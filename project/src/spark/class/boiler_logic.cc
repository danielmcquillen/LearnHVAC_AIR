/// \file  boiler_logic.cc
/// \brief Implementation as a SPARK model of the native EnergyPlus model 
///        named BOILER:SIMPLE implemented in the file PlantBoilers.f90
/// 
/// This model is used :
/// - to validate the SPARK/EnergyPlus link and 
/// - assess the overhead due to calling a SPARK model through the SPARK/EnergyPlus driver
///   as opposed to calling the native SUBROUTINE.
///


#ifdef SPARK_PARSER
 
PORT Qdot               [W]       "actual load generated by boiler";
PORT Qdot_requested     [W]       "requested load";
PORT Qdot_nominal       [W]       "nominal load capacity";

PORT T_inlet            [C]       "inlet water temperatue";
PORT T_outlet           [C]       "outlet water temperatue";
PORT T_setpoint         [C]       "set point for outlet water temperatue";
PORT T_limit            [C]       "upper limit for outlet water temperatue";

PORT mdot               [kg/s]    "actual mass flow rate through boiler";
PORT mdot_locked        [kg/s]    "resolved branch mass flow rate";
PORT mdot_tol           [kg/s]    "minimum significant mass flow rate";
PORT mdot_design        [kg/s]    "design mass flow rate";

PORT cp                 [J/(kg.K)] 
                        INIT=4187;

PORT FlowLockFlag       [{0=false,1=true}]    
                        INIT=0;
PORT FlowType           [{0=false,1=true}]    
                        INIT=1;

EQUATIONS {
    mdot,
    Qdot, 
    T_outlet = boiler_logic( 
        FlowLockFlag, 
        FlowType, 
        Qdot_requested, 
        Qdot_nominal, 
        T_inlet, 
        T_setpoint, 
        T_limit, 
        mdot_locked, 
        mdot_tol, 
        mdot_design, 
        cp ) ;
}

FUNCTIONS {
    mdot,
    Qdot, 
    T_outlet = boiler_logic__evaluate( 
        FlowLockFlag, 
        FlowType, 
        Qdot_requested, 
        Qdot_nominal, 
        T_inlet, 
        T_setpoint, 
        T_limit, 
        mdot_locked, 
        mdot_tol, 
        mdot_design,
        cp ) ;
}

#endif /* SPARK_PARSER */


#include "spark.h"
using std::cout;
using std::endl;

namespace SPARK {

    // Constant values match the ones used in PlantSPARKBoilers.f90
    // Defined as double to match the type of the flag variable it is compared to.
    const double CONSTANT_FLOW = 1.0;
    const double VARIABLE_FLOW = 2.0;

    /// \brief Returns true if flowType1 is equal to flowType2, whereby
    ///        flow types are represented by discrete values.
    inline bool IsFlow(double flowType1, double flowType2) 
    { 
        return SPARK::time_comparator::equal(flowType1, flowType2);
    }
    
    /// \brief Returns true if flag is set to 1; false otherwise
    inline bool IsTrue(double flag) { return flag > 0.5; }

    /// \brief Returns true if flag is set to 0; false otherwise
    inline bool IsFalse(double flag) { return !IsTrue(flag); }

};


/// Callback function used to evaluate the boiler logic
EVALUATE( boiler_logic__evaluate )
{
    ARGUMENT( 0, FlowLockFlag );
    ARGUMENT( 1, FlowType );
    ARGUMENT( 2, Qdot_requested );
    ARGUMENT( 3, Qdot_nominal );
    ARGUMENT( 4, T_inlet );
    ARGUMENT( 5, T_setpoint );
    ARGUMENT( 6, T_limit );
    ARGUMENT( 7, mdot_locked );
    ARGUMENT( 8, mdot_tol );
    ARGUMENT( 9, mdot_design );
    ARGUMENT(10, cp );

    double mdot;
    double Qdot;
    double T_outlet;

	//cout << "boiler logic says hi." << endl;
    
    // Calculate outlet conditions 

    // Flow request mode
    if ( SPARK::IsFalse(FlowLockFlag) ) {

        Qdot = Qdot_requested;

        // Constant flow boiler: set flow rate to design value
        if ( SPARK::IsFlow(FlowType, SPARK::CONSTANT_FLOW) ) {
            mdot = mdot_design;
            T_outlet = T_inlet + Qdot/(mdot*cp);
        }
        // Variable flow boiler: calculate delta temperature from the inlet temperature
        // to the boiler outlet setpoint, and derive the flow rate
        else {
            T_outlet = T_setpoint;
            
            double DeltaT = T_setpoint - T_inlet;
            if ( DeltaT != 0 ) {
                mdot = Qdot/(cp*DeltaT);
            }
            else {
                mdot = 0.0;
            }
        }

    }
    // Flow locked mode
    else {

        mdot = mdot_locked;

        double DeltaT = T_setpoint - T_inlet;
        
        // If boiler outlet temperature is already greater than setpoint then it does not 
        // need to operate
        if ( DeltaT <= 0.0 ) {
            Qdot = 0.0;
            T_outlet = T_inlet;
        }
        // Calculate the boiler load with the specified flow rate
        else {
            Qdot = mdot * cp * DeltaT;
            T_outlet = T_setpoint;
        }

        // If load exceeds the distributed load, setto the distributed load
        if ( Qdot > Qdot_requested ) {
            Qdot = Qdot_requested;
            T_outlet = T_inlet + Qdot/( mdot * cp );
        }

        // Check boiler load on the basis of the machine limits
        if ( Qdot > Qdot_nominal ) {
            if ( mdot > mdot_tol ) {
                Qdot = Qdot_nominal;
                T_outlet = T_inlet + Qdot/( mdot * cp );
            }
            else {
                Qdot = 0.0;
                T_outlet = T_inlet;
            }
        }
    }

    // If outlet temperature is greater than the max allowed temperature, trip boiler
    if ( T_outlet > T_limit ) {
        Qdot = 0.0;
        T_outlet = T_inlet;
    }


  // Return results
  BEGIN_RETURN
    mdot ,
    Qdot ,
    T_outlet , 
  END_RETURN  	


}

