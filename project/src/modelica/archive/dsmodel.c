/* DSblock model generated by Dymola from Modelica model LH_v2.HVAC_v2
 Dymola Version 7.3, 2009-09-15 translated this at Wed Mar 03 12:35:47 2010

  Advanced.NewStateSelection = true; // Due to used package.
 */

#include <matrixop.h>
static const char* DymArrays1[1]={"GasesPTDecoupled.SimpleAir"};
static const char* DymArrays0[1]={"SimpleLiquidWater"};
static double DymArrays4[3]={0.0, 0.0, 0.0};
static double DymArrays2[3]={1.888, 2.36, 2.832};
static double DymArrays3[3]={540.6, 460.8, 386.1};
/* Declaration of C-structs */
/* Prototypes for functions used in model */
#include "bcvtb.h"
#include "bcvtb.h"
#include "bcvtb.h"
DYMOLA_STATIC double   Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(
  double  y0_0, double  a0_0, double  b0_0, RealArray   cL0_0, RealArray   cU0_0,
   double  yL0_0, double  yU0_0);
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, int  linearized0_0);
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, int  linearized0_0,
   double  dpx_0der9, double  kx_0der9, double  mx_0flowx_0turbulentx_0der9);
DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, int  
  linearized0_0);
DYMOLA_STATIC RealArray    Buildings_Fluid_Movers_BaseClasses_Characteristics_derx_0solve
  (RealArray   A0_0, RealArray   x0_0, RealArray   Ader0_0, RealArray   xder0_0);
DYMOLA_STATIC RealArray    Buildings_Fluid_Movers_BaseClasses_Characteristics_solve
  (RealArray   A0_0, RealArray   x0_0);
DYMOLA_STATIC int   Buildings_Utilities_IO_BCVTB_BaseClasses_closeClientSocket_M
  (int  socketFD0_0);
DYMOLA_STATIC int   Buildings_Utilities_IO_BCVTB_BaseClasses_establishClientSocket_M
  (const char*  xmlFileName0_0);
struct Buildings_Utilities_IO_BCVTB_BaseClasses_exchangeReals_M_struct {
  int   flaRea0_0_0member;
  double   simTimRea0_0_0member;
  RealArray    dblValRea0_0_0member;
  int   retVal0_0_0member;
};
DYMOLA_STATIC struct Buildings_Utilities_IO_BCVTB_BaseClasses_exchangeReals_M_struct
   Buildings_Utilities_IO_BCVTB_BaseClasses_exchangeReals_M(int  socketFD0_0, 
  int  flaWri0_0, double  simTimWri0_0, RealArray   dblValWri0_0, int  
  nDblWri0_0, int  nDblRea0_0);
DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2(double  x0_0, double  
  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0);
DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0);
struct Modelica_Math_Matrices_LAPACK_dgesvx_0vec_M_struct {
  RealArray    x0_0_0member;
  int   info0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Matrices_LAPACK_dgesvx_0vec_M_struct 
  Modelica_Math_Matrices_LAPACK_dgesvx_0vec_M(RealArray   A0_0, RealArray   b0_0);
DYMOLA_STATIC RealArray    Modelica_Math_Matrices_solve(RealArray   A0_0, 
  RealArray   b0_0);
DYMOLA_STATIC double   Modelica_SIunits_Conversions_fromx_0degC(double  
  Celsius0_0);
DYMOLA_STATIC double   SupF_flowCharacteristicx_0Uniquez_0ccdbegeedddcebdedicc(
  double  Vx_0flow, RealArray   Vx_0flowx_0nominal, RealArray   dpx_0nominal);
DYMOLA_STATIC double   SupF_flowCharacteristicx_0Uniquez_0ccdbegeedddcebdedicc__derf
  (double  Vx_0flow, RealArray   Vx_0flowx_0nominal, RealArray   dpx_0nominal, 
  double  Vx_0flowx_0der6, RealArray   Vx_0flowx_0nominalx_0der6, RealArray   
  dpx_0nominalx_0der6);
/* Codes used in model */
/* Flattened Modelica model:

function Buildings.Fluid.Actuators.BaseClasses.exponentialDamper
  input Real y "Control signal, y=0 is closed, y=1 is open";
  input Real a "Coefficient a for damper characteristics";
  input Real b "Coefficient b for damper characteristics";
  input Real cL[3] "Polynomial coefficients for curve fit for y < yl";
  input Real cU[3] "Polynomial coefficients for curve fit for y > yu";
  input Real yL "Lower value for damper curve";
  input Real yU "Upper value for damper curve";
  output Real kTheta "Flow coefficient, kTheta = pressure drop divided by dynamic pressure";

algorithm 
  if (y < yL) then 
    kTheta := exp(cL[3]+y*(cL[2]+y*cL[1]));
  else
    if (y > yU) then 
      kTheta := exp(cU[3]+y*(cU[2]+y*cU[1]));
    else
      kTheta := exp(a+b*(1-y));
    end if;
  end if;
annotation(derivative=Buildings.Fluid.Actuators.BaseClasses.der_exponentialDamper,
   smoothOrder=1);
end Buildings.Fluid.Actuators.BaseClasses.exponentialDamper;
*/



DYMOLA_STATIC double   Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(
  double  y0_0, double  a0_0, double  b0_0, RealArray   cL0_0, RealArray   cU0_0,
   double  yL0_0, double  yU0_0) {
  PushContext("Buildings.Fluid.Actuators.BaseClasses.exponentialDamper")
  AssertModelica(RealSize( cL0_0,1)==3,"size(cL, 1) == 3","Dimension check of input to function failed");
  AssertModelica(RealSize( cU0_0,1)==3,"size(cU, 1) == 3","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   kTheta0_0;
    kTheta0_0=0;
    /* Start of real code */
      if (y0_0 < yL0_0) {
        kTheta0_0 = exp(RealVectorElement( cL0_0, (SizeType)( 3 ))+y0_0*(
          RealVectorElement( cL0_0, (SizeType)( 2 ))+y0_0*RealVectorElement( 
          cL0_0, (SizeType)( 1 ))));
      }
      else{
        if (y0_0 > yU0_0) {
          kTheta0_0 = exp(RealVectorElement( cU0_0, (SizeType)( 3 ))+y0_0*(
            RealVectorElement( cU0_0, (SizeType)( 2 ))+y0_0*RealVectorElement( 
            cU0_0, (SizeType)( 1 ))));
        }
        else{
          kTheta0_0 = exp(a0_0+b0_0*(1-y0_0));
        }
      }
    /* Output section */
    PopContext()
    return kTheta0_0;
  }}
/* Flattened Modelica model:

function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp
  input Real dp "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
  input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
  input Real m_flow_turbulent "Mass flow rate";
  input Boolean linearized := false "= true, use linear relation between m_flow and dp for any flow rate";
  output Real m_flow "Mass flow rate in design flow direction";
protected 
  Real dp_turbulent "Turbulent flow if |dp| >= dp_small, not a parameter because k can be a function of time";
  Real kSqu "Flow coefficient, kSqu=k^2=m_flow^2/|dp|";
  constant Real conv := 1 "Factor, needed to satisfy unit check";
  constant Real conv2 := sqrt(conv) "Factor, needed to satisfy unit check";
  public 
algorithm 
  kSqu := k*k;
  dp_turbulent := m_flow_turbulent^2/kSqu;
  if (linearized) then 
    m_flow := k*dp*conv2;
  else
    m_flow := Modelica.Fluid.Utilities.regRoot2(dp, dp_turbulent, kSqu, kSqu, 
      false, 1);
  end if;
annotation(derivative(zeroDerivative=linearized)=Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf,
   LateInline=true, smoothOrder=2);
end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp;
*/



DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, int  linearized0_0)
   {
  PushContext("Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dpx_0turbulent;
    double   kSqu0_0;
    double   conv0_0;
    double   conv20_0;
    mx_0flow=0;
    dpx_0turbulent=0;
    kSqu0_0=0;
    conv0_0 = 1;
    conv20_0 = sqrtGuarded(conv0_0,"conv");
    /* Start of real code */
      kSqu0_0 = k0_0*k0_0;
      dpx_0turbulent = divmacro(sqr(mx_0flowx_0turbulent),"m_flow_turbulent^2",
        kSqu0_0,"kSqu");
      if (linearized0_0) {
        mx_0flow = k0_0*dp0_0*conv20_0;
      }
      else{
        mx_0flow = Modelica_Fluid_Utilities_regRoot2(dp0_0, dpx_0turbulent, 
          kSqu0_0, kSqu0_0, false, 1);
      }
    /* Output section */
    PopContext()
    return mx_0flow;
  }}
/* Flattened Modelica model:

function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf
  input Real dp;
  input Real k;
  input Real m_flow_turbulent;
  input Boolean linearized := false;
protected 
  Real m_flow;
  Real dp_turbulent;
  Real kSqu;
  constant Real conv := 1;
  constant Real conv2 := sqrt(conv);
public 
  input Real dp_der9;
  input Real k_der9;
  input Real m_flow_turbulent_der9;
  output Real m_flow_der9;
protected 
  Real dp_turbulent_der9;
  Real kSqu_der9;
  public 
algorithm 
  kSqu_der9 := 2*k_der9*k;
  kSqu := k*k;
  dp_turbulent_der9 := 2*m_flow_turbulent*m_flow_turbulent_der9/kSqu-
    m_flow_turbulent^2*kSqu_der9/kSqu^2;
  dp_turbulent := m_flow_turbulent^2/kSqu;
  if (linearized) then 
    m_flow_der9 := (k_der9*dp+k*dp_der9)*conv2;
  else
    m_flow_der9 := Modelica.Fluid.Utilities.regRoot2:der(dp, dp_turbulent, kSqu,
       kSqu, false, 1, dp_der9, dp_turbulent_der9, kSqu_der9, kSqu_der9, 0);
  end if;
annotation(smoothOrder=1);
end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf;
*/



DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf
  (double  dp0_0, double  k0_0, double  mx_0flowx_0turbulent, int  linearized0_0,
   double  dpx_0der9, double  kx_0der9, double  mx_0flowx_0turbulentx_0der9) {
  PushContext("Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf")
  {
    /* Declare outputs and temporaries */
    double   mx_0flow;
    double   dpx_0turbulent;
    double   kSqu0_0;
    double   conv0_0;
    double   conv20_0;
    double   mx_0flowx_0der9;
    double   dpx_0turbulentx_0der9;
    double   kSqux_0der9;
    mx_0flow=0;
    dpx_0turbulent=0;
    kSqu0_0=0;
    conv0_0 = 1;
    conv20_0 = sqrtGuarded(conv0_0,"conv");
    mx_0flowx_0der9=0;
    dpx_0turbulentx_0der9=0;
    kSqux_0der9=0;
    /* Start of real code */
      kSqux_0der9 = 2*kx_0der9*k0_0;
      kSqu0_0 = k0_0*k0_0;
      dpx_0turbulentx_0der9 = divmacro(2*mx_0flowx_0turbulent*mx_0flowx_0turbulentx_0der9,
        "2*m_flow_turbulent*m_flow_turbulent_der9",kSqu0_0,"kSqu")-divmacro(sqr(
        mx_0flowx_0turbulent)*kSqux_0der9,"m_flow_turbulent^2*kSqu_der9",sqr(
        kSqu0_0),"kSqu^2");
      dpx_0turbulent = divmacro(sqr(mx_0flowx_0turbulent),"m_flow_turbulent^2",
        kSqu0_0,"kSqu");
      if (linearized0_0) {
        mx_0flowx_0der9 = (kx_0der9*dp0_0+k0_0*dpx_0der9)*conv20_0;
      }
      else{
        mx_0flowx_0der9 = Modelica_Fluid_Utilities_regRoot2__der(dp0_0, 
          dpx_0turbulent, kSqu0_0, kSqu0_0, false, 1, dpx_0der9, 
          dpx_0turbulentx_0der9, kSqux_0der9, kSqux_0der9, 0);
      }
    /* Output section */
    PopContext()
    return mx_0flowx_0der9;
  }}
/* Flattened Modelica model:

function Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow
  input Real m_flow "Mass flow rate in design flow direction";
  input Real k "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)";
  input Real m_flow_turbulent "Mass flow rate";
  input Boolean linearized := false "= true, use linear relation between m_flow and dp for any flow rate";
  output Real dp "Pressure difference between port_a and port_b (= port_a.p - port_b.p)";
protected 
  Real kSquInv "Flow coefficient";
  constant Real conv := 1 "Factor, needed to satisfy unit check";
  constant Real conv2 := sqrt(conv) "Factor, needed to satisfy unit check";
  public 
algorithm 
  kSquInv := 1/k^2;
  if (linearized) then 
    dp := m_flow/k/conv2;
  else
    dp := Modelica.Fluid.Utilities.regSquare2(m_flow, m_flow_turbulent, kSquInv,
       kSquInv, false, 1);
  end if;
annotation(LateInline=true, smoothOrder=2);
end Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow;
*/



DYMOLA_STATIC double   Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow
  (double  mx_0flow, double  k0_0, double  mx_0flowx_0turbulent, int  
  linearized0_0) {
  PushContext("Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow")
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    double   kSquInv0_0;
    double   conv0_0;
    double   conv20_0;
    dp0_0=0;
    kSquInv0_0=0;
    conv0_0 = 1;
    conv20_0 = sqrtGuarded(conv0_0,"conv");
    /* Start of real code */
      kSquInv0_0 = divmacro(1,"1",sqr(k0_0),"k^2");
      if (linearized0_0) {
        dp0_0 = divmacro(divmacro(mx_0flow,"m_flow",k0_0,"k"),"m_flow/k",
          conv20_0,"conv2");
      }
      else{
        dp0_0 = Modelica_Fluid_Utilities_regSquare2(mx_0flow, mx_0flowx_0turbulent,
           kSquInv0_0, kSquInv0_0, false, 1);
      }
    /* Output section */
    PopContext()
    return dp0_0;
  }}
/* Flattened Modelica model:

function Buildings.Utilities.IO.BCVTB.BaseClasses.closeClientSocket
  input Integer socketFD "Socket file descripter, or a negative value if an error occured";
  output Integer retVal "Return value of the function that closes the socket connection";

external "C" retVal := closeModelicaClient(socketFD);
annotation(Include="#include \"bcvtb.h\"", Library={"bcvtb_modelica"});
end Buildings.Utilities.IO.BCVTB.BaseClasses.closeClientSocket;
*/



DYMOLA_STATIC int   Buildings_Utilities_IO_BCVTB_BaseClasses_closeClientSocket_M
  (int  socketFD0_0) {
  PushContext("Buildings.Utilities.IO.BCVTB.BaseClasses.closeClientSocket")
  {
    /* Declare outputs and temporaries */
    int   retVal0_0;
    retVal0_0=0;
    /* Start of real code */
    {
      retVal0_0 = (closeModelicaClient)(socketFD0_0);
      }
    /* Output section */
    PopContext()
    return retVal0_0;
  }}
/* Flattened Modelica model:

function Buildings.Utilities.IO.BCVTB.BaseClasses.establishClientSocket
  input String xmlFileName := "socket.cfg" "Name of xml file that contains the socket information";
  output Integer socketFD "Socket file descripter, or a negative value if an error occured";

external "C" socketFD := establishModelicaClient(xmlFileName);
annotation(Include="#include \"bcvtb.h\"", Library={"bcvtb_modelica"});
end Buildings.Utilities.IO.BCVTB.BaseClasses.establishClientSocket;
*/



DYMOLA_STATIC int   Buildings_Utilities_IO_BCVTB_BaseClasses_establishClientSocket_M
  (const char*  xmlFileName0_0) {
  PushContext("Buildings.Utilities.IO.BCVTB.BaseClasses.establishClientSocket")
  {
    /* Declare outputs and temporaries */
    int   socketFD0_0;
    socketFD0_0=0;
    /* Start of real code */
    {
      socketFD0_0 = (establishModelicaClient)(xmlFileName0_0);
      }
    /* Output section */
    PopContext()
    return socketFD0_0;
  }}
/* Flattened Modelica model:

function Buildings.Utilities.IO.BCVTB.BaseClasses.exchangeReals
  input Integer socketFD "Socket file descripter";
  input Integer flaWri "Communication flag to write to the socket stream";
  input Real simTimWri "Current simulation time in seconds to write";
  input Real dblValWri[nDblWri] "Double values to write";
  input Integer nDblWri "Number of double values to write";
  input Integer nDblRea "Number of double values to read";
  output Integer flaRea "Communication flag read from the socket stream";
  output Real simTimRea "Current simulation time in seconds read from socket";
  output Real dblValRea[nDblRea] "Double values read from socket";
  output Integer retVal "The exit value, which is negative if an error occured";

external "C" retVal := exchangeModelicaClient(socketFD, flaWri, flaRea, 
  simTimWri, dblValWri, nDblWri, simTimRea, dblValRea, nDblRea);
annotation(Include="#include \"bcvtb.h\"", Library={"bcvtb_modelica"});
end Buildings.Utilities.IO.BCVTB.BaseClasses.exchangeReals;
*/



DYMOLA_STATIC struct Buildings_Utilities_IO_BCVTB_BaseClasses_exchangeReals_M_struct
   Buildings_Utilities_IO_BCVTB_BaseClasses_exchangeReals_M(int  socketFD0_0, 
  int  flaWri0_0, double  simTimWri0_0, RealArray   dblValWri0_0, int  
  nDblWri0_0, int  nDblRea0_0) {
  PushContext("Buildings.Utilities.IO.BCVTB.BaseClasses.exchangeReals")
  AssertModelica(RealSize( dblValWri0_0,1)==nDblWri0_0,"size(dblValWri, 1) == nDblWri","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    int   flaRea0_0;
    double   simTimRea0_0;
    RealArray    dblValRea0_0;
    int   retVal0_0;
    MarkObject retmark_ = PushMark();
    flaRea0_0=0;
    simTimRea0_0=0;
    dblValRea0_0=RealTemporary( 1, nDblRea0_0);
    RePushMark(&retmark_);
    RealFillAssign( dblValRea0_0, 0);
    retVal0_0=0;
    /* Start of real code */
    {
      retVal0_0 = (exchangeModelicaClient)(socketFD0_0, flaWri0_0, & flaRea0_0, 
        simTimWri0_0, dblValWri0_0.data, nDblWri0_0, & simTimRea0_0, 
        dblValRea0_0.data, nDblRea0_0);
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Buildings_Utilities_IO_BCVTB_BaseClasses_exchangeReals_M_struct out_;
      out_.flaRea0_0_0member = flaRea0_0;
      out_.simTimRea0_0_0member = simTimRea0_0;
      out_.dblValRea0_0_0member = dblValRea0_0;
      out_.retVal0_0_0member = retVal0_0;
      return out_;
    }
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.checkBoundary
  input String mediumName;
  input String substanceNames[:] "Names of substances";
  input Boolean singleState;
  input Boolean define_p;
  input Real X_boundary[:];
  input String modelName := "??? boundary ???";
protected 
  Integer nX := size(X_boundary, 1);
  String X_str;
  public 
algorithm 
  assert( not singleState or singleState and define_p, "
Wrong value of parameter define_p (= false) in model \""
    +modelName+"\":
The selected medium \""+mediumName+"\" has Medium.singleState=true.
Therefore, an boundary density cannot be defined and
define_p = true is required.
");
  for i in (1:nX) loop
    assert(X_boundary[i] >= 0, "
Wrong boundary mass fractions in medium \""+
      mediumName+"\" in model \""+modelName+"\":
The boundary value X_boundary("
      +       String(i, true, 0)+") = "+       String(X_boundary[i], true, 0)+
      "
is negative. It must be positive.
");
  end for;
  if (nX > 0 and abs(sum(X_boundary)-1) > 1E-010) then 
    X_str := "";
    for i in (1:nX) loop
      X_str := X_str+"   X_boundary["+       String(i, true, 0)+"] = "+
               String(X_boundary[i], true, 0)+" \""+substanceNames[i]+"\"\n";
    end for;
    ModelicaError("The boundary mass fractions in medium \""+mediumName+
      "\" in model \""+modelName+"\"\n"+"do not sum up to 1. Instead, sum(X_boundary) = "
      +       String(sum(X_boundary), true, 0)+":\n"+X_str);
  end if;
end Modelica.Fluid.Utilities.checkBoundary;
*/



DYMOLA_STATIC void Modelica_Fluid_Utilities_checkBoundary(const char*  
  mediumName0_0, StringArray   substanceNames0_0, int  singleState0_0, int  
  definex_0p, RealArray   Xx_0boundary, const char*  modelName0_0) {
  char*retSMark_=GetStringMark();
  PushContext("Modelica.Fluid.Utilities.checkBoundary")
  {
    /* Declare outputs and temporaries */
    int   nX0_0;
    const char*   Xx_0str;
    MarkObject retmark_ = PushMark();
    nX0_0 = RealSize( Xx_0boundary, 1);
    Xx_0str="";
    /* Start of real code */
      AssertModelica( NOT singleState0_0 OR singleState0_0 AND definex_0p,
        " not singleState or singleState and define_p", StringAdd(StringAdd(
        StringAdd(StringAdd("\nWrong value of parameter define_p (= false) in model \"",
        modelName0_0),"\":\nThe selected medium \""),mediumName0_0),
        "\" has Medium.singleState=true.\nTherefore, an boundary density cannot be defined and\ndefine_p = true is required.\n"));
      ;
      {
        int end_ = nX0_0;
        int i0_0_0;
        for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
          AssertModelica(RealElement( Xx_0boundary, (SizeType)( i0_0_0 )) >= 0,
            "X_boundary[i] >= 0", StringAdd(StringAdd(StringAdd(StringAdd(
            StringAdd(StringAdd(StringAdd(StringAdd("\nWrong boundary mass fractions in medium \"",
            mediumName0_0),"\" in model \""),modelName0_0),"\":\nThe boundary value X_boundary("),
            Integer2String2(i0_0_0, true, 0)),") = "),Real2String2(RealElement( 
            Xx_0boundary, (SizeType)( i0_0_0 )), true, 0)),"\nis negative. It must be positive.\n"));
          ;
        }
      }
      if (nX0_0 > 0 AND fabs(Realsum( Xx_0boundary)-1) > 1E-010) {
        Xx_0str = "";
        Release();
        {
          int end_ = nX0_0;
          int i0_0_0;
          for(i0_0_0 = 1;i0_0_0 <= end_;i0_0_0 += 1) {
            Xx_0str = StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
              StringAdd(StringAdd(Xx_0str,"   X_boundary["),Integer2String2(
              i0_0_0, true, 0)),"] = "),Real2String2(RealElement( Xx_0boundary, 
              (SizeType)( i0_0_0 )), true, 0))," \""),StringElement( 
              substanceNames0_0, (SizeType)( i0_0_0 ))),"\"\n");
          }
        }
        ModelicaError(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
          StringAdd(StringAdd(StringAdd("The boundary mass fractions in medium \"",
          mediumName0_0),"\" in model \""),modelName0_0),"\"\n"),
          "do not sum up to 1. Instead, sum(X_boundary) = "),Real2String2(
          Realsum( Xx_0boundary), true, 0)),":\n"),Xx_0str));
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    SetStringMark(retSMark_);
    PopContext()
    return ;
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2
  input Real x "abscissa value";
  input Real x_small := 0.01 "approximation of function for |x| <= x_small";
  input Real k1 := 1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
  input Real k2 := 1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|)";
  input Boolean use_yd0 := false "= true, if yd0 shall be used";
  input Real yd0 := 1 "Desired derivative at x=0: dy/dx = yd0";
  output Real y "ordinate value";

algorithm 
  y := smooth(2, (if x >= x_small then sqrt(k1*x) else (if x <=  -x_small then 
     -sqrt(k2*abs(x)) else (if k1 >= k2 then Modelica.Fluid.Utilities.regRoot2.regRoot2_utility
    (x, x_small, k1, k2, use_yd0, yd0) else  -Modelica.Fluid.Utilities.regRoot2.regRoot2_utility
    ( -x, x_small, k2, k1, use_yd0, yd0)))));
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regRoot2:der,
   smoothOrder=2);
end Modelica.Fluid.Utilities.regRoot2;
*/



DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2(double  x0_0, double  
  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regRoot2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 >= xx_0small THEN sqrtGuarded(k10_0*x0_0,"k1*x") ELSE IF 
        x0_0 <=  -xx_0small THEN  -sqrtGuarded(k20_0*fabs(x0_0),"k2*abs(x)")
         ELSE IF k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0) ELSE  -
        Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility( -x0_0, xx_0small, 
        k20_0, k10_0, usex_0yd0, yd00_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2.regRoot2_utility
  input Real x;
  input Real x1 "approximation of function abs(x) < x1";
  input Real k1 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|); k1 >= k2";
  input Real k2 "y = if x>=0 then sqrt(k1*x) else -sqrt(k2*|x|))";
  input Boolean use_yd0 "= true, if yd0 shall be used";
  input Real yd0 "Desired derivative at x=0: dy/dx = yd0";
  output Real y;
protected 
  Real x2;
  Real xsqrt1;
  Real xsqrt2;
  Real y1;
  Real y2;
  Real y1d;
  Real y2d;
  Real w;
  Real y0d;
  Real w1;
  Real w2;
  public 
algorithm 
  x2 :=  -x1*k2/k1;
  if (x <= x2) then 
    y :=  -sqrt(k2*abs(x));
  else
    y1 := sqrt(k1*x1);
    y2 :=  -sqrt(k2*abs(x2));
    y1d := 0.5*sqrt(k1/x1);
    y2d := 0.5*sqrt(k2/abs(x2));
    if (use_yd0) then 
      y0d := yd0;
    else
      w := x2/x1;
      y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
    end if;
    w1 := sqrt(8.75*k1/x1);
    w2 := sqrt(8.75*k2/abs(x2));
    y0d := min(y0d, 0.9*min(w1, w2));
    y := y1*(if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
      (x/x1, 1, 1, y1d*x1/y1, y0d*x1/y1) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
      (x/x1, x2/x1, y2/y1, y2d*x1/y1, y0d*x1/y1));
  end if;
annotation(derivative(zeroDerivative=use_yd0)=Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der,
   smoothOrder=2);
end Modelica.Fluid.Utilities.regRoot2.regRoot2_utility;
*/



DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regRoot2.regRoot2_utility")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   xsqrt10_0;
    double   xsqrt20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   y0d0_0;
    double   w10_0;
    double   w20_0;
    y0_0=0;
    x20_0=0;
    xsqrt10_0=0;
    xsqrt20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    y0d0_0=0;
    w10_0=0;
    w20_0=0;
    /* Start of real code */
      x20_0 =  -divmacro(x10_0*k20_0,"x1*k2",k10_0,"k1");
      if (x0_0 <= x20_0) {
        y0_0 =  -sqrtGuarded(k20_0*fabs(x0_0),"k2*abs(x)");
      }
      else{
        y10_0 = sqrtGuarded(k10_0*x10_0,"k1*x1");
        y20_0 =  -sqrtGuarded(k20_0*fabs(x20_0),"k2*abs(x2)");
        y1d0_0 = 0.5*sqrtGuarded(divmacro(k10_0,"k1",x10_0,"x1"),"k1/x1");
        y2d0_0 = 0.5*sqrtGuarded(divmacro(k20_0,"k2",fabs(x20_0),"abs(x2)"),
          "k2/abs(x2)");
        if (usex_0yd0) {
          y0d0_0 = yd00_0;
        }
        else{
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w10_0 = sqrtGuarded(divmacro(8.75*k10_0,"8.75*k1",x10_0,"x1"),
          "8.75*k1/x1");
        w20_0 = sqrtGuarded(divmacro(8.75*k20_0,"8.75*k2",fabs(x20_0),"abs(x2)"),
          "8.75*k2/abs(x2)");
        y0d0_0 = RealBmin(y0d0_0, 0.9*RealBmin(w10_0, w20_0));
        y0_0 = y10_0*(IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (divmacro(x0_0,"x",x10_0,"x1"), 1, 1, divmacro(y1d0_0*x10_0,"y1d*x1",
          y10_0,"y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1")) ELSE 
          Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero(divmacro(
          x0_0,"x",x10_0,"x1"), divmacro(x20_0,"x2",x10_0,"x1"), divmacro(y20_0,
          "y2",y10_0,"y1"), divmacro(y2d0_0*x10_0,"y2d*x1",y10_0,"y1"), divmacro
          (y0d0_0*x10_0,"y0d*x1",y10_0,"y1")));
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2:der
  input Real x;
  input Real x_small := 0.01;
  input Real k1 := 1;
  input Real k2 := 1;
  input Boolean use_yd0 := false;
  input Real yd0 := 1;
protected 
  Real y;
public 
  input Real x_der;
  input Real x_small_der := 0;
  input Real k1_der := 0;
  input Real k2_der := 0;
  input Real yd0_der := 0;
  output Real y_der;

algorithm 
  y_der := smooth(1, (if x >= x_small then 0.5*(k1_der*x+k1*x_der)/sqrt(k1*x)
     else (if x <=  -x_small then  -0.5*(k2_der*abs(x)+k2*x_der*noEvent((if x > 0
     then 1 else -1)))/sqrt(k2*abs(x)) else (if k1 >= k2 then Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der
    (x, x_small, k1, k2, use_yd0, yd0, x_der, x_small_der, k1_der, k2_der, 
    yd0_der) else  -Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der( -x, 
    x_small, k2, k1, use_yd0, yd0,  -x_der, x_small_der, k2_der, k1_der, yd0_der)))));
annotation(smoothOrder=1);
end Modelica.Fluid.Utilities.regRoot2:der;
*/



DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2__der(double  x0_0, 
  double  xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  
  yd00_0, double  xx_0der, double  xx_0smallx_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regRoot2:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   yx_0der;
    y0_0=0;
    yx_0der=0;
    /* Start of real code */
      yx_0der = IF x0_0 >= xx_0small THEN divmacro(0.5*(k1x_0der*x0_0+k10_0*
        xx_0der),"0.5*(k1_der*x+k1*x_der)",sqrtGuarded(k10_0*x0_0,"k1*x"),
        "sqrt(k1*x)") ELSE IF x0_0 <=  -xx_0small THEN  -divmacro(0.5*(k2x_0der*
        fabs(x0_0)+k20_0*xx_0der*(IF x0_0 > 0 THEN 1 ELSE -1)),"0.5*(k2_der*abs(x)+k2*x_der*noEvent((if x > 0 then 1 else -1)))",
        sqrtGuarded(k20_0*fabs(x0_0),"k2*abs(x)"),"sqrt(k2*abs(x))") ELSE IF 
        k10_0 >= k20_0 THEN Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility__der
        (x0_0, xx_0small, k10_0, k20_0, usex_0yd0, yd00_0, xx_0der, 
        xx_0smallx_0der, k1x_0der, k2x_0der, yd0x_0der) ELSE  -Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility__der
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0,  -xx_0der, 
        xx_0smallx_0der, k2x_0der, k1x_0der, yd0x_0der);
    /* Output section */
    PopContext()
    return yx_0der;
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2
  input Real x "abscissa value";
  input Real x_small := 0.01 "approximation of function for |x| <= x_small";
  input Real k1 := 1 "y = (if x>=0 then k1 else k2)*x*|x|";
  input Real k2 := 1 "y = (if x>=0 then k1 else k2)*x*|x|";
  input Boolean use_yd0 := false "= true, if yd0 shall be used";
  input Real yd0 := 1 "Desired derivative at x=0: dy/dx = yd0";
  output Real y "ordinate value";

algorithm 
  y := smooth(2, (if x >= x_small then k1*x^2 else (if x <=  -x_small then  -k2*
    x^2 else (if k1 >= k2 then Modelica.Fluid.Utilities.regSquare2.regSquare2_utility
    (x, x_small, k1, k2, use_yd0, yd0) else  -Modelica.Fluid.Utilities.regSquare2.regSquare2_utility
    ( -x, x_small, k2, k1, use_yd0, yd0)))));
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2;
*/



DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2(double  x0_0, double 
   xx_0small, double  k10_0, double  k20_0, int  usex_0yd0, double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    y0_0=0;
    /* Start of real code */
      y0_0 = IF x0_0 >= xx_0small THEN k10_0*sqr(x0_0) ELSE IF x0_0 <=  -
        xx_0small THEN  -k20_0*sqr(x0_0) ELSE IF k10_0 >= k20_0 THEN 
        Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(x0_0, xx_0small,
         k10_0, k20_0, usex_0yd0, yd00_0) ELSE  -Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility
        ( -x0_0, xx_0small, k20_0, k10_0, usex_0yd0, yd00_0);
    /* Output section */
    PopContext()
    return y0_0;
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regSquare2.regSquare2_utility
  input Real x;
  input Real x1 "approximation of function abs(x) < x1";
  input Real k1 "y = (if x>=0 then k1 else -k2)*x*|x|; k1 >= k2";
  input Real k2 "y = (if x>=0 then k1 else -k2)*x*|x|";
  input Boolean use_yd0 := false "= true, if yd0 shall be used";
  input Real yd0 := 1 "Desired derivative at x=0: dy/dx = yd0";
  output Real y;
protected 
  Real x2;
  Real y1;
  Real y2;
  Real y1d;
  Real y2d;
  Real w;
  Real w1;
  Real w2;
  Real y0d;
  public 
algorithm 
  x2 :=  -x1;
  if (x <= x2) then 
    y :=  -k2*x^2;
  else
    y1 := k1*x1^2;
    y2 :=  -k2*x2^2;
    y1d := 2*k1*x1;
    y2d := (-2)*k2*x2;
    if (use_yd0) then 
      y0d := yd0;
    else
      w := x2/x1;
      y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
    end if;
    w1 := 2.23606797749979*k1*x1;
    w2 := 2.23606797749979*k2*abs(x2);
    y0d := min(y0d, 0.9*min(w1, w2));
    y := (if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
      (x, x1, y1, y1d, y0d) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
      (x, x2, y2, y2d, y0d));
  end if;
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.regSquare2.regSquare2_utility;
*/



DYMOLA_STATIC double   Modelica_Fluid_Utilities_regSquare2_regSquare2x_0utility(
  double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0) {
  PushContext("Modelica.Fluid.Utilities.regSquare2.regSquare2_utility")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   w10_0;
    double   w20_0;
    double   y0d0_0;
    y0_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    w10_0=0;
    w20_0=0;
    y0d0_0=0;
    /* Start of real code */
      x20_0 =  -x10_0;
      if (x0_0 <= x20_0) {
        y0_0 =  -k20_0*sqr(x0_0);
      }
      else{
        y10_0 = k10_0*sqr(x10_0);
        y20_0 =  -k20_0*sqr(x20_0);
        y1d0_0 = 2*k10_0*x10_0;
        y2d0_0 = (-2)*k20_0*x20_0;
        if (usex_0yd0) {
          y0d0_0 = yd00_0;
        }
        else{
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w10_0 = 2.23606797749979*k10_0*x10_0;
        w20_0 = 2.23606797749979*k20_0*fabs(x20_0);
        y0d0_0 = RealBmin(y0d0_0, 0.9*RealBmin(w10_0, w20_0));
        y0_0 = IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x10_0, y10_0, y1d0_0, y0d0_0) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (x0_0, x20_0, y20_0, y2d0_0, y0d0_0);
      }
    /* Output section */
    PopContext()
    return y0_0;
  }}
/* Flattened Modelica model:

function Modelica.SIunits.Conversions.from_degC
  input Real Celsius "Celsius value";
  output Real Kelvin "Kelvin value";

algorithm 
  Kelvin := 273.15+Celsius;
end Modelica.SIunits.Conversions.from_degC;
*/



DYMOLA_STATIC double   Modelica_SIunits_Conversions_fromx_0degC(double  
  Celsius0_0) {
  PushContext("Modelica.SIunits.Conversions.from_degC")
  {
    /* Declare outputs and temporaries */
    double   Kelvin0_0;
    Kelvin0_0=0;
    /* Start of real code */
      Kelvin0_0 = 273.15+Celsius0_0;
    /* Output section */
    PopContext()
    return Kelvin0_0;
  }}
/* Flattened Modelica model:

function SupF.flowCharacteristic_Unique'"1FD32A48"'
  input Real V_flow "Volumetric flow rate";
  output Real dp "Fan or pump total pressure";
  input Real V_flow_nominal[3] "Volume flow rate for three operating points (single fan or pump)";
  input Real dp_nominal[3] "Fan or pump total pressure for three operating points";
protected 
  Real V_flow_nominal2[3] := {V_flow_nominal[1]^2, V_flow_nominal[2]^2, 
    V_flow_nominal[3]^2} "Squared nominal flow rates";
  Real c[3] := Buildings.Fluid.Movers.BaseClasses.Characteristics.solve([ones(3),
     V_flow_nominal, V_flow_nominal2], dp_nominal) "Coefficients of quadratic total pressure curve";
  public 
algorithm 
  dp := c[1]+V_flow*c[2]+V_flow^2*c[3];
annotation(derivative=SupF.flowCharacteristic_Unique'"1FD32A48"':derf, 
  smoothOrder=100);
end SupF.flowCharacteristic_Unique'"1FD32A48"';
*/



DYMOLA_STATIC double   SupF_flowCharacteristicx_0Uniquez_0ccdbegeedddcebdedicc(
  double  Vx_0flow, RealArray   Vx_0flowx_0nominal, RealArray   dpx_0nominal) {
  PushContext("SupF.flowCharacteristic_Unique'\"1FD32A48\"'")
  AssertModelica(RealSize( Vx_0flowx_0nominal,1)==3,"size(V_flow_nominal, 1) == 3","Dimension check of input to function failed");
  AssertModelica(RealSize( dpx_0nominal,1)==3,"size(dp_nominal, 1) == 3","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    RealArray    Vx_0flowx_0nominal2;
    RealArray    c0_0;
    MarkObject retmark_ = PushMark();
    dp0_0=0;
    Vx_0flowx_0nominal2=RealTemporary( 1, 3);
    PushMark();
    RealAssign (Vx_0flowx_0nominal2, RealScalarArray ( 3, sqr(RealVectorElement( 
      Vx_0flowx_0nominal, (SizeType)( 1 ))), sqr(RealVectorElement( 
      Vx_0flowx_0nominal, (SizeType)( 2 ))), sqr(RealVectorElement( 
      Vx_0flowx_0nominal, (SizeType)( 3 )))));
    Release();
    c0_0=RealTemporary( 1, 3);
    PushMark();
    RealAssign (c0_0, Buildings_Fluid_Movers_BaseClasses_Characteristics_solve((
      RealCat( 2, 3, RealPromote( RealConvertInteger (IntegerFill( 1, 1, (SizeType)(3))),
       2), RealPromote( Vx_0flowx_0nominal, 2), RealPromote( Vx_0flowx_0nominal2,
       2))), dpx_0nominal));
    Release();
    /* Start of real code */
      dp0_0 = RealVectorElement( c0_0, (SizeType)( 1 ))+Vx_0flow*
        RealVectorElement( c0_0, (SizeType)( 2 ))+sqr(Vx_0flow)*RealVectorElement( 
        c0_0, (SizeType)( 3 ));
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return dp0_0;
  }}
/* Flattened Modelica model:

function SupF.flowCharacteristic_Unique'"1FD32A48"':derf
  input Real V_flow;
protected 
  Real dp;
public 
  input Real V_flow_nominal[3];
  input Real dp_nominal[3];
protected 
  Real V_flow_nominal2[3] := {V_flow_nominal[1]^2, V_flow_nominal[2]^2, 
    V_flow_nominal[3]^2};
  Real c[3] := Buildings.Fluid.Movers.BaseClasses.Characteristics.solve([ones(3),
     V_flow_nominal, V_flow_nominal2], dp_nominal);
public 
  input Real V_flow_der6;
  output Real dp_der6;
  input Real V_flow_nominal_der6[3] := {0, 0, 0};
  input Real dp_nominal_der6[3] := {0, 0, 0};
protected 
  Real V_flow_nominal2_der6[3] := {2*V_flow_nominal[1]*V_flow_nominal_der6[1], 2
    *V_flow_nominal[2]*V_flow_nominal_der6[2], 2*V_flow_nominal[3]*
    V_flow_nominal_der6[3]};
  Real c_der6[3] := Buildings.Fluid.Movers.BaseClasses.Characteristics.der_solve
    ([ones(3), V_flow_nominal, V_flow_nominal2], dp_nominal, [{0, 0, 0}, 
    V_flow_nominal_der6, V_flow_nominal2_der6], dp_nominal_der6);
  public 
algorithm 
  dp_der6 := c_der6[1]+V_flow_der6*c[2]+V_flow*c_der6[2]+2*V_flow*V_flow_der6*c[3]
    +V_flow^2*c_der6[3];
annotation(smoothOrder=99);
end SupF.flowCharacteristic_Unique'"1FD32A48"':derf;
*/



DYMOLA_STATIC double   SupF_flowCharacteristicx_0Uniquez_0ccdbegeedddcebdedicc__derf
  (double  Vx_0flow, RealArray   Vx_0flowx_0nominal, RealArray   dpx_0nominal, 
  double  Vx_0flowx_0der6, RealArray   Vx_0flowx_0nominalx_0der6, RealArray   
  dpx_0nominalx_0der6) {
  PushContext("SupF.flowCharacteristic_Unique'\"1FD32A48\"':derf")
  AssertModelica(RealSize( Vx_0flowx_0nominal,1)==3,"size(V_flow_nominal, 1) == 3","Dimension check of input to function failed");
  AssertModelica(RealSize( dpx_0nominal,1)==3,"size(dp_nominal, 1) == 3","Dimension check of input to function failed");
  AssertModelica(RealSize( Vx_0flowx_0nominalx_0der6,1)==3,"size(V_flow_nominal_der6, 1) == 3","Dimension check of input to function failed");
  AssertModelica(RealSize( dpx_0nominalx_0der6,1)==3,"size(dp_nominal_der6, 1) == 3","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   dp0_0;
    RealArray    Vx_0flowx_0nominal2;
    RealArray    c0_0;
    double   dpx_0der6;
    RealArray    Vx_0flowx_0nominal2x_0der6;
    RealArray    cx_0der6;
    MarkObject retmark_ = PushMark();
    dp0_0=0;
    Vx_0flowx_0nominal2=RealTemporary( 1, 3);
    PushMark();
    RealAssign (Vx_0flowx_0nominal2, RealScalarArray ( 3, sqr(RealVectorElement( 
      Vx_0flowx_0nominal, (SizeType)( 1 ))), sqr(RealVectorElement( 
      Vx_0flowx_0nominal, (SizeType)( 2 ))), sqr(RealVectorElement( 
      Vx_0flowx_0nominal, (SizeType)( 3 )))));
    Release();
    c0_0=RealTemporary( 1, 3);
    PushMark();
    RealAssign (c0_0, Buildings_Fluid_Movers_BaseClasses_Characteristics_solve((
      RealCat( 2, 3, RealPromote( RealConvertInteger (IntegerFill( 1, 1, (SizeType)(3))),
       2), RealPromote( Vx_0flowx_0nominal, 2), RealPromote( Vx_0flowx_0nominal2,
       2))), dpx_0nominal));
    Release();
    dpx_0der6=0;
    Vx_0flowx_0nominal2x_0der6=RealTemporary( 1, 3);
    PushMark();
    RealAssign (Vx_0flowx_0nominal2x_0der6, RealScalarArray ( 3, 2*
      RealVectorElement( Vx_0flowx_0nominal, (SizeType)( 1 ))*RealVectorElement( 
      Vx_0flowx_0nominalx_0der6, (SizeType)( 1 )), 2*RealVectorElement( 
      Vx_0flowx_0nominal, (SizeType)( 2 ))*RealVectorElement( Vx_0flowx_0nominalx_0der6,
       (SizeType)( 2 )), 2*RealVectorElement( Vx_0flowx_0nominal, (SizeType)( 3
       ))*RealVectorElement( Vx_0flowx_0nominalx_0der6, (SizeType)( 3 ))));
    Release();
    cx_0der6=RealTemporary( 1, 3);
    PushMark();
    RealAssign (cx_0der6, Buildings_Fluid_Movers_BaseClasses_Characteristics_derx_0solve
      ((RealCat( 2, 3, RealPromote( RealConvertInteger (IntegerFill( 1, 1, (SizeType)(3))),
       2), RealPromote( Vx_0flowx_0nominal, 2), RealPromote( Vx_0flowx_0nominal2,
       2))), dpx_0nominal, (RealCat( 2, 3, RealPromote( RealTemporaryDense( 
      DymArrays4, 1, 3), 2), RealPromote( Vx_0flowx_0nominalx_0der6, 2), 
      RealPromote( Vx_0flowx_0nominal2x_0der6, 2))), dpx_0nominalx_0der6));
    Release();
    /* Start of real code */
      dpx_0der6 = RealVectorElement( cx_0der6, (SizeType)( 1 ))+Vx_0flowx_0der6*
        RealVectorElement( c0_0, (SizeType)( 2 ))+Vx_0flow*RealVectorElement( 
        cx_0der6, (SizeType)( 2 ))+2*Vx_0flow*Vx_0flowx_0der6*RealVectorElement( 
        c0_0, (SizeType)( 3 ))+sqr(Vx_0flow)*RealVectorElement( cx_0der6, 
        (SizeType)( 3 ));
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return dpx_0der6;
  }}
/* Flattened Modelica model:

function Buildings.Fluid.Movers.BaseClasses.Characteristics.der_solve
  input Real A[:, size(A, 1)];
  input Real x[size(A, 1)];
  input Real Ader[:, size(A, 1)];
  input Real xder[size(A, 1)];
  output Real b[size(A, 1)];

algorithm 
  b := Modelica.Math.Matrices.solve(A, xder-Ader*Modelica.Math.Matrices.solve(A,
     x));
end Buildings.Fluid.Movers.BaseClasses.Characteristics.der_solve;
*/



DYMOLA_STATIC RealArray    Buildings_Fluid_Movers_BaseClasses_Characteristics_derx_0solve
  (RealArray   A0_0, RealArray   x0_0, RealArray   Ader0_0, RealArray   xder0_0)
   {
  PushContext("Buildings.Fluid.Movers.BaseClasses.Characteristics.der_solve")
  AssertModelica(RealSize( A0_0,2)==RealSize( A0_0, 1),"size(A, 2) == size(A, 1)","Dimension check of input to function failed");
  AssertModelica(RealSize( x0_0,1)==RealSize( A0_0, 1),"size(x, 1) == size(A, 1)","Dimension check of input to function failed");
  AssertModelica(RealSize( Ader0_0,2)==RealSize( A0_0, 1),"size(Ader, 2) == size(A, 1)","Dimension check of input to function failed");
  AssertModelica(RealSize( xder0_0,1)==RealSize( A0_0, 1),"size(xder, 1) == size(A, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    b0_0;
    MarkObject retmark_ = PushMark();
    b0_0=RealTemporary( 1, RealSize( A0_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    /* Start of real code */
      RealAssign (b0_0, Modelica_Math_Matrices_solve(A0_0, RealSubtract (xder0_0,
        RealMultiplyMV (Ader0_0,Modelica_Math_Matrices_solve(A0_0, x0_0)))));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return b0_0;
  }}
/* Flattened Modelica model:

function Buildings.Fluid.Movers.BaseClasses.Characteristics.solve
  input Real A[:, size(A, 1)];
  input Real x[size(A, 1)];
  output Real b[size(A, 1)];

algorithm 
  b := Modelica.Math.Matrices.solve(A, x);
annotation(derivative=Buildings.Fluid.Movers.BaseClasses.Characteristics.der_solve);
end Buildings.Fluid.Movers.BaseClasses.Characteristics.solve;
*/



DYMOLA_STATIC RealArray    Buildings_Fluid_Movers_BaseClasses_Characteristics_solve
  (RealArray   A0_0, RealArray   x0_0) {
  PushContext("Buildings.Fluid.Movers.BaseClasses.Characteristics.solve")
  AssertModelica(RealSize( A0_0,2)==RealSize( A0_0, 1),"size(A, 2) == size(A, 1)","Dimension check of input to function failed");
  AssertModelica(RealSize( x0_0,1)==RealSize( A0_0, 1),"size(x, 1) == size(A, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    b0_0;
    MarkObject retmark_ = PushMark();
    b0_0=RealTemporary( 1, RealSize( A0_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( b0_0, 0);
    /* Start of real code */
      RealAssign (b0_0, Modelica_Math_Matrices_solve(A0_0, x0_0));
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return b0_0;
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
  input Real x "Value for which polynomial shall be evaluated";
  input Real x1 "Abscissa value";
  input Real y1 "y1=f(x1)";
  input Real y1d "First derivative at y1";
  input Real y0d "First derivative at f(x=0)";
  output Real y;
protected 
  Real a1;
  Real a2;
  Real a3;
  Real xx;
  public 
algorithm 
  a1 := x1*y0d;
  a2 := 3*y1-x1*y1d-2*a1;
  a3 := y1-a2-a1;
  xx := x/x1;
  y := xx*(a1+xx*(a2+xx*a3));
annotation(derivative=Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der,
   smoothOrder=3);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero;
*/



DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    /* Start of real code */
      a10_0 = x10_0*y0d0_0;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a30_0 = y10_0-a20_0-a10_0;
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      y0_0 = xx0_0*(a10_0+xx0_0*(a20_0+xx0_0*a30_0));
    /* Output section */
    PopContext()
    return y0_0;
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der
  input Real x;
  input Real x1;
  input Real k1;
  input Real k2;
  input Boolean use_yd0;
  input Real yd0;
protected 
  Real y;
  Real x2;
  Real xsqrt1;
  Real xsqrt2;
  Real y1;
  Real y2;
  Real y1d;
  Real y2d;
  Real w;
  Real y0d;
  Real w1;
  Real w2;
public 
  input Real x_der;
  input Real x1_der;
  input Real k1_der;
  input Real k2_der;
  input Real yd0_der;
  output Real y_der;
protected 
  Real x2_der;
  Real xsqrt1_der;
  Real xsqrt2_der;
  Real y1_der;
  Real y2_der;
  Real y1d_der;
  Real y2d_der;
  Real w_der;
  Real y0d_der;
  Real w1_der;
  Real w2_der;
  public 
algorithm 
  x2_der := x1*k2*k1_der/k1^2-(x1_der*k2+x1*k2_der)/k1;
  x2 :=  -x1*k2/k1;
  if (x <= x2) then 
    y_der :=  -0.5*(k2_der*abs(x)+k2*x_der*noEvent((if x > 0 then 1 else -1)))/
      sqrt(k2*abs(x));
  else
    y1_der := 0.5*(k1_der*x1+k1*x1_der)/sqrt(k1*x1);
    y1 := sqrt(k1*x1);
    y2_der :=  -0.5*(k2_der*abs(x2)+k2*x2_der*noEvent((if x2 > 0 then 1 else -1)))
      /sqrt(k2*abs(x2));
    y2 :=  -sqrt(k2*abs(x2));
    y1d_der := 0.25*(k1_der/x1-k1*x1_der/x1^2)/sqrt(k1/x1);
    y1d := 0.5*sqrt(k1/x1);
    y2d_der := 0.25*(k2_der/abs(x2)-k2*x2_der*noEvent((if x2 > 0 then 1 else -1))
      /abs(x2)^2)/sqrt(k2/abs(x2));
    y2d := 0.5*sqrt(k2/abs(x2));
    if (use_yd0) then 
      y0d_der := yd0_der;
      y0d := yd0;
    else
      w_der := x2_der/x1-x2*x1_der/x1^2;
      w := x2/x1;
      y0d_der := ((3*y2_der-(x2_der*y2d+x2*y2d_der))/w-(3*y2-x2*y2d)*w_der/w^2-(
        (3*y1_der-(x1_der*y1d+x1*y1d_der))*w+(3*y1-x1*y1d)*w_der))/(2*x1*(1-w))-2
        *((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)*(x1_der*(1-w)-x1*w_der)/(2*x1*(1-w))^2;
      y0d := ((3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w)/(2*x1*(1-w));
    end if;
    w1_der := 0.5*(8.75*k1_der/x1-8.75*k1*x1_der/x1^2)/sqrt(8.75*k1/x1);
    w1 := sqrt(8.75*k1/x1);
    w2_der := 0.5*(8.75*k2_der/abs(x2)-8.75*k2*x2_der*noEvent((if x2 > 0 then 1
       else -1))/abs(x2)^2)/sqrt(8.75*k2/abs(x2));
    w2 := sqrt(8.75*k2/abs(x2));
    y0d_der := (if noEvent(y0d < 0.9*min(w1, w2)) then y0d_der else 0.9*(if 
      noEvent(w1 < w2) then w1_der else w2_der));
    y0d := min(y0d, 0.9*min(w1, w2));
    y_der := y1_der*(if x >= 0 then Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
      (x/x1, 1, 1, y1d*x1/y1, y0d*x1/y1) else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero
      (x/x1, x2/x1, y2/y1, y2d*x1/y1, y0d*x1/y1))+y1*(if x >= 0 then 
      Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x/x1, 1, 1, 
      y1d*x1/y1, y0d*x1/y1, x_der/x1-x*x1_der/x1^2, 0, 0, (y1d_der*x1+y1d*x1_der)
      /y1-y1d*x1*y1_der/y1^2, (y0d_der*x1+y0d*x1_der)/y1-y0d*x1*y1_der/y1^2)
       else Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der(x/x1, x2
      /x1, y2/y1, y2d*x1/y1, y0d*x1/y1, x_der/x1-x*x1_der/x1^2, x2_der/x1-x2*
      x1_der/x1^2, y2_der/y1-y2*y1_der/y1^2, (y2d_der*x1+y2d*x1_der)/y1-y2d*x1*
      y1_der/y1^2, (y0d_der*x1+y0d*x1_der)/y1-y0d*x1*y1_der/y1^2));
  end if;
annotation(smoothOrder=1);
end Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der;
*/



DYMOLA_STATIC double   Modelica_Fluid_Utilities_regRoot2_regRoot2x_0utility__der
  (double  x0_0, double  x10_0, double  k10_0, double  k20_0, int  usex_0yd0, 
  double  yd00_0, double  xx_0der, double  x1x_0der, double  k1x_0der, double  
  k2x_0der, double  yd0x_0der) {
  PushContext("Modelica.Fluid.Utilities.regRoot2.regRoot2_utility:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   x20_0;
    double   xsqrt10_0;
    double   xsqrt20_0;
    double   y10_0;
    double   y20_0;
    double   y1d0_0;
    double   y2d0_0;
    double   w0_0;
    double   y0d0_0;
    double   w10_0;
    double   w20_0;
    double   yx_0der;
    double   x2x_0der;
    double   xsqrt1x_0der;
    double   xsqrt2x_0der;
    double   y1x_0der;
    double   y2x_0der;
    double   y1dx_0der;
    double   y2dx_0der;
    double   wx_0der;
    double   y0dx_0der;
    double   w1x_0der;
    double   w2x_0der;
    y0_0=0;
    x20_0=0;
    xsqrt10_0=0;
    xsqrt20_0=0;
    y10_0=0;
    y20_0=0;
    y1d0_0=0;
    y2d0_0=0;
    w0_0=0;
    y0d0_0=0;
    w10_0=0;
    w20_0=0;
    yx_0der=0;
    x2x_0der=0;
    xsqrt1x_0der=0;
    xsqrt2x_0der=0;
    y1x_0der=0;
    y2x_0der=0;
    y1dx_0der=0;
    y2dx_0der=0;
    wx_0der=0;
    y0dx_0der=0;
    w1x_0der=0;
    w2x_0der=0;
    /* Start of real code */
      x2x_0der = divmacro(x10_0*k20_0*k1x_0der,"x1*k2*k1_der",sqr(k10_0),"k1^2")
        -divmacro(x1x_0der*k20_0+x10_0*k2x_0der,"x1_der*k2+x1*k2_der",k10_0,"k1");
      x20_0 =  -divmacro(x10_0*k20_0,"x1*k2",k10_0,"k1");
      if (x0_0 <= x20_0) {
        yx_0der =  -divmacro(0.5*(k2x_0der*fabs(x0_0)+k20_0*xx_0der*(IF x0_0 > 0
           THEN 1 ELSE -1)),"0.5*(k2_der*abs(x)+k2*x_der*noEvent((if x > 0 then 1 else -1)))",
          sqrtGuarded(k20_0*fabs(x0_0),"k2*abs(x)"),"sqrt(k2*abs(x))");
      }
      else{
        y1x_0der = divmacro(0.5*(k1x_0der*x10_0+k10_0*x1x_0der),"0.5*(k1_der*x1+k1*x1_der)",
          sqrtGuarded(k10_0*x10_0,"k1*x1"),"sqrt(k1*x1)");
        y10_0 = sqrtGuarded(k10_0*x10_0,"k1*x1");
        y2x_0der =  -divmacro(0.5*(k2x_0der*fabs(x20_0)+k20_0*x2x_0der*(IF x20_0
           > 0 THEN 1 ELSE -1)),"0.5*(k2_der*abs(x2)+k2*x2_der*noEvent((if x2 > 0 then 1 else -1)))",
          sqrtGuarded(k20_0*fabs(x20_0),"k2*abs(x2)"),"sqrt(k2*abs(x2))");
        y20_0 =  -sqrtGuarded(k20_0*fabs(x20_0),"k2*abs(x2)");
        y1dx_0der = divmacro(0.25*(divmacro(k1x_0der,"k1_der",x10_0,"x1")-
          divmacro(k10_0*x1x_0der,"k1*x1_der",sqr(x10_0),"x1^2")),
          "0.25*(k1_der/x1-k1*x1_der/x1^2)",sqrtGuarded(divmacro(k10_0,"k1",
          x10_0,"x1"),"k1/x1"),"sqrt(k1/x1)");
        y1d0_0 = 0.5*sqrtGuarded(divmacro(k10_0,"k1",x10_0,"x1"),"k1/x1");
        y2dx_0der = divmacro(0.25*(divmacro(k2x_0der,"k2_der",fabs(x20_0),
          "abs(x2)")-divmacro(k20_0*x2x_0der*(IF x20_0 > 0 THEN 1 ELSE -1),
          "k2*x2_der*noEvent((if x2 > 0 then 1 else -1))",sqr(fabs(x20_0)),
          "abs(x2)^2")),"0.25*(k2_der/abs(x2)-k2*x2_der*noEvent((if x2 > 0 then 1 else -1))/abs(x2)^2)",
          sqrtGuarded(divmacro(k20_0,"k2",fabs(x20_0),"abs(x2)"),"k2/abs(x2)"),
          "sqrt(k2/abs(x2))");
        y2d0_0 = 0.5*sqrtGuarded(divmacro(k20_0,"k2",fabs(x20_0),"abs(x2)"),
          "k2/abs(x2)");
        if (usex_0yd0) {
          y0dx_0der = yd0x_0der;
          y0d0_0 = yd00_0;
        }
        else{
          wx_0der = divmacro(x2x_0der,"x2_der",x10_0,"x1")-divmacro(x20_0*
            x1x_0der,"x2*x1_der",sqr(x10_0),"x1^2");
          w0_0 = divmacro(x20_0,"x2",x10_0,"x1");
          /* Introducing 17 common subexpressions used in 12 expressions */
          /* Of the common subexpressions 17 are reals, 0 are integers, and 0
             are booleans. */

          { double helpvar[17];
          helpvar[0] = 3*y2x_0der-(x2x_0der*y2d0_0+x20_0*y2dx_0der);
          helpvar[1] = divmacro(1,"1",w0_0,"w");
          helpvar[2] = 3*y20_0-x20_0*y2d0_0;
          helpvar[3] = helpvar[2]*wx_0der;
          helpvar[4] = sqr(w0_0);
          helpvar[5] = divmacro(1,"1",helpvar[4],"w^2");
          helpvar[6] = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der);
          helpvar[7] = 3*y10_0-x10_0*y1d0_0;
          helpvar[8] = 1-w0_0;
          helpvar[9] = 2*x10_0*helpvar[8];
          helpvar[10] = divmacro(1,"1",helpvar[9],"2*x1*(1-w)");
          helpvar[11] = helpvar[1]*helpvar[2];
          helpvar[12] = helpvar[7]*w0_0;
          helpvar[13] = x1x_0der*helpvar[8];
          helpvar[14] = x10_0*wx_0der;
          helpvar[15] = sqr(helpvar[9]);
          helpvar[16] = divmacro(1,"1",helpvar[15],"(2*x1*(1-w))^2");
          y0dx_0der = helpvar[10]*(helpvar[1]*helpvar[0]-helpvar[5]*helpvar[3]-(
            helpvar[6]*w0_0+helpvar[7]*wx_0der))-helpvar[16]*2*(helpvar[11]-
            helpvar[12])*(helpvar[13]-helpvar[14]);
          }
          y0d0_0 = divmacro(divmacro(3*y20_0-x20_0*y2d0_0,"3*y2-x2*y2d",w0_0,"w")
            -(3*y10_0-x10_0*y1d0_0)*w0_0,"(3*y2-x2*y2d)/w-(3*y1-x1*y1d)*w",2*
            x10_0*(1-w0_0),"2*x1*(1-w)");
        }
        w1x_0der = divmacro(0.5*(divmacro(8.75*k1x_0der,"8.75*k1_der",x10_0,"x1")
          -divmacro(8.75*k10_0*x1x_0der,"8.75*k1*x1_der",sqr(x10_0),"x1^2")),
          "0.5*(8.75*k1_der/x1-8.75*k1*x1_der/x1^2)",sqrtGuarded(divmacro(8.75*
          k10_0,"8.75*k1",x10_0,"x1"),"8.75*k1/x1"),"sqrt(8.75*k1/x1)");
        w10_0 = sqrtGuarded(divmacro(8.75*k10_0,"8.75*k1",x10_0,"x1"),
          "8.75*k1/x1");
        w2x_0der = divmacro(0.5*(divmacro(8.75*k2x_0der,"8.75*k2_der",fabs(x20_0),
          "abs(x2)")-divmacro(8.75*k20_0*x2x_0der*(IF x20_0 > 0 THEN 1 ELSE -1),
          "8.75*k2*x2_der*noEvent((if x2 > 0 then 1 else -1))",sqr(fabs(x20_0)),
          "abs(x2)^2")),"0.5*(8.75*k2_der/abs(x2)-8.75*k2*x2_der*noEvent((if x2 > 0 then 1 else -1))/abs(x2)^2)",
          sqrtGuarded(divmacro(8.75*k20_0,"8.75*k2",fabs(x20_0),"abs(x2)"),
          "8.75*k2/abs(x2)"),"sqrt(8.75*k2/abs(x2))");
        w20_0 = sqrtGuarded(divmacro(8.75*k20_0,"8.75*k2",fabs(x20_0),"abs(x2)"),
          "8.75*k2/abs(x2)");
        y0dx_0der = IF y0d0_0 < 0.9*RealBmin(w10_0, w20_0) THEN y0dx_0der ELSE 
          0.9*(IF w10_0 < w20_0 THEN w1x_0der ELSE w2x_0der);
        y0d0_0 = RealBmin(y0d0_0, 0.9*RealBmin(w10_0, w20_0));
        yx_0der = y1x_0der*(IF x0_0 >= 0 THEN Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero
          (divmacro(x0_0,"x",x10_0,"x1"), 1, 1, divmacro(y1d0_0*x10_0,"y1d*x1",
          y10_0,"y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1")) ELSE 
          Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero(divmacro(
          x0_0,"x",x10_0,"x1"), divmacro(x20_0,"x2",x10_0,"x1"), divmacro(y20_0,
          "y2",y10_0,"y1"), divmacro(y2d0_0*x10_0,"y2d*x1",y10_0,"y1"), divmacro
          (y0d0_0*x10_0,"y0d*x1",y10_0,"y1")))+y10_0*(IF x0_0 >= 0 THEN 
          Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der(
          divmacro(x0_0,"x",x10_0,"x1"), 1, 1, divmacro(y1d0_0*x10_0,"y1d*x1",
          y10_0,"y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1"), divmacro(
          xx_0der,"x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,"x*x1_der",sqr(
          x10_0),"x1^2"), 0, 0, divmacro(y1dx_0der*x10_0+y1d0_0*x1x_0der,
          "y1d_der*x1+y1d*x1_der",y10_0,"y1")-divmacro(y1d0_0*x10_0*y1x_0der,
          "y1d*x1*y1_der",sqr(y10_0),"y1^2"), divmacro(y0dx_0der*x10_0+y0d0_0*
          x1x_0der,"y0d_der*x1+y0d*x1_der",y10_0,"y1")-divmacro(y0d0_0*x10_0*
          y1x_0der,"y0d*x1*y1_der",sqr(y10_0),"y1^2")) ELSE Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
          (divmacro(x0_0,"x",x10_0,"x1"), divmacro(x20_0,"x2",x10_0,"x1"), 
          divmacro(y20_0,"y2",y10_0,"y1"), divmacro(y2d0_0*x10_0,"y2d*x1",y10_0,
          "y1"), divmacro(y0d0_0*x10_0,"y0d*x1",y10_0,"y1"), divmacro(xx_0der,
          "x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,"x*x1_der",sqr(x10_0),
          "x1^2"), divmacro(x2x_0der,"x2_der",x10_0,"x1")-divmacro(x20_0*
          x1x_0der,"x2*x1_der",sqr(x10_0),"x1^2"), divmacro(y2x_0der,"y2_der",
          y10_0,"y1")-divmacro(y20_0*y1x_0der,"y2*y1_der",sqr(y10_0),"y1^2"), 
          divmacro(y2dx_0der*x10_0+y2d0_0*x1x_0der,"y2d_der*x1+y2d*x1_der",y10_0,
          "y1")-divmacro(y2d0_0*x10_0*y1x_0der,"y2d*x1*y1_der",sqr(y10_0),"y1^2"),
           divmacro(y0dx_0der*x10_0+y0d0_0*x1x_0der,"y0d_der*x1+y0d*x1_der",
          y10_0,"y1")-divmacro(y0d0_0*x10_0*y1x_0der,"y0d*x1*y1_der",sqr(y10_0),
          "y1^2")));
      }
    /* Output section */
    PopContext()
    return yx_0der;
  }}
/* Flattened Modelica model:

function Modelica.Math.Matrices.solve
  input Real A[:, size(A, 1)] "Matrix A of A*x = b";
  input Real b[size(A, 1)] "Vector b of A*x = b";
  output Real x[size(b, 1)] "Vector x such that A*x = b";
protected 
  Integer info;
  public 
algorithm 
  (x, info)  := Modelica.Math.Matrices.LAPACK.dgesv_vec(A, b);
  assert(info == 0, "Solving a linear system of equations with function
\"Matrices.solve\" is not possible, because the system has either
no or infinitely many solutions (A is singular).");
end Modelica.Math.Matrices.solve;
*/



DYMOLA_STATIC RealArray    Modelica_Math_Matrices_solve(RealArray   A0_0, 
  RealArray   b0_0) {
  PushContext("Modelica.Math.Matrices.solve")
  AssertModelica(RealSize( A0_0,2)==RealSize( A0_0, 1),"size(A, 2) == size(A, 1)","Dimension check of input to function failed");
  AssertModelica(RealSize( b0_0,1)==RealSize( A0_0, 1),"size(b, 1) == size(A, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    x0_0;
    int   info0_0;
    MarkObject retmark_ = PushMark();
    x0_0=RealTemporary( 1, RealSize( b0_0, 1));
    RePushMark(&retmark_);
    RealFillAssign( x0_0, 0);
    info0_0=0;
    /* Start of real code */
      {
        struct Modelica_Math_Matrices_LAPACK_dgesvx_0vec_M_struct dummy_mult_=
          Modelica_Math_Matrices_LAPACK_dgesvx_0vec_M(A0_0, b0_0);
        RealAssign (x0_0, dummy_mult_.x0_0_0member);
        info0_0 = dummy_mult_.info0_0_0member;
      }
      Release();
      AssertModelica(info0_0 == 0,"info == 0", "Solving a linear system of equations with function\n\"Matrices.solve\" is not possible, because the system has either\nno or infinitely many solutions (A is singular).");
      ;
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return x0_0;
  }}
/* Flattened Modelica model:

function Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der
  input Real x;
  input Real x1;
  input Real y1;
  input Real y1d;
  input Real y0d;
protected 
  Real y;
  Real a1;
  Real a2;
  Real a3;
  Real xx;
public 
  input Real x_der;
  input Real x1_der;
  input Real y1_der;
  input Real y1d_der;
  input Real y0d_der;
  output Real y_der;
protected 
  Real a1_der;
  Real a2_der;
  Real a3_der;
  Real xx_der;
  public 
algorithm 
  a1_der := x1_der*y0d+x1*y0d_der;
  a1 := x1*y0d;
  a2_der := 3*y1_der-(x1_der*y1d+x1*y1d_der)-2*a1_der;
  a2 := 3*y1-x1*y1d-2*a1;
  a3_der := y1_der-a2_der-a1_der;
  a3 := y1-a2-a1;
  xx_der := x_der/x1-x*x1_der/x1^2;
  xx := x/x1;
  y_der := xx_der*(a1+xx*(a2+xx*a3))+xx*(a1_der+xx_der*(a2+xx*a3)+xx*(a2_der+
    xx_der*a3+xx*a3_der));
annotation(smoothOrder=2);
end Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der;
*/



DYMOLA_STATIC double   Modelica_Fluid_Utilities_evaluatePoly3x_0derivativeAtZero__der
  (double  x0_0, double  x10_0, double  y10_0, double  y1d0_0, double  y0d0_0, 
  double  xx_0der, double  x1x_0der, double  y1x_0der, double  y1dx_0der, double 
   y0dx_0der) {
  PushContext("Modelica.Fluid.Utilities.evaluatePoly3_derivativeAtZero:der")
  {
    /* Declare outputs and temporaries */
    double   y0_0;
    double   a10_0;
    double   a20_0;
    double   a30_0;
    double   xx0_0;
    double   yx_0der;
    double   a1x_0der;
    double   a2x_0der;
    double   a3x_0der;
    double   xxx_0der;
    y0_0=0;
    a10_0=0;
    a20_0=0;
    a30_0=0;
    xx0_0=0;
    yx_0der=0;
    a1x_0der=0;
    a2x_0der=0;
    a3x_0der=0;
    xxx_0der=0;
    /* Start of real code */
      a1x_0der = x1x_0der*y0d0_0+x10_0*y0dx_0der;
      a10_0 = x10_0*y0d0_0;
      a2x_0der = 3*y1x_0der-(x1x_0der*y1d0_0+x10_0*y1dx_0der)-2*a1x_0der;
      a20_0 = 3*y10_0-x10_0*y1d0_0-2*a10_0;
      a3x_0der = y1x_0der-a2x_0der-a1x_0der;
      a30_0 = y10_0-a20_0-a10_0;
      xxx_0der = divmacro(xx_0der,"x_der",x10_0,"x1")-divmacro(x0_0*x1x_0der,
        "x*x1_der",sqr(x10_0),"x1^2");
      xx0_0 = divmacro(x0_0,"x",x10_0,"x1");
      yx_0der = xxx_0der*(a10_0+xx0_0*(a20_0+xx0_0*a30_0))+xx0_0*(a1x_0der+
        xxx_0der*(a20_0+xx0_0*a30_0)+xx0_0*(a2x_0der+xxx_0der*a30_0+xx0_0*
        a3x_0der));
    /* Output section */
    PopContext()
    return yx_0der;
  }}
/* Flattened Modelica model:

function Modelica.Math.Matrices.LAPACK.dgesv_vec
  input Real A[:, size(A, 1)];
  input Real b[size(A, 1)];
  output Real x[size(A, 1)] := b;
  output Integer info;
protected 
  Real Awork[size(A, 1), size(A, 1)] := A;
  Integer ipiv[size(A, 1)];
  public 
external "Fortran 77" dgesv(size(A, 1), 1, Awork, size(A, 1), ipiv, x, size(A, 1),
   info);
annotation(Library={"Lapack"});
end Modelica.Math.Matrices.LAPACK.dgesv_vec;
*/



DYMOLA_STATIC struct Modelica_Math_Matrices_LAPACK_dgesvx_0vec_M_struct 
  Modelica_Math_Matrices_LAPACK_dgesvx_0vec_M(RealArray   A0_0, RealArray   b0_0)
   {
  PushContext("Modelica.Math.Matrices.LAPACK.dgesv_vec")
  AssertModelica(RealSize( A0_0,2)==RealSize( A0_0, 1),"size(A, 2) == size(A, 1)","Dimension check of input to function failed");
  AssertModelica(RealSize( b0_0,1)==RealSize( A0_0, 1),"size(b, 1) == size(A, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    RealArray    x0_0;
    int   info0_0;
    RealArray    Awork0_0;
    IntegerArray    ipiv0_0;
    MarkObject retmark_ = PushMark();
    x0_0=RealTemporary( 1, RealSize( A0_0, 1));
    RePushMark(&retmark_);
    RealAssign (x0_0, b0_0);
    Release();
    info0_0=0;
    Awork0_0=RealTemporary( 2, RealSize( A0_0, 1), RealSize( A0_0, 1));
    PushMark();
    RealAssign (Awork0_0, A0_0);
    Release();
    ipiv0_0=IntegerTemporary( 1, RealSize( A0_0, 1));
    PushMark();
    IntegerFillAssign( ipiv0_0, 0);
    /* Start of real code */
    {
      extern void (dgesv_)(int  const *, int  const *, double  *, int  const *, 
        int  *, double  *, int  const *, int  *);
      int  helper_1 = 1;
      RealArray   helper_2 = RealSwitchMajor( Awork0_0);
      (dgesv_)(& A0_0.dims[1-1], & helper_1, helper_2.data, & A0_0.dims[1-1], 
        ipiv0_0.data, x0_0.data, & A0_0.dims[1-1], & info0_0);
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Math_Matrices_LAPACK_dgesvx_0vec_M_struct out_;
      out_.x0_0_0member = x0_0;
      out_.info0_0_0member = info0_0;
      return out_;
    }
  }}
/* DSblock C-code: */

#include <moutil.c>
DYMOLA_STATIC const char*modelName="LH_v2.HVAC_v2";
DYMOLA_STATIC const char*usedLibraries[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/documents and settings/xpang/application data/dynasim/dymola.lic";
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations

InitialSection
W_[0] = true;
W_[9] = 2;
W_[22] = true;
W_[23] = false;
W_[24] = false;
W_[31] = true;
W_[32] = true;
W_[40] = 2.31;
W_[41] = 3;
W_[48] = 1;
W_[49] = 1;
W_[64] = 3;
W_[65] = true;
W_[72] = false;
W_[101] = false;
W_[102] = 1;
W_[117] = false;
W_[118] = 1;
W_[119] = 1;
W_[120] = true;
W_[121] = 1;
W_[130] = false;
W_[135] = 3;
W_[136] = true;
W_[137] = false;
W_[138] = false;
W_[139] = false;
W_[145] = false;
W_[146] = true;
W_[154] = true;
W_[155] = true;
W_[164] = 2.31;
W_[172] = 1;
W_[173] = 1;
W_[189] = true;
W_[197] = true;
W_[198] = true;
W_[206] = 2.31;
W_[214] = 1;
W_[215] = 1;
W_[232] = true;
W_[239] = true;
W_[240] = true;
W_[250] = 2.31;
W_[258] = 1;
W_[259] = 1;
W_[277] = 2.31;
W_[278] = 42;
W_[279] = 2.31;
W_[280] = 42;
W_[281] = 2.31;
W_[282] = 42;
W_[283] = true;
W_[290] = true;
W_[291] = true;
W_[300] = 2.31;
W_[301] = 42;
W_[308] = 1;
W_[309] = 1;
W_[314] = true;
W_[321] = true;
W_[322] = true;
W_[332] = 2.31;
W_[333] = 42;
W_[340] = 1;
W_[341] = 1;
W_[346] = true;
W_[353] = true;
W_[354] = true;
W_[362] = 2.31;
W_[363] = 42;
W_[370] = 1;
W_[371] = 1;
W_[387] = 3;
W_[405] = 3;
W_[406] = false;
W_[407] = true;
W_[408] = false;
W_[409] = false;
W_[415] = false;
W_[421] = true;
W_[422] = true;
W_[430] = 2.31;
W_[431] = 100;
W_[438] = 1;
W_[439] = 1;
W_[444] = false;
W_[453] = false;
W_[468] = 2;
W_[482] = true;
W_[483] = false;
W_[487] = 2;
W_[500] = true;
W_[501] = false;
W_[503] = 2;
W_[517] = true;
W_[518] = false;
W_[520] = 2;
W_[532] = true;
W_[533] = false;
W_[535] = 2;
W_[548] = true;
W_[549] = false;
W_[552] = 100;
W_[554] = 1;
W_[565] = false;
W_[571] = 3;
W_[572] = false;
W_[573] = false;
W_[574] = false;
W_[575] = false;
W_[582] = 1;
W_[593] = false;
W_[599] = 3;
W_[600] = false;
W_[601] = false;
W_[602] = false;
W_[603] = false;
W_[610] = 1;
W_[616] = false;
W_[621] = 3;
W_[622] = true;
W_[623] = false;
W_[624] = false;
W_[625] = false;
W_[654] = 3;
W_[656] = false;
W_[661] = false;
W_[662] = 1;
W_[713] = 2;
W_[738] = 2;
W_[739] = false;
W_[743] = true;
W_[744] = 1;
W_[783] = 3.14159265358979;
W_[785] = 3.14159265358979;
W_[787] = 3.14159265358979;
W_[788] = 3.14159265358979;
W_[789] = 2.31;
W_[795] = false;
W_[801] = true;
W_[802] = true;
W_[811] = 2.31;
W_[812] = 100;
W_[819] = 1;
W_[820] = 1;
W_[825] = 100;
W_[828] = true;
W_[829] = true;
W_[846] = false;
W_[876] = true;
W_[877] = true;
W_[892] = false;
W_[928] = 2;
W_[929] = 2;
W_[943] = 0;
W_[948] = 1;
W_[949] = 1;
W_[950] = 1;
W_[951] = 1;
W_[794] = 355.35;
W_[1] = 1;
W_[2] = 1;
W_[3] = 1;
W_[4] = 1;
W_[5] = 4;
W_[10] = 5;
W_[11] = true;
W_[19] = true;
W_[26] = false;
W_[27] = false;
W_[28] = 3;
W_[30] = 0.000231;
W_[39] = true;
W_[42] = false;
W_[45] = 101325;
W_[46] = 293.15;
W_[47] = 1.82E-005;
W_[52] = 1.2;
W_[75] = 4;
W_[76] = 4;
W_[67] = false;
W_[70] = 1500;
W_[71] = false;
W_[73] = 0.5;
W_[77] = 4;
W_[78] = 4;
W_[80] = true;
W_[92] = true;
W_[105] = false;
W_[106] = 0;
W_[131] = true;
W_[140] = 0;
W_[141] = 355.35;
W_[142] = 1;
W_[149] = false;
W_[150] = false;
W_[153] = 0.000231;
W_[163] = true;
W_[166] = false;
W_[169] = 101325;
W_[170] = 293.15;
W_[171] = 1.82E-005;
W_[177] = 1.2;
W_[192] = false;
W_[193] = false;
W_[196] = 0.000231;
W_[205] = true;
W_[208] = false;
W_[211] = 101325;
W_[212] = 293.15;
W_[213] = 1.82E-005;
W_[220] = 1.2;
W_[234] = false;
W_[235] = false;
W_[238] = 0.000231;
W_[249] = true;
W_[252] = false;
W_[255] = 101325;
W_[256] = 293.15;
W_[257] = 1.82E-005;
W_[264] = 1.2;
W_[276] = 0.231;
W_[285] = false;
W_[286] = false;
W_[289] = 0.000231;
W_[299] = true;
W_[302] = false;
W_[305] = 101325;
W_[306] = 293.15;
W_[307] = 1.82E-005;
W_[310] = false;
W_[311] = 1;
W_[312] = 4000;
W_[313] = 0.3;
W_[316] = false;
W_[317] = false;
W_[320] = 0.000231;
W_[331] = true;
W_[334] = false;
W_[337] = 101325;
W_[338] = 293.15;
W_[339] = 1.82E-005;
W_[342] = false;
W_[343] = 1;
W_[344] = 4000;
W_[345] = 0.3;
W_[348] = false;
W_[349] = false;
W_[352] = 0.000231;
BreakSectionFunction(1);
W_[361] = true;
W_[364] = false;
W_[367] = 101325;
W_[368] = 293.15;
W_[369] = 1.82E-005;
W_[372] = false;
W_[373] = 1;
W_[374] = 4000;
W_[375] = 0.3;
W_[397] = false;
W_[410] = 101325;
W_[411] = 293.15;
W_[412] = 1;
W_[416] = false;
W_[417] = false;
W_[420] = 0.000231;
W_[429] = true;
W_[432] = false;
W_[435] = 101325;
W_[436] = 293.15;
W_[437] = 1.82E-005;
W_[440] = false;
W_[441] = 1;
W_[442] = 4000;
W_[443] = 0.3;
W_[449] = 2.31;
W_[450] = 0.000231;
W_[459] = true;
W_[460] = true;
W_[469] = 5;
W_[470] = true;
W_[479] = true;
W_[488] = 5;
W_[489] = true;
W_[497] = true;
W_[504] = 5;
W_[505] = true;
W_[514] = true;
W_[521] = 5;
W_[522] = true;
W_[530] = true;
W_[536] = 5;
W_[537] = true;
W_[545] = true;
W_[566] = true;
W_[576] = 100000;
W_[577] = 293.15;
W_[578] = 1;
W_[594] = true;
W_[604] = 100000;
W_[605] = 293.15;
W_[606] = 1;
W_[617] = true;
W_[626] = 0;
W_[628] = 1;
W_[630] = -2.31;
W_[631] = 1;
W_[632] = 1;
W_[633] = 1;
W_[634] = 1;
W_[636] = true;
W_[648] = true;
W_[665] = false;
W_[666] = 0;
W_[703] = 2.31;
W_[705] = true;
W_[706] = 1;
W_[707] = 1;
W_[708] = 1;
W_[709] = 1;
W_[710] = 4;
W_[716] = 2;
W_[717] = 2;
W_[718] = 2;
W_[719] = 2;
W_[720] = true;
W_[730] = true;
W_[746] = true;
W_[747] = 0;
W_[796] = false;
W_[797] = false;
W_[800] = 0.000231;
W_[810] = true;
W_[813] = false;
W_[816] = 101325;
W_[817] = 293.15;
W_[818] = 1.82E-005;
W_[821] = false;
W_[822] = 1;
W_[823] = 4000;
W_[824] = 0.3;
W_[860] = true;
W_[861] = true;
W_[863] = true;
W_[864] = true;
W_[884] = 2.31;
W_[886] = 0.000231;
W_[906] = true;
W_[907] = true;
W_[909] = true;
W_[910] = true;
W_[930] = true;
W_[931] = 0;
W_[932] = 0;
W_[953] = 3;
W_[960] = 3;
W_[967] = 3;
W_[974] = 3;
W_[981] = 3;
W_[988] = 3;
W_[91] = false;
W_[93] = true;
W_[396] = false;
W_[398] = true;
W_[647] = false;
W_[649] = true;
W_[685] = 1;
W_[729] = false;
W_[731] = true;
W_[737] = true;
W_[760] = 1;
W_[144] = 1;
W_[414] = 1;
W_[581] = 1;
W_[609] = 1;
W_[629] = 1;
W_[598] = 83680.0;
W_[905] = 293.15;
W_[134] = 343924.8;
W_[857] = 355.35;
W_[570] = 83680.0;
W_[859] = 293.15;
W_[751] = 0;
W_[752] = 0;
W_[660] = 0;
W_[672] = 0;
W_[673] = 0;
W_[674] = 0;
W_[126] = 343924.8;
W_[132] = 82.2;
W_[390] = 1.2;
W_[400] = 1.01325;
W_[560] = 83680.0;
W_[567] = 20.0;
W_[568] = 1;
W_[588] = 83680.0;
W_[595] = 20.0;
W_[596] = 1;
W_[675] = 0;
W_[676] = 0;
W_[677] = 0;
W_[681] = 0;
W_[682] = 0;
W_[683] = 0;
W_[753] = 0;
W_[754] = 0;
W_[757] = 0;
W_[758] = 0;
W_[394] = 0.0289651159;
W_[393] = 287.051224952979;
W_[391] = 1;
W_[388] = 101325;
W_[395] = 101325;
W_[413] = 101325;
W_[401] = 0;
W_[402] = 101325;
W_[403] = 101325;
W_[404] = 101325;
W_[580] = 293.15;
W_[562] = 0.018015268;
W_[561] = 0;
W_[558] = 293.15;
W_[559] = 1;
W_[557] = 995.586;
W_[556] = 83680.0;
W_[555] = 100000;
W_[564] = 293.15;
W_[563] = 100000;
W_[579] = 100000;
W_[569] = 100000;
W_[608] = 293.15;
W_[590] = 0.018015268;
W_[589] = 0;
W_[586] = 293.15;
W_[587] = 1;
W_[585] = 995.586;
W_[584] = 83680.0;
W_[583] = 100000;
W_[592] = 293.15;
W_[591] = 100000;
W_[607] = 100000;
W_[597] = 100000;
W_[143] = 355.35;
W_[128] = 0.018015268;
W_[127] = 0;
W_[124] = 355.35;
W_[125] = 1;
W_[123] = 995.586;
W_[122] = 343924.8;
W_[129] = 355.35;
W_[882] = 100000;
W_[899] = 100000;
W_[904] = 100000;
W_[814] = 0.231;
W_[815] = 0.693;
W_[379] = 101325;
W_[377] = 101325;
W_[383] = 0;
W_[385] = 0;
W_[335] = 0.356440738412432;
W_[336] = 0.693;
W_[315] = 101325;
W_[329] = 101325;
W_[303] = 0.356440738412432;
W_[304] = 0.693;
W_[284] = 101325;
W_[296] = 101325;
W_[365] = 0.356440738412432;
W_[366] = 0.693;
W_[836] = 100000;
W_[853] = 100000;
W_[858] = 100000;
W_[100] = 0;
W_[115] = 0.8;
W_[74] = 0.5;
W_[104] = 0;
W_[108] = 0;
W_[103] = 3.04647389268978;
W_[98] = 0;
W_[90] = 0.0289651159;
W_[89] = 287.051224952979;
W_[87] = 1;
W_[116] = 0;
W_[466] = 0;
W_[465] = 0;
W_[485] = 0;
W_[484] = 0;
W_[925] = 0;
W_[924] = 0;
W_[615] = 0.018015268;
W_[614] = 0;
W_[612] = 1;
W_[611] = 995.586;
W_[652] = 0;
W_[653] = 0;
W_[684] = 0;
W_[664] = 0;
W_[668] = 0;
W_[646] = 0.0289651159;
W_[645] = 287.051224952979;
BreakSectionFunction(2);
W_[643] = 1;
W_[669] = 0;
W_[670] = 0;
W_[671] = 0;
W_[687] = 0;
W_[688] = 0;
W_[689] = 0;
W_[690] = 0;
W_[691] = 0;
W_[692] = 0;
W_[693] = 0;
W_[694] = 0;
W_[695] = 0;
W_[696] = 0;
W_[697] = 0;
W_[698] = 0;
W_[655] = 0;
W_[678] = 1;
W_[679] = 1;
W_[680] = 1;
W_[433] = 0.231;
W_[434] = 0.693;
W_[551] = 0;
W_[550] = 0;
W_[777] = 0;
W_[736] = 0;
W_[759] = 0;
W_[728] = 0.0289651159;
W_[727] = 287.051224952979;
W_[725] = 1;
W_[749] = 0;
W_[750] = 0;
W_[762] = 0;
W_[763] = 0;
W_[764] = 0;
W_[765] = 0;
W_[766] = 0;
W_[767] = 0;
W_[768] = 0;
W_[769] = 0;
W_[755] = 1;
W_[756] = 1;
BoundParameterSection
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[13] = DP_[14];
W_[14] = DP_[9];
W_[17] = DP_[12];
W_[18] = DP_[13];
W_[29] = DP_[3];
W_[60] = IF DP_[34] THEN 0.886226925452758 ELSE 1;
W_[61] = IF DP_[31] THEN divmacro(divmacro(2.31,"2.31",W_[52],"VAV.rho_nominal"),
  "2.31/VAV.rho_nominal",DP_[32],"VAV.v_nominal") ELSE DP_[33];
W_[62] = divmacro(divmacro(2.66805*DP_[41],"2.66805*VAV.k1",1.18430792005922E-005
  *W_[45],"1.18430792005922E-005*VAV.sta0.p"),"2.66805*VAV.k1/(1.18430792005922E-005*VAV.sta0.p)",
  sqr(W_[61]),"VAV.area^2");
W_[63] = divmacro(5.3361,"5.3361",3-W_[62],"3-VAV.dpDamOpe0");
W_[68] = W_[6];
W_[69] = W_[68];
W_[79] = W_[69];
BreakSectionFunction(3);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
helpvar[0] = IF W_[80] THEN 0 ELSE 0.000994579541498831;
W_[81] = 300.0;
SolveScalarLinearParametric(1-helpvar[0]*(IF W_[80] THEN 1005.45 ELSE 0),
  "1-(if SupF.use_T_start then 0 else 0.000994579541498831)*(if SupF.use_T_start then 1005.45 else 0)",
   (IF W_[80] THEN W_[7] ELSE 298.15)+helpvar[0]*(IF W_[80] THEN -299774.9175
   ELSE -5027.25),"(if SupF.use_T_start then system.T_start else 298.15)+(if SupF.use_T_start then 0 else 0.000994579541498831)*(if SupF.use_T_start then -299774.9175 else -5027.25)",
   W_[81],"SupF.T_start");
W_[82] = IF W_[80] THEN 1005.45*(W_[81]-298.15) ELSE -5027.25;
 /* End of Equation Block */ 

BreakSectionFunction(4);
W_[107] = DP_[1];
W_[151] = 0.01*W_[6];
W_[152] = DP_[3];
W_[174] = DP_[70];
W_[185] = IF DP_[60] THEN 0.886226925452758 ELSE 1;
W_[186] = IF DP_[58] THEN divmacro(divmacro(2.31,"2.31",W_[177],"Econ.damOA.rho_nominal"),
  "2.31/Econ.damOA.rho_nominal",DP_[59],"Econ.damOA.v_nominal") ELSE W_[174];
W_[194] = 0.01*W_[6];
W_[195] = DP_[3];
W_[217] = DP_[86];
W_[228] = IF DP_[77] THEN 0.886226925452758 ELSE 1;
W_[229] = IF DP_[75] THEN divmacro(divmacro(2.31,"2.31",W_[220],"Econ.damExh.rho_nominal"),
  "2.31/Econ.damExh.rho_nominal",DP_[76],"Econ.damExh.v_nominal") ELSE W_[217];
W_[236] = 0.01*W_[6];
W_[237] = DP_[3];
W_[261] = DP_[102];
W_[272] = IF DP_[93] THEN 0.886226925452758 ELSE 1;
W_[273] = IF DP_[91] THEN divmacro(divmacro(2.31,"2.31",W_[264],"Econ.damRec.rho_nominal"),
  "2.31/Econ.damRec.rho_nominal",DP_[92],"Econ.damRec.v_nominal") ELSE W_[261];
W_[287] = 0.01*W_[6];
W_[288] = DP_[3];
W_[318] = 0.01*W_[6];
W_[319] = DP_[3];
W_[350] = 0.01*W_[6];
W_[351] = DP_[3];
W_[418] = 0.01*W_[6];
W_[419] = DP_[3];
W_[451] = W_[6];
W_[452] = W_[451];
W_[461] = DP_[213];
W_[463] = DP_[212];
W_[473] = DP_[125];
W_[474] = DP_[120];
W_[477] = DP_[123];
W_[478] = DP_[124];
W_[491] = DP_[143];
W_[492] = DP_[138];
W_[495] = DP_[141];
W_[496] = DP_[142];
W_[508] = DP_[162];
W_[509] = DP_[157];
W_[512] = DP_[160];
W_[513] = DP_[161];
W_[524] = DP_[180];
W_[525] = DP_[175];
W_[528] = DP_[178];
W_[529] = DP_[179];
W_[539] = DP_[198];
W_[540] = DP_[193];
W_[543] = DP_[196];
W_[544] = DP_[197];
W_[790] = divmacro(0.0666666666666667*DP_[255],"0.0666666666666667*Q_hc_d",
  DP_[44],"cp_a");
W_[553] = W_[790];
W_[627] = DP_[249];
W_[635] = W_[6];
BreakSectionFunction(5);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
helpvar[1] = IF W_[636] THEN 0 ELSE 0.000994579541498831;
W_[637] = 300.0;
SolveScalarLinearParametric(1-helpvar[1]*(IF W_[636] THEN 1005.45 ELSE 0),
  "1-(if del.use_T_start then 0 else 0.000994579541498831)*(if del.use_T_start then 1005.45 else 0)",
   (IF W_[636] THEN W_[7] ELSE 298.15)+helpvar[1]*(IF W_[636] THEN -299774.9175
   ELSE -5027.25),"(if del.use_T_start then system.T_start else 298.15)+(if del.use_T_start then 0 else 0.000994579541498831)*(if del.use_T_start then -299774.9175 else -5027.25)",
   W_[637],"del.T_start");
W_[638] = IF W_[636] THEN 1005.45*(W_[637]-298.15) ELSE -5027.25;
 /* End of Equation Block */ 

BreakSectionFunction(6);
W_[657] = DP_[4];
W_[667] = DP_[1];
W_[700] = W_[635];
W_[702] = 1.18430792005922E-005*W_[700];
W_[704] = divmacro(W_[703]*DP_[216],"del.m_flow_nominal*del.tau",W_[702],
  "del.rho_nominal");
W_[699] = W_[704];
W_[686] = 3.14159265358979*powmacro(0.75*W_[699],"0.75*del.V",0.666666666666667,
  "0.666666666666667");
W_[701] = W_[637];
W_[711] = DP_[217];
W_[712] = DP_[218];
W_[714] = DP_[6];
W_[715] = DP_[7];
W_[721] = IF W_[720] THEN 1005.45*(DP_[224]-298.15) ELSE -5027.25;
W_[740] = DP_[221];
W_[748] = DP_[218];
W_[770] = W_[714];
W_[761] = 3.14159265358979*powmacro(0.75*W_[770],"0.75*room.vol.V",
  0.666666666666667,"0.666666666666667");
W_[771] = DP_[223];
W_[772] = DP_[224];
W_[773] = 1.18430792005922E-005*W_[771];
W_[776] = W_[715];
W_[781] = DP_[8];
W_[779] = W_[781];
W_[791] = divmacro(0.17921146953405*DP_[250],"0.17921146953405*Q_cc_d",DP_[45],
  "cp_w");
W_[792] = 299.85-divmacro(0.432900432900433*DP_[250],"0.432900432900433*Q_cc_d",
  DP_[44],"cp_a");
W_[793] = divmacro(0.0909090909090909*DP_[255],"0.0909090909090909*Q_hc_d",
  DP_[45],"cp_w");
W_[798] = 0.01*W_[6];
W_[799] = DP_[3];
W_[838] = W_[790];
W_[839] = W_[793];
W_[840] = 0.0001*W_[838];
W_[841] = 0.0001*W_[839];
W_[842] = W_[6];
W_[843] = W_[842];
W_[844] = W_[6];
W_[845] = W_[844];
W_[862] = DP_[253];
W_[865] = DP_[254];
W_[922] = divmacro(15,"15",W_[794]-DP_[256],"T_ew_hc_d-T_ea_hc_d");
W_[867] = W_[922];
W_[885] = W_[791];
W_[887] = 0.0001*W_[885];
W_[888] = W_[6];
W_[889] = W_[888];
W_[890] = W_[6];
W_[891] = W_[890];
W_[908] = DP_[251];
W_[911] = DP_[252];
W_[923] = divmacro(DP_[248]-W_[792],"T_ea_cc_d-T_la_cc_d",DP_[248]-DP_[249],
  "T_ea_cc_d-T_ew_cc_d");
W_[913] = W_[923];
W_[952] = divmacro(1,"1",DP_[10],"DmprC.Ti");
W_[954] = DP_[18];
W_[956] = divmacro(1,"1",DP_[9]*DP_[16],"DmprC.k*DmprC.Ni");
W_[959] = divmacro(1,"1",DP_[121],"EcoC.Ti");
W_[961] = DP_[129];
W_[963] = divmacro(1,"1",DP_[120]*DP_[127],"EcoC.k*EcoC.Ni");
W_[966] = divmacro(1,"1",DP_[139],"CCC.Ti");
W_[968] = DP_[147];
W_[970] = divmacro(1,"1",DP_[138]*DP_[145],"CCC.k*CCC.Ni");
W_[973] = divmacro(1,"1",DP_[158],"HCC.Ti");
W_[975] = DP_[166];
W_[977] = divmacro(1,"1",DP_[157]*DP_[164],"HCC.k*HCC.Ni");
W_[980] = divmacro(1,"1",DP_[176],"RHCC.Ti");
W_[982] = DP_[184];
W_[984] = divmacro(1,"1",DP_[175]*DP_[182],"RHCC.k*RHCC.Ni");
W_[987] = divmacro(1,"1",DP_[194],"FanC.Ti");
W_[989] = DP_[202];
W_[991] = divmacro(1,"1",DP_[193]*DP_[200],"FanC.k*FanC.Ni");
W_[44] = IF DP_[29] THEN 2.31*DP_[30] ELSE 1.82E-005*DP_[35]*sqrtGuarded(W_[61],
  "VAV.area")*W_[60];
W_[620] = 4184*(W_[627]-273.15);
W_[903] = 273.15+0.000239005736137667*W_[620];
W_[254] = IF DP_[89] THEN 2.31*DP_[90] ELSE 1.82E-005*DP_[94]*sqrtGuarded(
  W_[273],"Econ.damRec.area")*W_[272];
W_[210] = IF DP_[73] THEN 2.31*DP_[74] ELSE 1.82E-005*DP_[78]*sqrtGuarded(
  W_[229],"Econ.damExh.area")*W_[228];
W_[168] = IF DP_[56] THEN 2.31*DP_[57] ELSE 1.82E-005*DP_[61]*sqrtGuarded(
  W_[186],"Econ.damOA.area")*W_[185];
W_[613] = 4184*(W_[627]-273.15);
W_[618] = W_[627]-273.15;
W_[663] = 12.5663706143592*powmacro(0.238732414637843*W_[699],"0.238732414637843*del.V",
  0.666666666666667,"0.666666666666667");
W_[745] = 12.5663706143592*powmacro(0.238732414637843*W_[770],"0.238732414637843*room.vol.V",
  0.666666666666667,"0.666666666666667");
InitialSection
#ifdef DynSimStruct
W_[33] = 3;
W_[35] = 300;
W_[36] = 300;
W_[37] = 300;
W_[38] = 300;
W_[50] = 1;
W_[51] = 1;
W_[85] = 1;
W_[113] = 1500;
W_[158] = 300;
W_[159] = 300;
W_[160] = 100000.0;
W_[161] = 300;
W_[162] = 300;
W_[175] = 1;
W_[176] = 1;
W_[201] = 300;
W_[202] = 300;
W_[203] = 300;
W_[204] = 300;
W_[218] = 1;
W_[219] = 1;
W_[244] = 300;
W_[245] = 300;
W_[246] = 100000.0;
W_[247] = 300;
W_[248] = 300;
W_[262] = 1;
W_[263] = 1;
W_[294] = 300;
W_[295] = 300;
W_[297] = 300;
W_[298] = 300;
W_[325] = 300;
W_[326] = 300;
W_[327] = 100000.0;
W_[328] = 300;
W_[330] = 300;
W_[357] = 300;
W_[358] = 300;
W_[359] = 300;
W_[360] = 300;
W_[376] = 0;
W_[378] = 0;
W_[380] = 0;
W_[381] = 0;
W_[425] = 300;
W_[426] = 300;
W_[427] = 300;
W_[428] = 300;
W_[454] = 0;
W_[455] = 300;
W_[456] = 300;
W_[457] = 300;
W_[458] = 300;
W_[641] = 1;
W_[724] = 1;
W_[778] = 273.15;
W_[806] = 300;
W_[807] = 300;
W_[808] = 300;
W_[809] = 300;
W_[847] = 0;
W_[848] = 0;
W_[849] = 0;
W_[850] = 300;
W_[851] = 300;
W_[852] = 300;
W_[854] = 300;
W_[855] = 300;
W_[856] = 300;
W_[893] = 0;
W_[894] = 0;
W_[895] = 0;
W_[896] = 300;
W_[897] = 300;
W_[898] = 300;
W_[900] = 300;
W_[901] = 300;
W_[902] = 300;
#endif
InitialSection2
W_[66] = W_[68];
W_[83] = W_[79];
W_[84] = W_[82];
W_[86] = W_[81];
W_[112] = divmacro(divmacro(DP_[48],"SupF.m_flow_start",DP_[50],"SupF.rho_nominal"),
  "SupF.m_flow_start/SupF.rho_nominal",DP_[49],"SupF.nParallel");
W_[156] = W_[151];
W_[199] = W_[194];
W_[241] = W_[237];
W_[242] = W_[236];
W_[292] = W_[287];
W_[323] = W_[318];
W_[355] = W_[350];
W_[423] = W_[418];
W_[445] = W_[451];
W_[447] = W_[452];
W_[639] = W_[635];
W_[640] = W_[638];
W_[642] = W_[637];
W_[722] = DP_[223];
W_[723] = W_[721];
W_[803] = W_[799];
W_[804] = W_[798];
W_[830] = W_[842];
W_[832] = W_[843];
W_[834] = W_[844];
W_[880] = W_[890];
X_[1] = W_[699]*W_[702];
X_[3] = W_[770]*W_[773];
X_[6] = W_[954];
X_[7] = W_[961];
X_[8] = W_[968];
X_[9] = W_[975];
X_[10] = W_[982];
X_[11] = W_[989];
InitialSection
DefaultSection
InitializeData(0)
InitialSection
Aux_[23] = W_[927];
Aux_[24] = W_[937];
Aux_[25] = W_[939];
Aux_[26] = W_[938];
Aux_[29] = W_[944];
Aux_[30] = W_[945];
Aux_[31] = W_[946];
Aux_[32] = W_[947];
Aux_[27] = W_[933];
Aux_[28] = W_[934];
Aux_[33] = W_[935];
Aux_[34] = W_[936];
InitialSection
InitialSection2
W_[6] = DP_[0];
W_[7] = DP_[1];
W_[13] = DP_[14];
W_[14] = DP_[9];
W_[17] = DP_[12];
W_[18] = DP_[13];
W_[29] = DP_[3];
W_[60] = IF DP_[34] THEN 0.886226925452758 ELSE 1;
W_[61] = IF DP_[31] THEN divmacro(divmacro(2.31,"2.31",W_[52],"VAV.rho_nominal"),
  "2.31/VAV.rho_nominal",DP_[32],"VAV.v_nominal") ELSE DP_[33];
W_[62] = divmacro(divmacro(2.66805*DP_[41],"2.66805*VAV.k1",1.18430792005922E-005
  *W_[45],"1.18430792005922E-005*VAV.sta0.p"),"2.66805*VAV.k1/(1.18430792005922E-005*VAV.sta0.p)",
  sqr(W_[61]),"VAV.area^2");
W_[63] = divmacro(5.3361,"5.3361",3-W_[62],"3-VAV.dpDamOpe0");
W_[68] = W_[6];
W_[69] = W_[68];
W_[79] = W_[69];
BreakSectionFunction(7);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
helpvar[2] = IF W_[80] THEN 0 ELSE 0.000994579541498831;
W_[81] = 300;
SolveScalarLinearParametric(1-helpvar[2]*(IF W_[80] THEN 1005.45 ELSE 0),
  "1-(if SupF.use_T_start then 0 else 0.000994579541498831)*(if SupF.use_T_start then 1005.45 else 0)",
   (IF W_[80] THEN W_[7] ELSE 298.15)+helpvar[2]*(IF W_[80] THEN -299774.9175
   ELSE -5027.25),"(if SupF.use_T_start then system.T_start else 298.15)+(if SupF.use_T_start then 0 else 0.000994579541498831)*(if SupF.use_T_start then -299774.9175 else -5027.25)",
   W_[81],"SupF.T_start");
W_[82] = IF W_[80] THEN 1005.45*(W_[81]-298.15) ELSE -5027.25;
 /* End of Equation Block */ 

BreakSectionFunction(8);
W_[107] = DP_[1];
W_[151] = 0.01*W_[6];
W_[152] = DP_[3];
W_[174] = DP_[70];
W_[179] = divmacro(logGuarded(DP_[66],"Econ.damOA.k0")-DP_[63]-DP_[62],
  "ln(Econ.damOA.k0)-Econ.damOA.b-Econ.damOA.a",sqr(DP_[64]),"Econ.damOA.yL^2");
W_[180] = divmacro(2*DP_[63]-(DP_[63]*DP_[64]+2*logGuarded(DP_[66],
  "Econ.damOA.k0"))+2*DP_[62],"2*Econ.damOA.b-(Econ.damOA.b*Econ.damOA.yL+2*ln(Econ.damOA.k0))+2*Econ.damOA.a",
  DP_[64],"Econ.damOA.yL");
W_[181] = logGuarded(DP_[66],"Econ.damOA.k0");
W_[182] = divmacro(logGuarded(DP_[67],"Econ.damOA.k1")-DP_[62],"ln(Econ.damOA.k1)-Econ.damOA.a",1
  +sqr(DP_[65])-2*DP_[65],"1+Econ.damOA.yU^2-2*Econ.damOA.yU");
W_[183] = divmacro(2*(DP_[63]+DP_[62])*DP_[65]-(DP_[63]*sqr(DP_[65])+2*
  logGuarded(DP_[67],"Econ.damOA.k1")*DP_[65])-DP_[63],"2*(Econ.damOA.b+Econ.damOA.a)*Econ.damOA.yU-(Econ.damOA.b*Econ.damOA.yU^2+2*ln(Econ.damOA.k1)*Econ.damOA.yU)-Econ.damOA.b",1
  +sqr(DP_[65])-2*DP_[65],"1+Econ.damOA.yU^2-2*Econ.damOA.yU");
W_[184] = divmacro(logGuarded(DP_[67],"Econ.damOA.k1")*sqr(DP_[65])+DP_[63]*sqr(
  DP_[65])-2*(DP_[63]+DP_[62])*DP_[65]+DP_[63]+DP_[62],"ln(Econ.damOA.k1)*Econ.damOA.yU^2+Econ.damOA.b*Econ.damOA.yU^2-2*(Econ.damOA.b+Econ.damOA.a)*Econ.damOA.yU+Econ.damOA.b+Econ.damOA.a",1
  +sqr(DP_[65])-2*DP_[65],"1+Econ.damOA.yU^2-2*Econ.damOA.yU");
  W_[188] = (PushModelContext(1,"Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(1, Econ.damOA.a, Econ.damOA.b, Econ.damOA.cL, Econ.damOA.cU, Econ.damOA.yL, Econ.damOA.yU)")
    Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(1, DP_[62], DP_[63],
     RealTemporaryDense( &W_[179], 1, 3), RealTemporaryDense( &W_[182], 1, 3), 
    DP_[64], DP_[65]));
  PopAllMarks();
  AssertModelica(W_[188] >= 0,"Econ.damOA.kTheta_nominal >= 0", "Flow coefficient must not be negative");
  ;
  W_[187] = sqrtGuarded(divmacro(2.4,"2.4",W_[188],"Econ.damOA.kTheta_nominal"),
    "2.4/Econ.damOA.kTheta_nominal")*W_[174];
W_[165] = sqr(divmacro(2.31,"2.31",W_[187],"Econ.damOA.kDam_nominal"));
W_[185] = IF DP_[60] THEN 0.886226925452758 ELSE 1;
W_[186] = IF DP_[58] THEN divmacro(divmacro(2.31,"2.31",W_[177],"Econ.damOA.rho_nominal"),
  "2.31/Econ.damOA.rho_nominal",DP_[59],"Econ.damOA.v_nominal") ELSE W_[174];
W_[194] = 0.01*W_[6];
W_[195] = DP_[3];
W_[217] = DP_[86];
W_[222] = divmacro(logGuarded(DP_[83],"Econ.damExh.k0")-DP_[80]-DP_[79],
  "ln(Econ.damExh.k0)-Econ.damExh.b-Econ.damExh.a",sqr(DP_[81]),"Econ.damExh.yL^2");
W_[223] = divmacro(2*DP_[80]-(DP_[80]*DP_[81]+2*logGuarded(DP_[83],
  "Econ.damExh.k0"))+2*DP_[79],"2*Econ.damExh.b-(Econ.damExh.b*Econ.damExh.yL+2*ln(Econ.damExh.k0))+2*Econ.damExh.a",
  DP_[81],"Econ.damExh.yL");
W_[224] = logGuarded(DP_[83],"Econ.damExh.k0");
W_[225] = divmacro(logGuarded(DP_[84],"Econ.damExh.k1")-DP_[79],"ln(Econ.damExh.k1)-Econ.damExh.a",1
  +sqr(DP_[82])-2*DP_[82],"1+Econ.damExh.yU^2-2*Econ.damExh.yU");
W_[226] = divmacro(2*(DP_[80]+DP_[79])*DP_[82]-(DP_[80]*sqr(DP_[82])+2*
  logGuarded(DP_[84],"Econ.damExh.k1")*DP_[82])-DP_[80],"2*(Econ.damExh.b+Econ.damExh.a)*Econ.damExh.yU-(Econ.damExh.b*Econ.damExh.yU^2+2*ln(Econ.damExh.k1)*Econ.damExh.yU)-Econ.damExh.b",1
  +sqr(DP_[82])-2*DP_[82],"1+Econ.damExh.yU^2-2*Econ.damExh.yU");
W_[227] = divmacro(logGuarded(DP_[84],"Econ.damExh.k1")*sqr(DP_[82])+DP_[80]*
  sqr(DP_[82])-2*(DP_[80]+DP_[79])*DP_[82]+DP_[80]+DP_[79],"ln(Econ.damExh.k1)*Econ.damExh.yU^2+Econ.damExh.b*Econ.damExh.yU^2-2*(Econ.damExh.b+Econ.damExh.a)*Econ.damExh.yU+Econ.damExh.b+Econ.damExh.a",1
  +sqr(DP_[82])-2*DP_[82],"1+Econ.damExh.yU^2-2*Econ.damExh.yU");
  W_[231] = (PushModelContext(1,"Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(1, Econ.damExh.a, Econ.damExh.b, Econ.damExh.cL, Econ.damExh.cU, Econ.damExh.yL, Econ.damExh.yU)")
    Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(1, DP_[79], DP_[80],
     RealTemporaryDense( &W_[222], 1, 3), RealTemporaryDense( &W_[225], 1, 3), 
    DP_[81], DP_[82]));
  PopAllMarks();
  AssertModelica(W_[231] >= 0,"Econ.damExh.kTheta_nominal >= 0", 
    "Flow coefficient must not be negative");
  ;
  W_[230] = sqrtGuarded(divmacro(2.4,"2.4",W_[231],"Econ.damExh.kTheta_nominal"),
    "2.4/Econ.damExh.kTheta_nominal")*W_[217];
W_[207] = sqr(divmacro(2.31,"2.31",W_[230],"Econ.damExh.kDam_nominal"));
W_[228] = IF DP_[77] THEN 0.886226925452758 ELSE 1;
W_[229] = IF DP_[75] THEN divmacro(divmacro(2.31,"2.31",W_[220],"Econ.damExh.rho_nominal"),
  "2.31/Econ.damExh.rho_nominal",DP_[76],"Econ.damExh.v_nominal") ELSE W_[217];
W_[236] = 0.01*W_[6];
W_[237] = DP_[3];
W_[261] = DP_[102];
W_[266] = divmacro(logGuarded(DP_[99],"Econ.damRec.k0")-DP_[96]-DP_[95],
  "ln(Econ.damRec.k0)-Econ.damRec.b-Econ.damRec.a",sqr(DP_[97]),"Econ.damRec.yL^2");
W_[267] = divmacro(2*DP_[96]-(DP_[96]*DP_[97]+2*logGuarded(DP_[99],
  "Econ.damRec.k0"))+2*DP_[95],"2*Econ.damRec.b-(Econ.damRec.b*Econ.damRec.yL+2*ln(Econ.damRec.k0))+2*Econ.damRec.a",
  DP_[97],"Econ.damRec.yL");
W_[268] = logGuarded(DP_[99],"Econ.damRec.k0");
W_[269] = divmacro(logGuarded(DP_[100],"Econ.damRec.k1")-DP_[95],
  "ln(Econ.damRec.k1)-Econ.damRec.a",1+sqr(DP_[98])-2*DP_[98],"1+Econ.damRec.yU^2-2*Econ.damRec.yU");
W_[270] = divmacro(2*(DP_[96]+DP_[95])*DP_[98]-(DP_[96]*sqr(DP_[98])+2*
  logGuarded(DP_[100],"Econ.damRec.k1")*DP_[98])-DP_[96],"2*(Econ.damRec.b+Econ.damRec.a)*Econ.damRec.yU-(Econ.damRec.b*Econ.damRec.yU^2+2*ln(Econ.damRec.k1)*Econ.damRec.yU)-Econ.damRec.b",1
  +sqr(DP_[98])-2*DP_[98],"1+Econ.damRec.yU^2-2*Econ.damRec.yU");
W_[271] = divmacro(logGuarded(DP_[100],"Econ.damRec.k1")*sqr(DP_[98])+DP_[96]*
  sqr(DP_[98])-2*(DP_[96]+DP_[95])*DP_[98]+DP_[96]+DP_[95],"ln(Econ.damRec.k1)*Econ.damRec.yU^2+Econ.damRec.b*Econ.damRec.yU^2-2*(Econ.damRec.b+Econ.damRec.a)*Econ.damRec.yU+Econ.damRec.b+Econ.damRec.a",1
  +sqr(DP_[98])-2*DP_[98],"1+Econ.damRec.yU^2-2*Econ.damRec.yU");
  W_[275] = (PushModelContext(1,"Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(1, Econ.damRec.a, Econ.damRec.b, Econ.damRec.cL, Econ.damRec.cU, Econ.damRec.yL, Econ.damRec.yU)")
    Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(1, DP_[95], DP_[96],
     RealTemporaryDense( &W_[266], 1, 3), RealTemporaryDense( &W_[269], 1, 3), 
    DP_[97], DP_[98]));
  PopAllMarks();
  AssertModelica(W_[275] >= 0,"Econ.damRec.kTheta_nominal >= 0", 
    "Flow coefficient must not be negative");
  ;
  W_[274] = sqrtGuarded(divmacro(2.4,"2.4",W_[275],"Econ.damRec.kTheta_nominal"),
    "2.4/Econ.damRec.kTheta_nominal")*W_[261];
W_[251] = sqr(divmacro(2.31,"2.31",W_[274],"Econ.damRec.kDam_nominal"));
W_[272] = IF DP_[93] THEN 0.886226925452758 ELSE 1;
W_[273] = IF DP_[91] THEN divmacro(divmacro(2.31,"2.31",W_[264],"Econ.damRec.rho_nominal"),
  "2.31/Econ.damRec.rho_nominal",DP_[92],"Econ.damRec.v_nominal") ELSE W_[261];
W_[287] = 0.01*W_[6];
W_[288] = DP_[3];
W_[318] = 0.01*W_[6];
W_[319] = DP_[3];
W_[350] = 0.01*W_[6];
W_[351] = DP_[3];
W_[418] = 0.01*W_[6];
W_[419] = DP_[3];
W_[451] = W_[6];
W_[452] = W_[451];
W_[461] = DP_[213];
W_[463] = DP_[212];
W_[473] = DP_[125];
W_[474] = DP_[120];
W_[477] = DP_[123];
W_[478] = DP_[124];
W_[491] = DP_[143];
W_[492] = DP_[138];
W_[495] = DP_[141];
W_[496] = DP_[142];
W_[508] = DP_[162];
W_[509] = DP_[157];
W_[512] = DP_[160];
W_[513] = DP_[161];
W_[524] = DP_[180];
W_[525] = DP_[175];
W_[528] = DP_[178];
W_[529] = DP_[179];
W_[539] = DP_[198];
W_[540] = DP_[193];
W_[543] = DP_[196];
W_[544] = DP_[197];
W_[790] = divmacro(0.0666666666666667*DP_[255],"0.0666666666666667*Q_hc_d",
  DP_[44],"cp_a");
W_[553] = W_[790];
W_[627] = DP_[249];
W_[635] = W_[6];
BreakSectionFunction(9);
 /* Linear system of equations to solve. */
/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
helpvar[3] = IF W_[636] THEN 0 ELSE 0.000994579541498831;
W_[637] = 300;
SolveScalarLinearParametric(1-helpvar[3]*(IF W_[636] THEN 1005.45 ELSE 0),
  "1-(if del.use_T_start then 0 else 0.000994579541498831)*(if del.use_T_start then 1005.45 else 0)",
   (IF W_[636] THEN W_[7] ELSE 298.15)+helpvar[3]*(IF W_[636] THEN -299774.9175
   ELSE -5027.25),"(if del.use_T_start then system.T_start else 298.15)+(if del.use_T_start then 0 else 0.000994579541498831)*(if del.use_T_start then -299774.9175 else -5027.25)",
   W_[637],"del.T_start");
W_[638] = IF W_[636] THEN 1005.45*(W_[637]-298.15) ELSE -5027.25;
 /* End of Equation Block */ 

BreakSectionFunction(10);
W_[657] = DP_[4];
W_[667] = DP_[1];
W_[700] = W_[635];
W_[702] = 1.18430792005922E-005*W_[700];
W_[704] = divmacro(W_[703]*DP_[216],"del.m_flow_nominal*del.tau",W_[702],
  "del.rho_nominal");
W_[699] = W_[704];
W_[686] = 3.14159265358979*powmacro(0.75*W_[699],"0.75*del.V",0.666666666666667,
  "0.666666666666667");
W_[701] = W_[637];
W_[711] = DP_[217];
W_[712] = DP_[218];
W_[714] = DP_[6];
W_[715] = DP_[7];
W_[721] = IF W_[720] THEN 1005.45*(DP_[224]-298.15) ELSE -5027.25;
W_[740] = DP_[221];
W_[748] = DP_[218];
W_[770] = W_[714];
W_[761] = 3.14159265358979*powmacro(0.75*W_[770],"0.75*room.vol.V",
  0.666666666666667,"0.666666666666667");
W_[771] = DP_[223];
W_[772] = DP_[224];
W_[773] = 1.18430792005922E-005*W_[771];
W_[776] = W_[715];
W_[781] = DP_[8];
W_[779] = W_[781];
W_[791] = divmacro(0.17921146953405*DP_[250],"0.17921146953405*Q_cc_d",DP_[45],
  "cp_w");
W_[792] = 299.85-divmacro(0.432900432900433*DP_[250],"0.432900432900433*Q_cc_d",
  DP_[44],"cp_a");
W_[793] = divmacro(0.0909090909090909*DP_[255],"0.0909090909090909*Q_hc_d",
  DP_[45],"cp_w");
W_[798] = 0.01*W_[6];
W_[799] = DP_[3];
W_[838] = W_[790];
W_[839] = W_[793];
W_[840] = 0.0001*W_[838];
W_[841] = 0.0001*W_[839];
W_[842] = W_[6];
W_[843] = W_[842];
W_[844] = W_[6];
W_[845] = W_[844];
W_[862] = DP_[253];
W_[865] = DP_[254];
W_[922] = divmacro(15,"15",W_[794]-DP_[256],"T_ew_hc_d-T_ea_hc_d");
W_[867] = W_[922];
W_[885] = W_[791];
W_[887] = 0.0001*W_[885];
W_[888] = W_[6];
W_[889] = W_[888];
W_[890] = W_[6];
W_[891] = W_[890];
W_[908] = DP_[251];
W_[911] = DP_[252];
W_[923] = divmacro(DP_[248]-W_[792],"T_ea_cc_d-T_la_cc_d",DP_[248]-DP_[249],
  "T_ea_cc_d-T_ew_cc_d");
W_[913] = W_[923];
W_[952] = divmacro(1,"1",DP_[10],"DmprC.Ti");
W_[954] = DP_[18];
W_[956] = divmacro(1,"1",DP_[9]*DP_[16],"DmprC.k*DmprC.Ni");
W_[959] = divmacro(1,"1",DP_[121],"EcoC.Ti");
W_[961] = DP_[129];
W_[963] = divmacro(1,"1",DP_[120]*DP_[127],"EcoC.k*EcoC.Ni");
W_[966] = divmacro(1,"1",DP_[139],"CCC.Ti");
W_[968] = DP_[147];
W_[970] = divmacro(1,"1",DP_[138]*DP_[145],"CCC.k*CCC.Ni");
W_[973] = divmacro(1,"1",DP_[158],"HCC.Ti");
W_[975] = DP_[166];
W_[977] = divmacro(1,"1",DP_[157]*DP_[164],"HCC.k*HCC.Ni");
W_[980] = divmacro(1,"1",DP_[176],"RHCC.Ti");
W_[982] = DP_[184];
W_[984] = divmacro(1,"1",DP_[175]*DP_[182],"RHCC.k*RHCC.Ni");
W_[987] = divmacro(1,"1",DP_[194],"FanC.Ti");
W_[989] = DP_[202];
W_[991] = divmacro(1,"1",DP_[193]*DP_[200],"FanC.k*FanC.Ni");
W_[54] = divmacro(logGuarded(DP_[40],"VAV.k0")-DP_[37]-DP_[36],"ln(VAV.k0)-VAV.b-VAV.a",
  sqr(DP_[38]),"VAV.yL^2");
W_[55] = divmacro(2*DP_[37]-(DP_[37]*DP_[38]+2*logGuarded(DP_[40],"VAV.k0"))+2*
  DP_[36],"2*VAV.b-(VAV.b*VAV.yL+2*ln(VAV.k0))+2*VAV.a",DP_[38],"VAV.yL");
W_[56] = logGuarded(DP_[40],"VAV.k0");
W_[57] = divmacro(logGuarded(DP_[41],"VAV.k1")-DP_[36],"ln(VAV.k1)-VAV.a",1+sqr(
  DP_[39])-2*DP_[39],"1+VAV.yU^2-2*VAV.yU");
W_[58] = divmacro(2*(DP_[37]+DP_[36])*DP_[39]-(DP_[37]*sqr(DP_[39])+2*logGuarded
  (DP_[41],"VAV.k1")*DP_[39])-DP_[37],"2*(VAV.b+VAV.a)*VAV.yU-(VAV.b*VAV.yU^2+2*ln(VAV.k1)*VAV.yU)-VAV.b",1
  +sqr(DP_[39])-2*DP_[39],"1+VAV.yU^2-2*VAV.yU");
W_[59] = divmacro(logGuarded(DP_[41],"VAV.k1")*sqr(DP_[39])+DP_[37]*sqr(DP_[39])
  -2*(DP_[37]+DP_[36])*DP_[39]+DP_[37]+DP_[36],"ln(VAV.k1)*VAV.yU^2+VAV.b*VAV.yU^2-2*(VAV.b+VAV.a)*VAV.yU+VAV.b+VAV.a",1
  +sqr(DP_[39])-2*DP_[39],"1+VAV.yU^2-2*VAV.yU");
RealFillAssign (RealTemporaryDense( &W_[941], 1, 2), 0);
PopAllMarks();
  W_[940] = (PushModelContext(1,"Buildings.Utilities.IO.BCVTB.BaseClasses.establishClientSocket(\"socket.cfg\")")
    Buildings_Utilities_IO_BCVTB_BaseClasses_establishClientSocket_M(
    "socket.cfg"));
  AssertModelica(W_[940] >= 0,"cliBCVTB.socketFD >= 0", StringAdd(
    "Socket file descripter for BCVTB must be positive.\n   A negative value indicates that no connection\n   could be established. Check file 'utilSocket.log'.\n   Received: socketFD = ",
    Integer2String(W_[940], 1, 1)));
  ;
  PopAllMarks();
  W_[937] = 0;
  RealFillAssign (RealTemporaryDense( &X_[4], 1, 2), 0);
  PopAllMarks();
  RealFillAssign (RealTemporaryDense( &W_[944], 1, 2), 0);
  PopAllMarks();
  {
    int i_0_;
    int i0_0_0;
    for(i_0_ = 0, i0_0_0 = 1;i0_0_0 <= 2;i0_0_0 += 1 , ++i_0_) {
      AssertModelica(IntegerElement( IntegerTemporaryDense( &DP_[285], 1, 2), 
        (SizeType)( i0_0_0 )) >= 0 AND IntegerElement( IntegerTemporaryDense( 
        &DP_[285], 1, 2), (SizeType)( i0_0_0 )) <= 2,"cliBCVTB.flaDblWri[i] >= 0 and cliBCVTB.flaDblWri[i] <= 2",
         StringAdd(StringAdd("Parameter flaDblWri out of range for ",
        Integer2String(i0_0_0, 1, 1)),"-th component."));
      ;
      PopAllMarks();
      if (IntegerElement( IntegerTemporaryDense( &DP_[285], 1, 2), (SizeType)( 
        i0_0_0 )) == 0) {
        SetRealElement(RealElement( RealTemporaryDense( &DP_[287], 1, 2), 
          (SizeType)( i0_0_0 )), RealTemporaryDense( &W_[941], 1, 2), 
          (SizeType)( i0_0_0 ));
        PopAllMarks();
      }
      else if (IntegerElement( IntegerTemporaryDense( &DP_[285], 1, 2), 
        (SizeType)( i0_0_0 )) == 1) {
        SetRealElement(RealElement( RealTemporaryDense( &DP_[287], 1, 2), 
          (SizeType)( i0_0_0 )), RealTemporaryDense( &W_[941], 1, 2), 
          (SizeType)( i0_0_0 ));
        PopAllMarks();
      }
      else{
        SetRealElement(RealElement( RealTemporaryDense( &DP_[287], 1, 2), 
          (SizeType)( i0_0_0 ))*DP_[283], RealTemporaryDense( &W_[941], 1, 2), 
          (SizeType)( i0_0_0 ));
        PopAllMarks();
      }
    }
  }
W_[935] = Aux_[33];
W_[938] = Aux_[26];
W_[947] = Aux_[32];
W_[946] = Aux_[31];
W_[936] = Aux_[34];
W_[44] = IF DP_[29] THEN 2.31*DP_[30] ELSE 1.82E-005*DP_[35]*sqrtGuarded(W_[61],
  "VAV.area")*W_[60];
W_[620] = 4184*(W_[627]-273.15);
W_[903] = 273.15+0.000239005736137667*W_[620];
W_[254] = IF DP_[89] THEN 2.31*DP_[90] ELSE 1.82E-005*DP_[94]*sqrtGuarded(
  W_[273],"Econ.damRec.area")*W_[272];
W_[210] = IF DP_[73] THEN 2.31*DP_[74] ELSE 1.82E-005*DP_[78]*sqrtGuarded(
  W_[229],"Econ.damExh.area")*W_[228];
W_[168] = IF DP_[56] THEN 2.31*DP_[57] ELSE 1.82E-005*DP_[61]*sqrtGuarded(
  W_[186],"Econ.damOA.area")*W_[185];
W_[613] = 4184*(W_[627]-273.15);
W_[618] = W_[627]-273.15;
W_[663] = 12.5663706143592*powmacro(0.238732414637843*W_[699],"0.238732414637843*del.V",
  0.666666666666667,"0.666666666666667");
W_[745] = 12.5663706143592*powmacro(0.238732414637843*W_[770],"0.238732414637843*room.vol.V",
  0.666666666666667,"0.666666666666667");
InitialSection
Aux_[29] = W_[944];
Aux_[30] = W_[945];
InitialSection2
X_[8] = W_[968];
X_[9] = W_[975];
X_[11] = W_[989];
X_[6] = W_[954];
X_[7] = W_[961];
X_[1] = W_[699]*W_[702];
W_[722] = DP_[223];
W_[724] = 1.18430792005922E-005*W_[722];
X_[3] = W_[770]*W_[724];
W_[933] = DP_[224];
W_[723] = 1005.45*(W_[933]-298.15);
W_[726] = W_[723]-287.051224952979*W_[933];
X_[2] = X_[3]*W_[726];
X_[10] = W_[982];
W_[939] = Aux_[25];
InitialSection
Aux_[24] = W_[937];
InitialSection2
W_[927] = Aux_[23];
InitialSection2
W_[934] = Aux_[28];
InitialSection
Init=false;InitializeData(2);Init=true;
InitialSection2
AssertModelica(DP_[40] > DP_[41],"VAV.k0 > VAV.k1", "k0 must be bigger than k1.");
;
AssertModelica(DP_[66] > DP_[67],"Econ.damOA.k0 > Econ.damOA.k1", 
  "k0 must be bigger than k1.");
;
AssertModelica(DP_[83] > DP_[84],"Econ.damExh.k0 > Econ.damExh.k1", 
  "k0 must be bigger than k1.");
;
AssertModelica(DP_[99] > DP_[100],"Econ.damRec.k0 > Econ.damRec.k1", 
  "k0 must be bigger than k1.");
;
AssertModelica(W_[17] >= W_[18],"DmprC.limiter.uMax >= DmprC.limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[17], true, 0)),") < uMin (="),Real2String2(W_[18], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(DP_[12] >= DP_[13],"DmprC.yMax >= DmprC.yMin", StringAdd(
  StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[12], true, 0)),") < yMin (="),Real2String2(DP_[13], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(355.35 >= (PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(-1)")
  Modelica_SIunits_Conversions_fromx_0degC(-1)) AND 355.35 <= (PushModelContext(1,
  "Modelica.SIunits.Conversions.from_degC(130)")Modelica_SIunits_Conversions_fromx_0degC
  (130)),"355.35 >= Modelica.SIunits.Conversions.from_degC(-1) and 355.35 <= Modelica.SIunits.Conversions.from_degC(130)",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("\nTemperature T (= 355.35 K) is not\nin the allowed range (",
  Real2String2((PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(-1)")
  Modelica_SIunits_Conversions_fromx_0degC(-1)), true, 0))," K <= T <= "),
  Real2String2((PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(130)")
  Modelica_SIunits_Conversions_fromx_0degC(130)), true, 0))," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
;
PopAllMarks();
AssertModelica(W_[477] >= W_[478],"EcoC.limiter.uMax >= EcoC.limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[477], true, 0)),") < uMin (="),Real2String2(W_[478], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(DP_[123] >= DP_[124],"EcoC.yMax >= EcoC.yMin", StringAdd(
  StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[123], true, 0)),") < yMin (="),Real2String2(DP_[124], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(W_[495] >= W_[496],"CCC.limiter.uMax >= CCC.limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[495], true, 0)),") < uMin (="),Real2String2(W_[496], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(DP_[141] >= DP_[142],"CCC.yMax >= CCC.yMin", StringAdd(StringAdd(
  StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[141], true, 0)),") < yMin (="),Real2String2(DP_[142], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(W_[512] >= W_[513],"HCC.limiter.uMax >= HCC.limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[512], true, 0)),") < uMin (="),Real2String2(W_[513], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(DP_[160] >= DP_[161],"HCC.yMax >= HCC.yMin", StringAdd(StringAdd(
  StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[160], true, 0)),") < yMin (="),Real2String2(DP_[161], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(W_[528] >= W_[529],"RHCC.limiter.uMax >= RHCC.limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[528], true, 0)),") < uMin (="),Real2String2(W_[529], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(DP_[178] >= DP_[179],"RHCC.yMax >= RHCC.yMin", StringAdd(
  StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[178], true, 0)),") < yMin (="),Real2String2(DP_[179], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(W_[543] >= W_[544],"FanC.limiter.uMax >= FanC.limiter.uMin", 
  StringAdd(StringAdd(StringAdd(StringAdd("Limiter: Limits must be consistent. However, uMax (=",
  Real2String2(W_[543], true, 0)),") < uMin (="),Real2String2(W_[544], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(DP_[196] >= DP_[197],"FanC.yMax >= FanC.yMin", StringAdd(
  StringAdd(StringAdd(StringAdd("LimPID: Limits must be consistent. However, yMax (=",
  Real2String2(DP_[196], true, 0)),") < yMin (="),Real2String2(DP_[197], true, 0)),
  ")"));
;
PopAllMarks();
AssertModelica(293.15 >= (PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(-1)")
  Modelica_SIunits_Conversions_fromx_0degC(-1)) AND 293.15 <= (PushModelContext(1,
  "Modelica.SIunits.Conversions.from_degC(130)")Modelica_SIunits_Conversions_fromx_0degC
  (130)),"293.15 >= Modelica.SIunits.Conversions.from_degC(-1) and 293.15 <= Modelica.SIunits.Conversions.from_degC(130)",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("\nTemperature T (= 293.15 K) is not\nin the allowed range (",
  Real2String2((PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(-1)")
  Modelica_SIunits_Conversions_fromx_0degC(-1)), true, 0))," K <= T <= "),
  Real2String2((PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(130)")
  Modelica_SIunits_Conversions_fromx_0degC(130)), true, 0))," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
;
PopAllMarks();
AssertModelica(293.15 >= (PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(-1)")
  Modelica_SIunits_Conversions_fromx_0degC(-1)) AND 293.15 <= (PushModelContext(1,
  "Modelica.SIunits.Conversions.from_degC(130)")Modelica_SIunits_Conversions_fromx_0degC
  (130)),"293.15 >= Modelica.SIunits.Conversions.from_degC(-1) and 293.15 <= Modelica.SIunits.Conversions.from_degC(130)",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("\nTemperature T (= 293.15 K) is not\nin the allowed range (",
  Real2String2((PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(-1)")
  Modelica_SIunits_Conversions_fromx_0degC(-1)), true, 0))," K <= T <= "),
  Real2String2((PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(130)")
  Modelica_SIunits_Conversions_fromx_0degC(130)), true, 0))," K)\nrequired from medium model \""),
  "SimpleLiquidWater"),"\".\n"));
;
PopAllMarks();
AssertModelica(W_[627] >= (PushModelContext(1,"Modelica.SIunits.Conversions.from_degC(-1)")
  Modelica_SIunits_Conversions_fromx_0degC(-1)) AND W_[627] <= (PushModelContext(1,
  "Modelica.SIunits.Conversions.from_degC(130)")Modelica_SIunits_Conversions_fromx_0degC
  (130)),"chiller.T >= Modelica.SIunits.Conversions.from_degC(-1) and chiller.T <= Modelica.SIunits.Conversions.from_degC(130)",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("\nTemperature T (= ",Real2String2(W_[627], true, 0)),
  " K) is not\nin the allowed range ("),Real2String2((PushModelContext(1,
  "Modelica.SIunits.Conversions.from_degC(-1)")Modelica_SIunits_Conversions_fromx_0degC
  (-1)), true, 0))," K <= T <= "),Real2String2((PushModelContext(1,
  "Modelica.SIunits.Conversions.from_degC(130)")Modelica_SIunits_Conversions_fromx_0degC
  (130)), true, 0))," K)\nrequired from medium model \""),"SimpleLiquidWater"),
  "\".\n"));
;
PopAllMarks();

OutputSection
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, Boi.X_in_internal, \"MassFlowSource_T\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays0, 1, 1), true, true, RealTemporaryDense( &W_[144], 1, 1), 
  "MassFlowSource_T"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"GasesPTDecoupled.SimpleAir\", {\"GasesPTDecoupled.SimpleAir\"}, false, true, Amb.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("GasesPTDecoupled.SimpleAir", 
  StringTemporaryDense( DymArrays1, 1, 1), false, true, RealTemporaryDense( 
  &W_[414], 1, 1), "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, Amb1.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays0, 1, 1), true, true, RealTemporaryDense( &W_[581], 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, Amb2.X_in_internal, \"Boundary_pT\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays0, 1, 1), true, true, RealTemporaryDense( &W_[609], 1, 1), 
  "Boundary_pT"));
PopAllMarks();
(PushModelContext(1,"Modelica.Fluid.Utilities.checkBoundary(\"SimpleLiquidWater\", {\"SimpleLiquidWater\"}, true, true, chiller.X_in_internal, \"MassFlowSource_T\")")
  Modelica_Fluid_Utilities_checkBoundary("SimpleLiquidWater", StringTemporaryDense( 
  DymArrays0, 1, 1), true, true, RealTemporaryDense( &W_[629], 1, 1), 
  "MassFlowSource_T"));
PopAllMarks();

DynamicsSection
W_[926] = sample(DP_[284], DP_[283], 0);
beginwhenBlock
whenModelicaS(W_[926])
  W_[927] = Time <= DP_[284]+0.5*DP_[283];
endwhenModelica()
endwhenBlock
W_[946] = PRE(W_[946], 0);
W_[947] = PRE(W_[947], 1);
W_[937] = PRE(W_[937], 2);
W_[938] = PRE(W_[938], 3);
W_[935] = PRE(W_[935], 4);
W_[936] = PRE(W_[936], 5);
W_[939] = PRE(W_[939], 6);
W_[944] = PRE(W_[944], 7);
W_[945] = PRE(W_[945], 8);
  beginwhenBlock
  vectorWhenOld(IntegerTemporaryDense( &W_[926], 1, 1), 0, 1) 
    AssertModelica(W_[937] == 0,"cliBCVTB.flaRea == 0", StringAdd(
      "BCVTB interface attempts to exchange data after Ptolemy reached its final time.\n   Aborting simulation. Check final time in Modelica and in Ptolemy.\n   Received: flaRea = ",
      Integer2String(W_[937], 1, 1)));
    ;
    PopAllMarks();
    {
      int i0_0_0;
      for(i0_0_0 = 1;i0_0_0 <= 2;i0_0_0 += 1) {
        if (IntegerElement( IntegerTemporaryDense( &DP_[285], 1, 2), 
          (SizeType)( i0_0_0 )) == 0) {
          SetRealElement(RealElement( RealScalarArray ( 2, PRE(W_[933], 9), PRE(
            W_[934], 10)), (SizeType)( i0_0_0 )), RealTemporaryDense( &W_[946], 1,
             2), (SizeType)( i0_0_0 ));
          PopAllMarks();
        }
        else{
          SetRealElement(RealElement( RealTemporaryDense( &X_[4], 1, 2), 
            (SizeType)( i0_0_0 ))-RealElement( RealTemporaryDense( &W_[944], 1, 2),
             (SizeType)( i0_0_0 )), RealTemporaryDense( &W_[946], 1, 2), 
            (SizeType)( i0_0_0 ));
          PopAllMarks();
          if (IntegerElement( IntegerTemporaryDense( &DP_[285], 1, 2), 
            (SizeType)( i0_0_0 )) == 1) {
            SetRealElement(divmacro(RealElement( RealTemporaryDense( &W_[946], 1,
               2), (SizeType)( i0_0_0 )),"cliBCVTB.uRWri[i]",DP_[283],
              "cliBCVTB.samplePeriod"), RealTemporaryDense( &W_[946], 1, 2), 
              (SizeType)( i0_0_0 ));
            PopAllMarks();
          }
        }
      }
    }
    {
      struct Buildings_Utilities_IO_BCVTB_BaseClasses_exchangeReals_M_struct
         dummy_mult_=(PushModelContext(1,"Buildings.Utilities.IO.BCVTB.BaseClasses.exchangeReals(cliBCVTB.socketFD, 0, time, (if cliBCVTB.firstTrigger then cliBCVTB._uStart else cliBCVTB.uRWri), 2, 2)")
        Buildings_Utilities_IO_BCVTB_BaseClasses_exchangeReals_M(W_[940], 0, 
        Time, IF W_[927] THEN RealTemporaryDense( &W_[941], 1, 2) ELSE 
        RealTemporaryDense( &W_[946], 1, 2), 2, 2));
      W_[937] = dummy_mult_.flaRea0_0_0member;
      W_[938] = dummy_mult_.simTimRea0_0_0member;
      RealAssign (RealTemporaryDense( &W_[935], 1, 2), dummy_mult_.dblValRea0_0_0member);
      W_[939] = dummy_mult_.retVal0_0_0member;
    }
    PopAllMarks();
    AssertModelica(W_[937] >= 0,"cliBCVTB.flaRea >= 0", StringAdd(
      "BCVTB sent a negative flag to Modelica during data transfer.\n   Aborting simulation. Check file 'utilSocket.log'.\n   Received: flaRea = ",
      Integer2String(W_[937], 1, 1)));
    ;
    PopAllMarks();
    AssertModelica(W_[939] >= 0,"cliBCVTB.retVal >= 0", StringAdd(
      "Obtained negative return value during data transfer with BCVTB.\n   Aborting simulation. Check file 'utilSocket.log'.\n   Received: retVal = ",
      Integer2String(W_[939], 1, 1)));
    ;
    PopAllMarks();
    RealAssign (RealTemporaryDense( &W_[944], 1, 2), RealTemporaryDense( &X_[4],
       1, 2));
    PopAllMarks();
  endVectorWhen()
  endwhenBlock
  beginwhenBlock
  whenModelicaOld(terminal(), 1) 
    (PushModelContext(1,"Buildings.Utilities.IO.BCVTB.BaseClasses.closeClientSocket(cliBCVTB.socketFD)")
      Buildings_Utilities_IO_BCVTB_BaseClasses_closeClientSocket_M(W_[940]));
  endwhenModelica()
  endwhenBlock
 /* Linear system of equations to solve. */
W_[641] = RememberSimple_(W_[641], 0);
SolveScalarLinearParametric( -W_[699]," -del.V",  -X_[1]," -del.m", W_[641],
  "del.medium.d");
 /* End of Equation Block */ 

W_[639] = 84437.5*W_[641];
PopModelContext();
 /* Linear system of equations to solve. */
W_[726] = RememberSimple_(W_[726], 1);
SolveScalarLinear( -X_[3]," -room.vol.m",  -X_[2]," -room.vol.U", W_[726],
  "room.vol.medium.u");
 /* End of Equation Block */ 

BreakSectionFunction(11);
 /* Linear system of equations to solve. */
W_[933] = (-0.00139198455611864)*(-299774.9175-W_[726]);

W_[723] = 1005.45*(W_[933]-298.15);
 /* End of Equation Block */ 

BreakSectionFunction(12);
W_[12] = W_[13]*W_[935]+DP_[21]*W_[933];
W_[16] = DP_[22]*W_[12];
W_[15] = DP_[23]*W_[16]+DP_[24]*DP_[26]+DP_[25]*X_[6];
W_[20] = W_[14]*W_[15];
W_[21] = IF GreaterS(W_[20],"DmprC.limiter.u", W_[17],"DmprC.limiter.uMax", 0)
   THEN W_[17] ELSE IF LessS(W_[20],"DmprC.limiter.u", W_[18],"DmprC.limiter.uMin",
   1) THEN W_[18] ELSE W_[20];
W_[826] = DP_[259]*W_[21];
W_[53] = (PushModelContext(1,"Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(gain2.y, VAV.a, VAV.b, VAV.cL, VAV.cU, VAV.yL, VAV.yU)")
  Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(W_[826], DP_[36], 
  DP_[37], RealTemporaryDense( &W_[54], 1, 3), RealTemporaryDense( &W_[57], 1, 3),
   DP_[38], DP_[39]));
PopAllMarks();
 /* Linear system of equations to solve. */
W_[724] = RememberSimple_(W_[724], 2);
SolveScalarLinearParametric( -W_[770]," -room.vol.V",  -X_[3]," -room.vol.m", 
  W_[724],"room.vol.medium.d");
 /* End of Equation Block */ 

W_[722] = 84437.5*W_[724];
BreakSectionFunction(13);
{ /* Non-linear system of equations to solve. */
/* Introducing 101 common subexpressions and reusing 4 variables totally
   used in 72 expressions */
/* Of the common subexpressions 101 are reals, 2 are integers, and 2
   are booleans. */
const char*const varnames_[]={"RHC.port_b.p", "RHC.port_a.p", "SupF.port_a.p", 
  "HC.port_b1.p", "HC.port_a1.p", "SupF.medium.p"};
const double nominal_[]={100000.0, 100000.0, 100000.0, 100000.0, 100000.0, 
  100000.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 6, 0, 1, 11);
SetInitVector(x__, 1, W_[447], Remember_(W_[447], 3));
SetInitVector(x__, 2, W_[445], Remember_(W_[445], 4));
SetInitVector(x__, 3, W_[66], Remember_(W_[66], 5));
SetInitVector(x__, 4, W_[832], Remember_(W_[832], 6));
SetInitVector(x__, 5, W_[830], Remember_(W_[830], 7));
SetInitVector(x__, 6, W_[83], Remember_(W_[83], 8));
Residues;
  W_[85] = 1.18430792005922E-005*W_[83];
  W_[33] = W_[83]-W_[445];
  W_[51] = IF DP_[42] THEN 1.2 ELSE W_[85];
  helpvar[4] = divmacro(1,"1",W_[53],"VAV.kTheta");
  W_[50] = helpvar[4]*2*W_[51]*W_[61]*W_[61];
  helpvar[5] = divmacro(1,"1",W_[63],"VAV.kResSqu");
  helpvar[6] = divmacro(1,"1",W_[50],"VAV.kDamSqu");
  helpvar[7] = helpvar[5]+helpvar[6];
  helpvar[8] = divmacro(1,"1",helpvar[7],"1/VAV.kResSqu+1/VAV.kDamSqu");
  W_[43] = sqrtGuarded(helpvar[8],"1/(1/VAV.kResSqu+1/VAV.kDamSqu)");
  W_[803] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(VAV.dp, VAV.k, VAV.m_flow_turbulent, false)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[33], W_[43],
     W_[44], false));
  PopModelContext();
  helpvar[9] = divmacro(1,"1",W_[85],"SupF.medium.d");
  W_[111] = helpvar[9]*W_[803];
  helpvar[10] = divmacro(1,"1",DP_[49],"SupF.nParallel");
  W_[112] = helpvar[10]*W_[111];
  W_[804] = W_[447]-W_[722];
  W_[454] = W_[445]-W_[447];
  W_[893] = W_[832]-W_[66];
  W_[847] = W_[830]-W_[832];
  W_[423] = W_[639]-W_[830];
  W_[538] = W_[539]*DP_[211]+DP_[205]*W_[83];
  W_[542] = DP_[206]*W_[538];
  W_[541] = DP_[207]*W_[542]+DP_[208]*DP_[210]+DP_[209]*X_[11];
  W_[546] = W_[540]*W_[541];
  helpvar[11] = GreaterS(W_[546],"FanC.limiter.u", W_[543],"FanC.limiter.uMax", 2);
  W_[547] = IF helpvar[11] THEN W_[543] ELSE IF LessS(W_[546],"FanC.limiter.u", 
    W_[544],"FanC.limiter.uMin", 3) THEN W_[544] ELSE W_[546];
  helpvar[12] = 1500*W_[547];
  W_[113] = RealBmax(helpvar[12], 0.001);
  W_[109] = W_[83]-W_[66];
helpvar[13] = sqr(0.000666666666666667*W_[113]);
helpvar[14] = 1500*W_[112];
helpvar[15] = divmacro(helpvar[14],"1500*SupF.V_flow_single",W_[113],"SupF.N");
helpvar[16] = divmacro(1,"1",W_[113],"SupF.N");
helpvar[17] = (PushModelContext(1,"SupF.flowCharacteristic_Unique'\"1FD32A48\"'(1500*SupF.V_flow_single/SupF.N, {1.888, 2.36, 2.832}, {540.6, 460.8, 386.1})")
  SupF_flowCharacteristicx_0Uniquez_0ccdbegeedddcebdedicc(helpvar[15], 
  RealTemporaryDense( DymArrays2, 1, 3), RealTemporaryDense( DymArrays3, 1, 3)));
PopAllMarks();
helpvar[18] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(filter.dp, 0.231, 0.693, false)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[423], 0.231, 
  0.693, false));
PopModelContext();
if (NewParameters) {
helpvar[19] = sqrtGuarded(W_[461],"RHC.dp_nominal");
}
helpvar[20] = divmacro(2.31,"2.31",helpvar[19],"sqrt(RHC.dp_nominal)");
helpvar[21] = divmacro(1,"1",helpvar[19],"sqrt(RHC.dp_nominal)");
helpvar[22] = 2.31*DP_[119];
helpvar[23] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(RHC.dp, 2.31/sqrt(RHC.dp_nominal), 2.31*RHC.deltaM, RHC.linearizeFlowResistance)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[454], 
  helpvar[20], helpvar[22], DP_[118]));
PopModelContext();
helpvar[24] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(Duct.dp, 0.231, 0.693, false)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[804], 0.231, 
  0.693, false));
PopModelContext();
if (NewParameters) {
helpvar[25] = sqrtGuarded(W_[862],"HC.dp1_nominal");
}
helpvar[26] = divmacro(W_[838],"HC.m1_flow_nominal",helpvar[25],"sqrt(HC.dp1_nominal)");
helpvar[27] = divmacro(1,"1",helpvar[25],"sqrt(HC.dp1_nominal)");
helpvar[28] = DP_[268]*W_[838];
helpvar[29] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(HC.dp1, HC.m1_flow_nominal/sqrt(HC.dp1_nominal), HC.deltaM1*HC.m1_flow_nominal, HC.linearizeFlowResistance1)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[847], 
  helpvar[26], helpvar[28], DP_[267]));
PopModelContext();
if (NewParameters) {
helpvar[30] = sqrtGuarded(W_[908],"CC.dp1_nominal");
}
helpvar[31] = divmacro(2.31,"2.31",helpvar[30],"sqrt(CC.dp1_nominal)");
helpvar[32] = divmacro(1,"1",helpvar[30],"sqrt(CC.dp1_nominal)");
helpvar[33] = 2.31*DP_[276];
helpvar[34] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(CC.dp1, 2.31/sqrt(CC.dp1_nominal), 2.31*CC.deltaM1, CC.linearizeFlowResistance1)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[893], 
  helpvar[31], helpvar[33], DP_[275]));
PopModelContext();
SetVector(residue__, 1, W_[109]-helpvar[13]*helpvar[17]);
SetVector(residue__, 2, W_[803]-helpvar[18]);
SetVector(residue__, 3, W_[803]-helpvar[23]);
SetVector(residue__, 4, W_[803]-helpvar[24]);
SetVector(residue__, 5, W_[803]-helpvar[29]);
SetVector(residue__, 6, W_[803]-helpvar[34]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
helpvar[35] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(VAV.dp, VAV.k, VAV.m_flow_turbulent, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[33], 
  W_[43], W_[44], false, 1, 0, 0));
PopModelContext();
helpvar[36] = helpvar[13]*(PushModelContext(1,"SupF.flowCharacteristic_Unique'\"1FD32A48\"':derf(1500*SupF.V_flow_single/SupF.N, {1.888, 2.36, 2.832}, {540.6, 460.8, 386.1}, 1500/SupF.N, {0, 0, 0}, {0, 0, 0})")
  SupF_flowCharacteristicx_0Uniquez_0ccdbegeedddcebdedicc__derf(helpvar[15], 
  RealTemporaryDense( DymArrays2, 1, 3), RealTemporaryDense( DymArrays3, 1, 3), 
  helpvar[16]*1500, RealTemporaryDense( DymArrays4, 1, 3), RealTemporaryDense( 
  DymArrays4, 1, 3)));
PopAllMarks();
helpvar[37] = helpvar[9]*helpvar[35]*helpvar[36];
helpvar[38] = sqr(W_[85]);
helpvar[39] = divmacro(1.18430792005922E-005*W_[803]*helpvar[36],
  "1.18430792005922E-005*Duct.m_flow*(0.000666666666666667*SupF.N)^2*SupF.flowCharacteristic_Unique'\"1FD32A48\"':derf(1500*SupF.V_flow_single/SupF.N, {1.888, 2.36, 2.832}, {540.6, 460.8, 386.1}, 1500/SupF.N, {0, 0, 0}, {0, 0, 0})",
  helpvar[38],"SupF.medium.d^2");
helpvar[40] = divmacro(1,"1",helpvar[38],"SupF.medium.d^2");
helpvar[41] = W_[61]*W_[61];
helpvar[42] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(VAV.dp, VAV.k, VAV.m_flow_turbulent, false, 0, 1, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[33], 
  W_[43], W_[44], false, 0, 1, 0));
PopModelContext();
helpvar[43] = helpvar[42]*helpvar[36];
helpvar[44] = IF DP_[42] THEN 0 ELSE 1.18430792005922E-005;
helpvar[45] = divmacro(1,"1",W_[43],"sqrt(1/(1/VAV.kResSqu+1/VAV.kDamSqu))");
helpvar[46] = sqr(W_[50]);
helpvar[47] = divmacro(1,"1",helpvar[46],"VAV.kDamSqu^2");
helpvar[48] = sqr(helpvar[7]);
helpvar[49] = divmacro(helpvar[47]*helpvar[45]*helpvar[4]*helpvar[41]*helpvar[43]
  *helpvar[44],"VAV.area*VAV.area*Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(VAV.dp, VAV.k, VAV.m_flow_turbulent, false, 0, 1, 0)*(0.000666666666666667*SupF.N)^2*SupF.flowCharacteristic_Unique'\"1FD32A48\"':derf(1500*SupF.V_flow_single/SupF.N, {1.888, 2.36, 2.832}, {540.6, 460.8, 386.1}, 1500/SupF.N, {0, 0, 0}, {0, 0, 0})*(if VAV.use_constant_density then 0 else 1.18430792005922E-005)/VAV.k...",
  helpvar[48],"(1/VAV.kResSqu+1/VAV.kDamSqu)^2");
helpvar[50] = divmacro(1,"1",helpvar[48],"(1/VAV.kResSqu+1/VAV.kDamSqu)^2");
helpvar[51] = sqr(W_[113]);
helpvar[52] = divmacro(1,"1",helpvar[51],"SupF.N^2");
helpvar[53] = W_[540]*(IF helpvar[11] THEN 0 ELSE IF LessS(W_[546],
  "FanC.limiter.u", W_[544],"FanC.limiter.uMin", 3) THEN 0 ELSE 1)*(IF helpvar[12]
   > 0.001 THEN 1500 ELSE 0)*(8.88888888888889E-007*helpvar[17]*W_[113]+helpvar[13]
  *(PushModelContext(1,"SupF.flowCharacteristic_Unique'\"1FD32A48\"':derf(1500*SupF.V_flow_single/SupF.N, {1.888, 2.36, 2.832}, {540.6, 460.8, 386.1},  -1500*SupF.V_flow_single/SupF.N^2, {0, 0, 0}, {0, 0, 0})")
  SupF_flowCharacteristicx_0Uniquez_0ccdbegeedddcebdedicc__derf(helpvar[15], 
  RealTemporaryDense( DymArrays2, 1, 3), RealTemporaryDense( DymArrays3, 1, 3), 
   -helpvar[52]*helpvar[14], RealTemporaryDense( DymArrays4, 1, 3), 
  RealTemporaryDense( DymArrays4, 1, 3))));
PopAllMarks();
helpvar[54] =  -helpvar[35];
helpvar[55] = helpvar[41]*helpvar[42]*helpvar[44];
helpvar[56] = helpvar[35]+helpvar[50]*helpvar[47]*helpvar[45]*helpvar[4]*
  helpvar[55];
helpvar[57] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(RHC.dp, 2.31/sqrt(RHC.dp_nominal), 2.31*RHC.deltaM, RHC.linearizeFlowResistance, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[454], 
  helpvar[20], helpvar[22], DP_[118], 1, 0, 0));
PopModelContext();
helpvar[58] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(HC.dp1, HC.m1_flow_nominal/sqrt(HC.dp1_nominal), HC.deltaM1*HC.m1_flow_nominal, HC.linearizeFlowResistance1, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[847], 
  helpvar[26], helpvar[28], DP_[267], 1, 0, 0));
PopModelContext();
helpvar[59] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(CC.dp1, 2.31/sqrt(CC.dp1_nominal), 2.31*CC.deltaM1, CC.linearizeFlowResistance1, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[893], 
  helpvar[31], helpvar[33], DP_[275], 1, 0, 0));
PopModelContext();
SetMatrixLeading(Jacobian__, 1, 2, 6, helpvar[10]*helpvar[37]);
SetMatrixLeading(Jacobian__, 1, 3, 6, -1);
SetMatrixLeading(Jacobian__, 1, 6, 6, 1+helpvar[10]*(helpvar[39]-helpvar[37]-
  helpvar[9]*helpvar[49])-DP_[206]*DP_[207]*helpvar[53]*DP_[205]);
SetMatrixLeading(Jacobian__, 2, 2, 6, helpvar[54]);
SetMatrixLeading(Jacobian__, 2, 5, 6, (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(filter.dp, 0.231, 0.693, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[423], 
  0.231, 0.693, false, 1, 0, 0)));
PopModelContext();
SetMatrixLeading(Jacobian__, 2, 6, 6, helpvar[56]);
SetMatrixLeading(Jacobian__, 3, 1, 6, helpvar[57]);
SetMatrixLeading(Jacobian__, 3, 2, 6,  -(helpvar[35]+helpvar[57]));
SetMatrixLeading(Jacobian__, 3, 6, 6, helpvar[56]);
SetMatrixLeading(Jacobian__, 4, 1, 6,  -(PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Duct.dp, 0.231, 0.693, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[804], 
  0.231, 0.693, false, 1, 0, 0)));
PopModelContext();
SetMatrixLeading(Jacobian__, 4, 2, 6, helpvar[54]);
SetMatrixLeading(Jacobian__, 4, 6, 6, helpvar[56]);
SetMatrixLeading(Jacobian__, 5, 2, 6, helpvar[54]);
SetMatrixLeading(Jacobian__, 5, 4, 6, helpvar[58]);
SetMatrixLeading(Jacobian__, 5, 5, 6,  -helpvar[58]);
SetMatrixLeading(Jacobian__, 5, 6, 6, helpvar[56]);
SetMatrixLeading(Jacobian__, 6, 2, 6, helpvar[54]);
SetMatrixLeading(Jacobian__, 6, 3, 6, helpvar[59]);
SetMatrixLeading(Jacobian__, 6, 4, 6,  -helpvar[59]);
SetMatrixLeading(Jacobian__, 6, 6, 6, helpvar[56]);

SolveNonLinearSystemOfEquations(Jacobian__, residue__, x__);
W_[447] = GetVector(x__, 1);
W_[445] = GetVector(x__, 2);
W_[66] = GetVector(x__, 3);
W_[832] = GetVector(x__, 4);
W_[830] = GetVector(x__, 5);
W_[83] = GetVector(x__, 6);
EndNonLinearSystemOfEquations(residue__, x__);
 /* End of Non-Linear Equation Block */ }



BreakSectionFunction(14);
W_[114] = 1.25*W_[109]*W_[112];
W_[99] =  -W_[114]*DP_[49];
 /* Linear system of equations to solve. */
W_[644] = RememberSimple_(W_[644], 9);
SolveScalarLinear( -X_[1]," -del.m",  -X_[0]," -del.U", W_[644],"del.medium.u");
 /* End of Equation Block */ 

BreakSectionFunction(15);
 /* Linear system of equations to solve. */
W_[642] = (-0.00139198455611864)*(-299774.9175-W_[644]);

W_[640] = 1005.45*(W_[642]-298.15);
 /* End of Equation Block */ 

BreakSectionFunction(16);
helpvar[60] = fabs(W_[803]);
helpvar[61] = 0.75*W_[840];
helpvar[62] = 0.25*W_[840];
helpvar[63] = helpvar[60]-helpvar[61];
W_[874] = IF helpvar[63] > helpvar[62] THEN 1 ELSE IF helpvar[63] < (-0.25)*
  W_[840] THEN 0 ELSE IF fabs(helpvar[62]) > 0 THEN 0.5+divmacro((-0.25)*(
  helpvar[60]-helpvar[61])*(sqr(divmacro(helpvar[60]-helpvar[61],
  "abs(Duct.m_flow)-0.75*HC.m1_flow_small",helpvar[62],"0.25*HC.m1_flow_small"))
  -3),"(-0.25)*(abs(Duct.m_flow)-0.75*HC.m1_flow_small)*(((abs(Duct.m_flow)-0.75*HC.m1_flow_small)/(0.25*HC.m1_flow_small))^2-3)",
  helpvar[62],"0.25*HC.m1_flow_small") ELSE 0.5;
W_[870] = 1005.45*W_[874]*helpvar[60];
W_[855] = 298.15+0.000994579541498831*W_[640];
helpvar[64] = helpvar[60]-0.00017325;
W_[920] = IF helpvar[64] > 5.775E-005 THEN 1 ELSE IF helpvar[64] < -5.775E-005
   THEN 0 ELSE 0.5-4329.00432900433*(helpvar[60]-0.00017325)*(sqr(
  17316.0173160173*(helpvar[60]-0.00017325))-3);
W_[916] = 1005.45*W_[920]*helpvar[60];
BreakSectionFunction(17);
{ /* Non-linear system of equations to solve. */
/* Introducing 118 common subexpressions and reusing 3 variables totally
   used in 54 expressions */
/* Of the common subexpressions 100 are reals, 8 are integers, and 13
   are booleans. */
const char*const varnames_[]={"CC.state_a1_inflow.T", "HC.state_b1_inflow.T", 
  "CC.port_b1.h_outflow", "SupF.medium.h"};
const double nominal_[]={300.0, 300.0, 1000000.0, 1000000.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 4, 0, 2, 17);
SetInitVector(x__, 1, W_[901], Remember_(W_[901], 10));
SetInitVector(x__, 2, W_[856], Remember_(W_[856], 11));
SetInitVector(x__, 3, W_[879], Remember_(W_[879], 12));
SetInitVector(x__, 4, W_[84], Remember_(W_[84], 13));
Residues;
  W_[934] = 298.15+0.000994579541498831*W_[84];
  W_[902] = W_[934];
  helpvar[65] = W_[803] > 0.000231;
  W_[914] = IF helpvar[65] THEN W_[901] ELSE IF W_[803] < -0.000231 THEN W_[902]
     ELSE 1082.25108225108*W_[803]*(sqr(4329.00432900433*W_[803])-3)*(W_[902]-
    W_[901])+0.5*(W_[901]+W_[902]);
  W_[490] = W_[491]*W_[936]+DP_[150]*W_[934];
  W_[494] = DP_[151]*W_[490];
  W_[493] = DP_[152]*W_[494]+DP_[153]*DP_[155]+DP_[154]*X_[8];
  W_[498] = W_[492]*W_[493];
  helpvar[66] = GreaterS(W_[498],"CCC.limiter.u", W_[495],"CCC.limiter.uMax", 4);
  W_[499] = IF helpvar[66] THEN W_[495] ELSE IF LessS(W_[498],"CCC.limiter.u", 
    W_[496],"CCC.limiter.uMin", 5) THEN W_[496] ELSE W_[498];
  W_[894] = (-2.31)*W_[499];
  helpvar[67] = W_[894] > W_[887];
  W_[915] = IF helpvar[67] THEN W_[903] ELSE IF W_[894] <  -W_[887] THEN 293.15
     ELSE IF fabs(W_[887]) > 0 THEN 146.575+divmacro(0.25*W_[894]*(sqr(divmacro(
    W_[894],"CC.m2_flow",W_[887],"CC.m2_flow_small"))-3)*(293.15-W_[903]),
    "0.25*CC.m2_flow*((CC.m2_flow/CC.m2_flow_small)^2-3)*(293.15-CC.state_a2_inflow.T)",
    W_[887],"CC.m2_flow_small")+0.5*W_[903] ELSE 146.575+0.5*W_[903];
  helpvar[68] = fabs(W_[894]);
  helpvar[69] = 0.25*W_[887];
  helpvar[70] = helpvar[68]-0.75*W_[887];
  helpvar[71] = helpvar[70] > helpvar[69];
  W_[921] = IF helpvar[71] THEN 1 ELSE IF helpvar[70] < (-0.25)*W_[887] THEN 0
     ELSE IF fabs(helpvar[69]) > 0 THEN 0.5+divmacro((-0.25)*(helpvar[68]-0.75*
    W_[887])*(sqr(divmacro(helpvar[68]-0.75*W_[887],"abs(CC.m2_flow)-0.75*CC.m2_flow_small",
    helpvar[69],"0.25*CC.m2_flow_small"))-3),"(-0.25)*(abs(CC.m2_flow)-0.75*CC.m2_flow_small)*(((abs(CC.m2_flow)-0.75*CC.m2_flow_small)/(0.25*CC.m2_flow_small))^2-3)",
    helpvar[69],"0.25*CC.m2_flow_small") ELSE 0.5;
  W_[917] = 4184*W_[921]*helpvar[68];
  W_[918] = RealBmin(W_[916], W_[917]);
  helpvar[72] = W_[915]-W_[914];
  W_[919] = W_[918]*helpvar[72];
  W_[912] = W_[913]*W_[919];
  Aux_[12] = (-1005.45)*(298.15-W_[856]);
  helpvar[73] = W_[803] > W_[840];
  W_[868] = IF helpvar[73] THEN W_[855] ELSE IF W_[803] <  -W_[840] THEN W_[856]
     ELSE IF fabs(W_[840]) > 0 THEN divmacro(0.25*W_[803]*(sqr(divmacro(W_[803],
    "Duct.m_flow",W_[840],"HC.m1_flow_small"))-3)*(W_[856]-W_[855]),
    "0.25*Duct.m_flow*((Duct.m_flow/HC.m1_flow_small)^2-3)*(HC.state_b1_inflow.T-HC.state_a1_inflow.T)",
    W_[840],"HC.m1_flow_small")+0.5*(W_[855]+W_[856]) ELSE 0.5*(W_[855]+W_[856]);
  Aux_[13] = (-1005.45)*(298.15-W_[901]);
  W_[506] = 298.15+0.000994579541498831*Aux_[13];
  W_[507] = W_[508]*DP_[281]+DP_[169]*W_[506];
  W_[511] = DP_[170]*W_[507];
  W_[510] = DP_[171]*W_[511]+DP_[172]*DP_[174]+DP_[173]*X_[9];
  W_[515] = W_[509]*W_[510];
  helpvar[74] = GreaterS(W_[515],"HCC.limiter.u", W_[512],"HCC.limiter.uMax", 6);
  W_[516] = IF helpvar[74] THEN W_[512] ELSE IF LessS(W_[515],"HCC.limiter.u", 
    W_[513],"HCC.limiter.uMin", 7) THEN W_[513] ELSE W_[515];
  W_[848] = W_[553]*W_[516];
  helpvar[75] = W_[848] > W_[841];
  W_[869] = IF helpvar[75] THEN 355.35 ELSE IF W_[848] <  -W_[841] THEN 293.15
     ELSE IF fabs(W_[841]) > 0 THEN 324.25+divmacro((-15.55)*W_[848]*(sqr(
    divmacro(W_[848],"HC.m2_flow",W_[841],"HC.m2_flow_small"))-3),
    "(-15.55)*HC.m2_flow*((HC.m2_flow/HC.m2_flow_small)^2-3)",W_[841],
    "HC.m2_flow_small") ELSE 324.25;
  helpvar[76] = fabs(W_[848]);
  helpvar[77] = 0.25*W_[841];
  helpvar[78] = helpvar[76]-0.75*W_[841];
  helpvar[79] = helpvar[78] > helpvar[77];
  W_[875] = IF helpvar[79] THEN 1 ELSE IF helpvar[78] < (-0.25)*W_[841] THEN 0
     ELSE IF fabs(helpvar[77]) > 0 THEN 0.5+divmacro((-0.25)*(helpvar[76]-0.75*
    W_[841])*(sqr(divmacro(helpvar[76]-0.75*W_[841],"abs(HC.m2_flow)-0.75*HC.m2_flow_small",
    helpvar[77],"0.25*HC.m2_flow_small"))-3),"(-0.25)*(abs(HC.m2_flow)-0.75*HC.m2_flow_small)*(((abs(HC.m2_flow)-0.75*HC.m2_flow_small)/(0.25*HC.m2_flow_small))^2-3)",
    helpvar[77],"0.25*HC.m2_flow_small") ELSE 0.5;
  W_[871] = 4184*W_[875]*helpvar[76];
  W_[872] = RealBmin(W_[870], W_[871]);
  helpvar[80] = W_[869]-W_[868];
  W_[873] = W_[872]*helpvar[80];
  W_[866] = W_[867]*W_[873];
helpvar[81] = W_[803] > 0;
helpvar[82] = W_[803]*W_[84];
helpvar[83] = W_[803]*Aux_[13];
SetVector(residue__, 1, W_[99]-(W_[803]*(IF helpvar[81] THEN W_[879] ELSE W_[84])
  + -helpvar[82]));
SetVector(residue__, 2, helpvar[83]-W_[803]*W_[640]-W_[866]);
SetVector(residue__, 3, W_[803]*Aux_[12]-helpvar[82]+W_[912]);
SetVector(residue__, 4, W_[803]*W_[879]-helpvar[83]-W_[912]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
helpvar[84] = IF W_[848] > 0 THEN 1 ELSE -1;
helpvar[85] = (IF W_[870] < W_[871] THEN 0 ELSE 1)*helpvar[80]*W_[867];
helpvar[86] = (-4184)*(IF helpvar[79] THEN 0 ELSE IF helpvar[78] < (-0.25)*
  W_[841] THEN 0 ELSE IF fabs(helpvar[77]) > 0 THEN divmacro((-0.25)*((sqr(
  divmacro(helpvar[76]-0.75*W_[841],"abs(HC.m2_flow)-0.75*HC.m2_flow_small",
  helpvar[77],"0.25*HC.m2_flow_small"))-3)*helpvar[84]+divmacro(divmacro(2*(
  helpvar[76]-0.75*W_[841])*(helpvar[76]-0.75*W_[841])*helpvar[84],
  "2*(abs(HC.m2_flow)-0.75*HC.m2_flow_small)*(abs(HC.m2_flow)-0.75*HC.m2_flow_small)*noEvent((if HC.m2_flow > 0 then 1 else -1))",
  helpvar[77],"0.25*HC.m2_flow_small"),"2*(abs(HC.m2_flow)-0.75*HC.m2_flow_small)*(abs(HC.m2_flow)-0.75*HC.m2_flow_small)*noEvent((if HC.m2_flow > 0 then 1 else -1))/(0.25*HC.m2_flow_small)",
  helpvar[77],"0.25*HC.m2_flow_small")),"(-0.25)*((((abs(HC.m2_flow)-0.75*HC.m2_flow_small)/(0.25*HC.m2_flow_small))^2-3)*noEvent((if HC.m2_flow > 0 then 1 else -1))+2*(abs(HC.m2_flow)-0.75*HC.m2_flow_small)*(abs(HC.m2_flow)-0.75*HC.m2_flow_small)*noEvent((if HC.m2_flow > 0 then 1 else -1))/(0.25*HC.m2_flow_small)/(0.25*HC.m2_flow_small))",
  helpvar[77],"0.25*HC.m2_flow_small") ELSE 0)*helpvar[76]*helpvar[85];
helpvar[87] = W_[872]*W_[867];
helpvar[88] = (IF helpvar[75] THEN 0 ELSE IF W_[848] <  -W_[841] THEN 0 ELSE IF 
  fabs(W_[841]) > 0 THEN divmacro((-15.55)*(sqr(divmacro(W_[848],"HC.m2_flow",
  W_[841],"HC.m2_flow_small"))+divmacro(divmacro(2*W_[848]*W_[848],
  "2*HC.m2_flow*HC.m2_flow",W_[841],"HC.m2_flow_small"),"2*HC.m2_flow*HC.m2_flow/HC.m2_flow_small",
  W_[841],"HC.m2_flow_small")-3),"(-15.55)*((HC.m2_flow/HC.m2_flow_small)^2+2*HC.m2_flow*HC.m2_flow/HC.m2_flow_small/HC.m2_flow_small-3)",
  W_[841],"HC.m2_flow_small") ELSE 0)*helpvar[87];
helpvar[89] = W_[875]*helpvar[84]*helpvar[85];
helpvar[90] = DP_[171]*W_[509]*(IF helpvar[74] THEN 0 ELSE IF LessS(W_[515],
  "HCC.limiter.u", W_[513],"HCC.limiter.uMin", 7) THEN 0 ELSE 1)*W_[553]*(
  helpvar[86]-helpvar[88]-4184*helpvar[89]);
helpvar[91] = W_[918]*W_[913];
helpvar[92] = helpvar[91]*(IF helpvar[65] THEN 1 ELSE IF W_[803] < -0.000231
   THEN 0 ELSE 0.5-1082.25108225108*W_[803]*(sqr(4329.00432900433*W_[803])-3));
helpvar[93] = 1005.45*W_[803];
helpvar[94] = IF helpvar[66] THEN 0 ELSE IF LessS(W_[498],"CCC.limiter.u", 
  W_[496],"CCC.limiter.uMin", 5) THEN 0 ELSE 1;
helpvar[95] = (IF helpvar[67] THEN 0 ELSE IF W_[894] <  -W_[887] THEN 0 ELSE IF 
  fabs(W_[887]) > 0 THEN divmacro(0.25*(293.15-W_[903])*(sqr(divmacro(W_[894],
  "CC.m2_flow",W_[887],"CC.m2_flow_small"))+divmacro(divmacro(2*W_[894]*W_[894],
  "2*CC.m2_flow*CC.m2_flow",W_[887],"CC.m2_flow_small"),"2*CC.m2_flow*CC.m2_flow/CC.m2_flow_small",
  W_[887],"CC.m2_flow_small")-3),"0.25*(293.15-CC.state_a2_inflow.T)*((CC.m2_flow/CC.m2_flow_small)^2+2*CC.m2_flow*CC.m2_flow/CC.m2_flow_small/CC.m2_flow_small-3)",
  W_[887],"CC.m2_flow_small") ELSE 0)*helpvar[91];
helpvar[96] = IF W_[894] > 0 THEN 1 ELSE -1;
helpvar[97] = (IF W_[916] < W_[917] THEN 0 ELSE 1)*helpvar[72]*W_[913];
helpvar[98] = (IF helpvar[71] THEN 0 ELSE IF helpvar[70] < (-0.25)*W_[887] THEN 0
   ELSE IF fabs(helpvar[69]) > 0 THEN divmacro((-0.25)*((sqr(divmacro(helpvar[68]
  -0.75*W_[887],"abs(CC.m2_flow)-0.75*CC.m2_flow_small",helpvar[69],
  "0.25*CC.m2_flow_small"))-3)*helpvar[96]+divmacro(divmacro(2*(helpvar[68]-0.75
  *W_[887])*(helpvar[68]-0.75*W_[887])*helpvar[96],"2*(abs(CC.m2_flow)-0.75*CC.m2_flow_small)*(abs(CC.m2_flow)-0.75*CC.m2_flow_small)*noEvent((if CC.m2_flow > 0 then 1 else -1))",
  helpvar[69],"0.25*CC.m2_flow_small"),"2*(abs(CC.m2_flow)-0.75*CC.m2_flow_small)*(abs(CC.m2_flow)-0.75*CC.m2_flow_small)*noEvent((if CC.m2_flow > 0 then 1 else -1))/(0.25*CC.m2_flow_small)",
  helpvar[69],"0.25*CC.m2_flow_small")),"(-0.25)*((((abs(CC.m2_flow)-0.75*CC.m2_flow_small)/(0.25*CC.m2_flow_small))^2-3)*noEvent((if CC.m2_flow > 0 then 1 else -1))+2*(abs(CC.m2_flow)-0.75*CC.m2_flow_small)*(abs(CC.m2_flow)-0.75*CC.m2_flow_small)*noEvent((if CC.m2_flow > 0 then 1 else -1))/(0.25*CC.m2_flow_small)/(0.25*CC.m2_flow_small))",
  helpvar[69],"0.25*CC.m2_flow_small") ELSE 0)*helpvar[68]*helpvar[97];
helpvar[99] = W_[921]*helpvar[96];
helpvar[100] = 4184*helpvar[99]*helpvar[97];
helpvar[101] = DP_[152]*W_[492]*helpvar[94]*(helpvar[95]+4184*helpvar[98]+
  helpvar[100]);
helpvar[102] = 0.000994579541498831*(IF helpvar[65] THEN 0 ELSE IF W_[803] < 
  -0.000231 THEN 1 ELSE 0.5+1082.25108225108*W_[803]*(sqr(4329.00432900433*
  W_[803])-3))*helpvar[91];
helpvar[103] = W_[492]*helpvar[94]*((-4184)*helpvar[98]-helpvar[95]-helpvar[100]);
SetMatrixLeading(Jacobian__, 1, 3, 4,  -W_[803]*(IF helpvar[81] THEN 1 ELSE 0));
SetMatrixLeading(Jacobian__, 1, 4, 4,  -(W_[803]*(IF helpvar[81] THEN 0 ELSE 1)+
   -W_[803]));
SetMatrixLeading(Jacobian__, 2, 1, 4, 1005.45*(W_[803]+0.000994579541498831*
  DP_[169]*DP_[170]*helpvar[90]));
SetMatrixLeading(Jacobian__, 2, 2, 4, helpvar[87]*(IF helpvar[73] THEN 0 ELSE 
  IF W_[803] <  -W_[840] THEN 1 ELSE IF fabs(W_[840]) > 0 THEN 0.5+divmacro(0.25
  *W_[803]*(sqr(divmacro(W_[803],"Duct.m_flow",W_[840],"HC.m1_flow_small"))-3),
  "0.25*Duct.m_flow*((Duct.m_flow/HC.m1_flow_small)^2-3)",W_[840],
  "HC.m1_flow_small") ELSE 0.5));
SetMatrixLeading(Jacobian__, 3, 1, 4,  -helpvar[92]);
SetMatrixLeading(Jacobian__, 3, 2, 4, helpvar[93]);
SetMatrixLeading(Jacobian__, 3, 4, 4, (-0.0022974787408623)*DP_[150]*DP_[151]*
  helpvar[101]-helpvar[102]-W_[803]);
SetMatrixLeading(Jacobian__, 4, 1, 4, helpvar[92]-helpvar[93]);
SetMatrixLeading(Jacobian__, 4, 3, 4, W_[803]);
SetMatrixLeading(Jacobian__, 4, 4, 4, helpvar[102]-0.0022974787408623*DP_[150]*
  DP_[151]*DP_[152]*helpvar[103]);

SolveNonLinearSystemOfEquations(Jacobian__, residue__, x__);
W_[901] = GetVector(x__, 1);
W_[856] = GetVector(x__, 2);
W_[879] = GetVector(x__, 3);
W_[84] = GetVector(x__, 4);
EndNonLinearSystemOfEquations(residue__, x__);
 /* End of Non-Linear Equation Block */ }



BreakSectionFunction(18);
W_[971] = DP_[302]*W_[499]+DP_[303]*W_[498];
W_[972] = W_[970]*W_[971];
W_[969] = DP_[299]*W_[936]+DP_[300]*W_[934]+DP_[301]*W_[972];
F_[8] = W_[966]*W_[969];
W_[978] = DP_[307]*W_[516]+DP_[308]*W_[515];
W_[979] = W_[977]*W_[978];
W_[976] = DP_[304]*DP_[281]+DP_[305]*W_[506]+DP_[306]*W_[979];
F_[9] = W_[973]*W_[976];
W_[992] = DP_[317]*W_[547]+DP_[318]*W_[546];
W_[993] = W_[991]*W_[992];
W_[990] = DP_[314]*DP_[211]+DP_[315]*W_[83]+DP_[316]*W_[993];
F_[11] = W_[987]*W_[990];
W_[957] = DP_[292]*W_[21]+DP_[293]*W_[20];
W_[958] = W_[956]*W_[957];
W_[955] = DP_[289]*W_[935]+DP_[290]*W_[933]+DP_[291]*W_[958];
F_[6] = W_[952]*W_[955];
F_[5] = IF DP_[286] > 0 THEN W_[934] ELSE 0;
F_[4] = IF DP_[285] > 0 THEN W_[933] ELSE 0;
W_[471] = 298.15+0.000994579541498831*W_[640];
W_[472] = W_[473]*DP_[279]+DP_[132]*W_[471];
W_[476] = DP_[133]*W_[472];
W_[475] = DP_[134]*W_[476]+DP_[135]*DP_[137]+DP_[136]*X_[7];
W_[480] = W_[474]*W_[475];
W_[481] = IF GreaterS(W_[480],"EcoC.limiter.u", W_[477],"EcoC.limiter.uMax", 8)
   THEN W_[477] ELSE IF LessS(W_[480],"EcoC.limiter.u", W_[478],"EcoC.limiter.uMin",
   9) THEN W_[478] ELSE W_[480];
W_[964] = DP_[297]*W_[481]+DP_[298]*W_[480];
W_[965] = W_[963]*W_[964];
W_[962] = DP_[294]*DP_[279]+DP_[295]*W_[471]+DP_[296]*W_[965];
F_[7] = W_[959]*W_[962];
W_[216] = DP_[282]*W_[481];
W_[178] = (PushModelContext(1,"Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(Econ.damExh.y, Econ.damOA.a, Econ.damOA.b, Econ.damOA.cL, Econ.damOA.cU, Econ.damOA.yL, Econ.damOA.yU)")
  Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(W_[216], DP_[62], 
  DP_[63], RealTemporaryDense( &W_[179], 1, 3), RealTemporaryDense( &W_[182], 1,
   3), DP_[64], DP_[65]));
PopAllMarks();
BreakSectionFunction(19);
{ /* Non-linear system of equations to solve. */
/* Introducing 14 common subexpressions and reusing 2 variables totally used in 5
   expressions */
/* Of the common subexpressions 16 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"Econ.damOA.dp"};
const double nominal_[]={10.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 3, 21);
SetInitVector(x__, 1, W_[156], Remember_(W_[156], 14));
Residues;
  W_[160] = W_[156]+W_[639];
  W_[176] = IF DP_[68] THEN 1.2 ELSE 1.18430792005922E-005*W_[160];
  helpvar[104] = divmacro(1,"1",W_[178],"Econ.damOA.kTheta");
  W_[175] = helpvar[104]*2*W_[176]*W_[186]*W_[186];
  W_[167] = sqrtGuarded(W_[175],"Econ.damOA.kDamSqu");
  W_[292] = 101325-W_[160];
  W_[376] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(Econ.damOA.dp, Econ.damOA.k, Econ.damOA.m_flow_turbulent, false)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[156], 
    W_[167], W_[168], false));
  PopModelContext();
helpvar[105] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(Econ.preDroOut.dp, 0.356440738412432, 0.693, false)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[292], 
  0.356440738412432, 0.693, false));
PopModelContext();
SetVector(residue__, 1, W_[376]-helpvar[105]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
helpvar[106] = W_[186]*W_[186]*(PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Econ.damOA.dp, Econ.damOA.k, Econ.damOA.m_flow_turbulent, false, 0, 1, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[156], 
  W_[167], W_[168], false, 0, 1, 0));
PopModelContext();
helpvar[107] = divmacro(1,"1",W_[167],"sqrt(Econ.damOA.kDamSqu)");
SetMatrixLeading(Jacobian__, 1, 1, 1, helpvar[107]*helpvar[104]*(IF DP_[68]
   THEN 0 ELSE 1.18430792005922E-005)*helpvar[106]+(PushModelContext(1,
  "Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Econ.preDroOut.dp, 0.356440738412432, 0.693, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[292], 
  0.356440738412432, 0.693, false, 1, 0, 0))+(PushModelContext(1,
  "Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Econ.damOA.dp, Econ.damOA.k, Econ.damOA.m_flow_turbulent, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[156], 
  W_[167], W_[168], false, 1, 0, 0)));
PopModelContext();

SolveNonLinearSystemOfEquations(Jacobian__, residue__, x__);
W_[156] = GetVector(x__, 1);
EndNonLinearSystemOfEquations(residue__, x__);
 /* End of Non-Linear Equation Block */ }



BreakSectionFunction(20);
W_[260] = DP_[111]*DP_[110]+DP_[112]*W_[216];
W_[265] = (PushModelContext(1,"Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(Econ.damRec.y, Econ.damRec.a, Econ.damRec.b, Econ.damRec.cL, Econ.damRec.cU, Econ.damRec.yL, Econ.damRec.yU)")
  Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(W_[260], DP_[95], 
  DP_[96], RealTemporaryDense( &W_[266], 1, 3), RealTemporaryDense( &W_[269], 1,
   3), DP_[97], DP_[98]));
PopAllMarks();
BreakSectionFunction(21);
{ /* Non-linear system of equations to solve. */
/* Introducing 14 common subexpressions and reusing 2 variables totally used in 5
   expressions */
/* Of the common subexpressions 16 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"Econ.damRec.dp"};
const double nominal_[]={10.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 4, 22);
SetInitVector(x__, 1, W_[242], Remember_(W_[242], 15));
Residues;
  W_[246] = W_[242]+W_[639];
  W_[263] = IF DP_[101] THEN 1.2 ELSE 1.18430792005922E-005*W_[246];
  helpvar[108] = divmacro(1,"1",W_[265],"Econ.damRec.kTheta");
  W_[262] = helpvar[108]*2*W_[263]*W_[273]*W_[273];
  W_[253] = sqrtGuarded(W_[262],"Econ.damRec.kDamSqu");
  W_[355] = W_[722]-W_[246];
  W_[241] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(Econ.damRec.dp, Econ.damRec.k, Econ.damRec.m_flow_turbulent, false)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[242], 
    W_[253], W_[254], false));
  PopModelContext();
helpvar[109] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(Econ.preDroRec.dp, 0.356440738412432, 0.693, false)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[355], 
  0.356440738412432, 0.693, false));
PopModelContext();
SetVector(residue__, 1, W_[241]-helpvar[109]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
helpvar[110] = W_[273]*W_[273]*(PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Econ.damRec.dp, Econ.damRec.k, Econ.damRec.m_flow_turbulent, false, 0, 1, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[242], 
  W_[253], W_[254], false, 0, 1, 0));
PopModelContext();
helpvar[111] = divmacro(1,"1",W_[253],"sqrt(Econ.damRec.kDamSqu)");
SetMatrixLeading(Jacobian__, 1, 1, 1, helpvar[111]*helpvar[108]*(IF DP_[101]
   THEN 0 ELSE 1.18430792005922E-005)*helpvar[110]+(PushModelContext(1,
  "Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Econ.preDroRec.dp, 0.356440738412432, 0.693, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[355], 
  0.356440738412432, 0.693, false, 1, 0, 0))+(PushModelContext(1,
  "Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Econ.damRec.dp, Econ.damRec.k, Econ.damRec.m_flow_turbulent, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[242], 
  W_[253], W_[254], false, 1, 0, 0)));
PopModelContext();

SolveNonLinearSystemOfEquations(Jacobian__, residue__, x__);
W_[242] = GetVector(x__, 1);
EndNonLinearSystemOfEquations(residue__, x__);
 /* End of Non-Linear Equation Block */ }



BreakSectionFunction(22);
W_[381] =  -(W_[376]+W_[241]);
helpvar[112] = RealBmax(W_[241], 0);
Aux_[15] = helpvar[112]+W_[376];
Aux_[16] = IF Aux_[15] > 2.31E-010 THEN 1 ELSE IF Aux_[15] > 0 THEN sqr(
  4329004329.00433*Aux_[15])*(3.0-8658008658.00866*Aux_[15]) ELSE 0;
W_[778] = DP_[246]+(IF LessTime(DP_[247], 0) THEN 0 ELSE DP_[243]*sin(
  6.28318530717959*DP_[244]*(Time-DP_[247])+DP_[245]));
W_[148] = 1005.45*(W_[778]-298.15);
helpvar[113] = 1-Aux_[16];
helpvar[114] = Aux_[16]*helpvar[112]+2.31E-010*helpvar[113];
helpvar[115] = helpvar[114]+W_[376];
helpvar[116] = divmacro(1,"1",helpvar[115],"stream_alpha1*max(Econ.damRec.m_flow, 0)+2.31E-010*(1-stream_alpha1)+Econ.port_Out.m_flow");
W_[382] = helpvar[116]*(helpvar[114]*W_[723]+W_[376]*W_[148]);
W_[658] =  -W_[381]*(IF  -W_[381] > 0 THEN W_[382] ELSE W_[640]);
 /* Linear system of equations to solve. */
W_[831] = RememberSimple_(W_[831], 16);
SolveScalarLinear(W_[803],"Duct.m_flow", W_[803]*Aux_[12]-W_[866],
  "Duct.m_flow*HC.port_b1.h_outflow_inStream-HC.Q1_flow", W_[831],
  "HC.port_a1.h_outflow");
 /* End of Equation Block */ 

W_[659] =  -W_[803]*(IF  -W_[803] > 0 THEN W_[831] ELSE W_[640]);
F_[0] = W_[658]+W_[659];
F_[1] =  -(W_[381]+W_[803]);
W_[219] = IF DP_[85] THEN 1.2 ELSE 1.18430792005922E-005*W_[722];
W_[221] = (PushModelContext(1,"Buildings.Fluid.Actuators.BaseClasses.exponentialDamper(Econ.damExh.y, Econ.damExh.a, Econ.damExh.b, Econ.damExh.cL, Econ.damExh.cU, Econ.damExh.yL, Econ.damExh.yU)")
  Buildings_Fluid_Actuators_BaseClasses_exponentialDamper(W_[216], DP_[79], 
  DP_[80], RealTemporaryDense( &W_[222], 1, 3), RealTemporaryDense( &W_[225], 1,
   3), DP_[81], DP_[82]));
PopAllMarks();
W_[218] = divmacro(2*W_[219]*W_[229]*W_[229],"2*Econ.damExh.rho*Econ.damExh.area*Econ.damExh.area",
  W_[221],"Econ.damExh.kTheta");
W_[209] = sqrtGuarded(W_[218],"Econ.damExh.kDamSqu");
BreakSectionFunction(23);
{ /* Non-linear system of equations to solve. */
/* Introducing 6 common subexpressions used in 0 expressions */
/* Of the common subexpressions 6 are reals, 0 are integers, and 0
   are booleans. */
const char*const varnames_[]={"Econ.damExh.dp"};
const double nominal_[]={10.0};
NonLinearSystemOfEquations(Jacobian__, residue__, x__, 1, 0, 5, 23);
SetInitVector(x__, 1, W_[199], Remember_(W_[199], 17));
Residues;
  W_[327] = W_[722]-W_[199];
  W_[323] = W_[327]-101325;
  helpvar[117] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(Econ.damExh.dp, Econ.damExh.k, Econ.damExh.m_flow_turbulent, false)")
    Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[199], 
    W_[209], W_[210], false));
  PopModelContext();
  W_[378] =  -helpvar[117];
helpvar[118] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp(Econ.preDroExh.dp, 0.356440738412432, 0.693, false)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp(W_[323], 
  0.356440738412432, 0.693, false));
PopModelContext();
SetVector(residue__, 1, W_[378]+helpvar[118]);

Jacobian(Jacobian__)
MatrixZeros(Jacobian__);
SetMatrixLeading(Jacobian__, 1, 1, 1,  -((PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Econ.preDroExh.dp, 0.356440738412432, 0.693, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[323], 
  0.356440738412432, 0.693, false, 1, 0, 0))+(PushModelContext(1,
  "Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_dp:derf(Econ.damExh.dp, Econ.damExh.k, Econ.damExh.m_flow_turbulent, false, 1, 0, 0)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0dp__derf(W_[199], 
  W_[209], W_[210], false, 1, 0, 0))));
PopModelContext();

SolveNonLinearSystemOfEquations(Jacobian__, residue__, x__);
W_[199] = GetVector(x__, 1);
EndNonLinearSystemOfEquations(residue__, x__);
 /* End of Non-Linear Equation Block */ }



BreakSectionFunction(24);
W_[380] = W_[241]-W_[378];
F_[3] = W_[803]-W_[380];
W_[741] =  -W_[380]*(IF  -W_[380] > 0 THEN W_[148] ELSE W_[723]);
W_[523] = W_[524]*DP_[280]+DP_[187]*W_[933];
W_[527] = DP_[188]*W_[523];
W_[526] = DP_[189]*W_[527]+DP_[190]*DP_[192]+DP_[191]*X_[10];
W_[531] = W_[525]*W_[526];
W_[464] = IF GreaterS(W_[531],"RHCC.limiter.u", W_[528],"RHCC.limiter.uMax", 10)
   THEN W_[528] ELSE IF LessS(W_[531],"RHCC.limiter.u", W_[529],"RHCC.limiter.uMin",
   11) THEN W_[529] ELSE W_[531];
W_[462] = W_[463]*W_[464];
 /* Linear system of equations to solve. */
W_[448] = RememberSimple_(W_[448], 18);
SolveScalarLinear(W_[803],"Duct.m_flow", W_[803]*W_[84]+W_[462],"Duct.m_flow*SupF.medium.h+RHC.Q_flow",
   W_[448],"RHC.port_b.h_outflow");
 /* End of Equation Block */ 

W_[742] = W_[803]*(IF W_[803] > 0 THEN W_[448] ELSE W_[723]);
W_[734] = W_[741]+W_[742];
W_[780] =  -W_[779]*(1+DP_[227]*(W_[933]-DP_[226]));
W_[774] = W_[933]-W_[778];
W_[775] = W_[776]*W_[774];
W_[735] =  -(W_[780]+W_[775]);
F_[2] = W_[734]+W_[735];
W_[985] = DP_[312]*W_[464]+DP_[313]*W_[531];
W_[986] = W_[984]*W_[985];
W_[983] = DP_[309]*DP_[280]+DP_[310]*W_[933]+DP_[311]*W_[986];
F_[10] = W_[980]*W_[983];
AssertModelica(Greater(W_[803],"Duct.m_flow",  -W_[30]," -VAV.m_flow_small", 12)
   OR W_[24],"Duct.m_flow >  -VAV.m_flow_small or VAV.allowFlowReversal", 
  "Reverting flow occurs even though allowFlowReversal is false");
;
AssertModelica(GreaterEqual(W_[53],"VAV.kTheta", 0,"0", 13),"VAV.kTheta >= 0", 
  "Flow coefficient must not be negative");
;
AssertModelica(GreaterEqual(W_[178],"Econ.damOA.kTheta", 0,"0", 14),
  "Econ.damOA.kTheta >= 0", "Flow coefficient must not be negative");
;
AssertModelica(GreaterEqual(W_[221],"Econ.damExh.kTheta", 0,"0", 15),
  "Econ.damExh.kTheta >= 0", "Flow coefficient must not be negative");
;
AssertModelica(GreaterEqual(W_[265],"Econ.damRec.kTheta", 0,"0", 16),
  "Econ.damRec.kTheta >= 0", "Flow coefficient must not be negative");
;
AssertModelica(Greater(W_[803],"Duct.m_flow",  -W_[420]," -filter.m_flow_small",
   17) OR W_[415],"Duct.m_flow >  -filter.m_flow_small or filter.allowFlowReversal",
   "Reverting flow occurs even though allowFlowReversal is false");
;
AssertModelica(GreaterEqual(W_[639],"del.medium.p", 0,"0", 18),"del.medium.p >= 0",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(W_[639], true, 0))," Pa) of medium \""),"GasesPTDecoupled.SimpleAir"),
  "\" is negative\n(Temperature = "),Real2String2(W_[642], true, 0))," K)"));
;
PopAllMarks();
AssertModelica(GreaterEqual(W_[722],"room.vol.medium.p", 0,"0", 19),
  "room.vol.medium.p >= 0", StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(
  StringAdd("Pressure (= ",Real2String2(W_[722], true, 0))," Pa) of medium \""),
  "GasesPTDecoupled.SimpleAir"),"\" is negative\n(Temperature = "),Real2String2(
  W_[933], true, 0))," K)"));
;
PopAllMarks();
AssertModelica(Greater(W_[803],"Duct.m_flow",  -W_[800]," -Duct.m_flow_small", 20)
   OR W_[795],"Duct.m_flow >  -Duct.m_flow_small or Duct.allowFlowReversal", 
  "Reverting flow occurs even though allowFlowReversal is false");
;

AcceptedSection1
W_[86] = (-0.000994579541498831)*(-299774.9175-W_[84]);

Aux_[35] = W_[848];

if (NewParameters) {
helpvar[119] = sqrtGuarded(W_[865],"HC.dp2_nominal");
}
helpvar[120] = divmacro(1,"1",helpvar[119],"sqrt(HC.dp2_nominal)");
W_[849] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(Nonlin_8., HC.m2_flow_nominal/sqrt(HC.dp2_nominal), HC.deltaM2*HC.m2_flow_nominal, HC.linearizeFlowResistance2)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(Aux_[35], 
  helpvar[120]*W_[839], DP_[270]*W_[839], DP_[269]));
PopModelContext();

W_[834] = 100000+W_[849];

Aux_[36] = W_[894];

if (NewParameters) {
helpvar[121] = sqrtGuarded(W_[911],"CC.dp2_nominal");
}
helpvar[122] = divmacro(1,"1",helpvar[121],"sqrt(CC.dp2_nominal)");
W_[895] = (PushModelContext(1,"Buildings.Fluid.BaseClasses.FlowModels.basicFlowFunction_m_flow(Nonlin_9., CC.m2_flow_nominal/sqrt(CC.dp2_nominal), CC.deltaM2*CC.m2_flow_nominal, CC.linearizeFlowResistance2)")
  Buildings_Fluid_BaseClasses_FlowModels_basicFlowFunctionx_0mx_0flow(Aux_[36], 
  helpvar[122]*W_[885], DP_[278]*W_[885], DP_[277]));
PopModelContext();

W_[880] = 100000+W_[895];

AssertModelica(GreaterEqual(W_[83],"SupF.medium.p", 0,"0", 21),"SupF.medium.p >= 0",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(W_[83], true, 0))," Pa) of medium \""),"GasesPTDecoupled.SimpleAir"),
  "\" is negative\n(Temperature = "),Real2String2(W_[86], true, 0))," K)"));
;
PopAllMarks();
AssertModelica(GreaterEqual(W_[834],"HC.port_a2.p", 0,"0", 22),"HC.port_a2.p >= 0",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(W_[834], true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),"355.35")," K)"));
;
PopAllMarks();
AssertModelica(GreaterEqual(W_[880],"CC.port_a2.p", 0,"0", 23),"CC.port_a2.p >= 0",
   StringAdd(StringAdd(StringAdd(StringAdd(StringAdd(StringAdd("Pressure (= ",
  Real2String2(W_[880], true, 0))," Pa) of medium \""),"SimpleLiquidWater"),
  "\" is negative\n(Temperature = "),Real2String2(W_[627], true, 0))," K)"));
;
PopAllMarks();
AcceptedSection2
Aux_[5] = W_[148];
Aux_[4] = W_[148];
Aux_[10] = W_[148];
Aux_[1] = W_[84];
Aux_[8] = W_[84];
Aux_[14] = Aux_[13];
Aux_[0] = W_[84];
Aux_[11] = W_[448];
Aux_[7] = W_[723];
Aux_[2] = W_[723];
helpvar[123] = RealBmax( -W_[241], 0);
Aux_[17] = W_[380]+helpvar[123];
Aux_[18] = IF Aux_[17] > 2.31E-010 THEN 1 ELSE IF Aux_[17] > 0 THEN sqr(
  4329004329.00433*Aux_[17])*(3.0-8658008658.00866*Aux_[17]) ELSE 0;
helpvar[124] = 1-Aux_[18];
helpvar[125] = Aux_[18]*helpvar[123]+2.31E-010*helpvar[124];
helpvar[126] = W_[380]+helpvar[125];
helpvar[127] = divmacro(1,"1",helpvar[126],"Econ.port_Ret.m_flow+stream_alpha3*max( -Econ.damRec.m_flow, 0)+2.31E-010*(1-stream_alpha3)");
W_[191] = helpvar[127]*(W_[380]*W_[723]+helpvar[125]*W_[148]);
Aux_[3] = W_[191];
Aux_[6] = W_[148];
Aux_[9] = W_[84];
W_[389] = W_[148];
W_[347] = W_[148];
W_[878] = Aux_[12];
W_[833] = Aux_[13];
W_[25] = W_[84];
W_[233] = W_[723];
W_[8] = W_[935]-W_[933];
 /* Linear system of equations to solve. */
W_[446] = RememberSimple_(W_[446], 19);
SolveScalarLinear(W_[803],"Duct.m_flow", W_[803]*W_[723]-W_[462],
  "Duct.m_flow*room.vol.medium.h-RHC.Q_flow", W_[446],"RHC.port_a.h_outflow");
 /* End of Equation Block */ 

W_[34] = divmacro(W_[803],"Duct.m_flow",IF W_[803] > 0.000231 THEN 
  1.18430792005922E-005*W_[83] ELSE IF W_[803] < -0.000231 THEN 1.18430792005922E-005
  *W_[445] ELSE 0.0128171852820261*W_[803]*(sqr(4329.00432900433*W_[803])-3)*(
  W_[445]-W_[83])+5.92153960029608E-006*(W_[83]+W_[445]),"smooth(1, (if noEvent(Duct.m_flow > 0.000231) then 1.18430792005922E-005*SupF.medium.p else (if noEvent(Duct.m_flow < -0.000231) then 1.18430792005922E-005*RHC.port_a.p else 0.0128171852820261*Duct.m_flow*((4329.00432900433*Duct.m_flow)^2-3)*(RHC.port_a.p-SupF.medium.p)+5.92153960029608E-006*(SupF.medium.p+RHC.port_a.p))))");
W_[37] = 298.15+0.000994579541498831*W_[84];
W_[35] = IF W_[803] > 0.000231 THEN W_[37] ELSE IF W_[803] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[446] ELSE 149.075+1082.25108225108*W_[803]*(
  sqr(4329.00432900433*W_[803])-3)*(298.15+0.000994579541498831*W_[446]-W_[37])+
  0.5*(W_[37]+0.000994579541498831*W_[446]);
W_[38] = 298.15+0.000994579541498831*W_[446];
W_[36] = IF  -W_[803] > 0.000231 THEN W_[38] ELSE IF  -W_[803] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[84] ELSE 149.075+0.5*(W_[38]+0.000994579541498831
  *W_[84])-1082.25108225108*W_[803]*(sqr((-4329.00432900433)*W_[803])-3)*(298.15
  +0.000994579541498831*W_[84]-W_[38]);
W_[88] = W_[84]-287.051224952979*W_[86];
W_[94] = W_[86]-273.15;
W_[95] = 1E-005*W_[83];
W_[97] = 0.5*W_[85];
W_[96] = W_[97]*W_[88];
W_[110] = divmacro(W_[803],"Duct.m_flow",DP_[49],"SupF.nParallel");
W_[133] = 1E-005*W_[834];
W_[147] = W_[723];
W_[157] = divmacro(W_[376],"Econ.port_Out.m_flow",IF W_[376] > 0.000231 THEN 
  1.18430792005922E-005*W_[160] ELSE IF W_[376] < -0.000231 THEN 
  1.18430792005922E-005*W_[639] ELSE 0.0128171852820261*W_[376]*(sqr(
  4329.00432900433*W_[376])-3)*(W_[639]-W_[160])+5.92153960029608E-006*(W_[160]+
  W_[639]),"smooth(1, (if noEvent(Econ.port_Out.m_flow > 0.000231) then 1.18430792005922E-005*Econ.damOA.state_a.p else (if noEvent(Econ.port_Out.m_flow < -0.000231) then 1.18430792005922E-005*del.medium.p else 0.0128171852820261*Econ.port_Out.m_flow*((4329.00432900433*Econ.port_Out.m_flow)^2-3)*(del.medium.p-Econ.damOA.state_a.p)+5.92153960029608E-006*(Econ.damOA.state_a.p+del.medium.p))))");
W_[161] = 298.15+0.000994579541498831*W_[148];
W_[158] = IF W_[376] > 0.000231 THEN W_[161] ELSE IF W_[376] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[723] ELSE 149.075+1082.25108225108*W_[376]*(
  sqr(4329.00432900433*W_[376])-3)*(298.15+0.000994579541498831*W_[723]-W_[161])
  +0.5*(W_[161]+0.000994579541498831*W_[723]);
W_[162] = 298.15+0.000994579541498831*W_[723];
W_[159] = IF  -W_[376] > 0.000231 THEN W_[162] ELSE IF  -W_[376] < -0.000231
   THEN 298.15+0.000994579541498831*W_[148] ELSE 149.075+0.5*(W_[162]+
  0.000994579541498831*W_[148])-1082.25108225108*W_[376]*(sqr((-4329.00432900433)
  *W_[376])-3)*(298.15+0.000994579541498831*W_[148]-W_[162]);
W_[190] = W_[148];
W_[200] =  -divmacro(W_[378],"Econ.port_Exh.m_flow",IF  -W_[378] > 0.000231
   THEN 1.18430792005922E-005*W_[722] ELSE IF  -W_[378] < -0.000231 THEN 
  1.18430792005922E-005*W_[327] ELSE 5.92153960029608E-006*(W_[722]+W_[327])-
  0.0128171852820261*W_[378]*(sqr((-4329.00432900433)*W_[378])-3)*(W_[327]-
  W_[722]),"smooth(1, (if noEvent( -Econ.port_Exh.m_flow > 0.000231) then 1.18430792005922E-005*room.vol.medium.p else (if noEvent( -Econ.port_Exh.m_flow < -0.000231) then 1.18430792005922E-005*Econ.preDroExh.state_a.p else 5.92153960029608E-006*(room.vol.medium.p+Econ.preDroExh.state_a.p)-0.0128171852820261*Econ.port_Exh.m_flow*(((-4329.00432900433)*Econ.port_Exh.m_flow)^2-3)*(Econ.preDroExh.state_a.p-roo...");
W_[203] = 298.15+0.000994579541498831*W_[191];
W_[201] = IF  -W_[378] > 0.000231 THEN W_[203] ELSE IF  -W_[378] < -0.000231
   THEN 298.15+0.000994579541498831*W_[148] ELSE 149.075+0.5*(W_[203]+
  0.000994579541498831*W_[148])-1082.25108225108*W_[378]*(sqr((-4329.00432900433)
  *W_[378])-3)*(298.15+0.000994579541498831*W_[148]-W_[203]);
W_[204] = 298.15+0.000994579541498831*W_[148];
W_[202] = IF W_[378] > 0.000231 THEN W_[204] ELSE IF W_[378] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[191] ELSE 149.075+1082.25108225108*W_[378]*(
  sqr(4329.00432900433*W_[378])-3)*(298.15+0.000994579541498831*W_[191]-W_[204])
  +0.5*(W_[204]+0.000994579541498831*W_[191]);
W_[243] = divmacro(W_[241],"Econ.damRec.m_flow",IF W_[241] > 0.000231 THEN 
  1.18430792005922E-005*W_[246] ELSE IF W_[241] < -0.000231 THEN 
  1.18430792005922E-005*W_[639] ELSE 0.0128171852820261*W_[241]*(sqr(
  4329.00432900433*W_[241])-3)*(W_[639]-W_[246])+5.92153960029608E-006*(W_[246]+
  W_[639]),"smooth(1, (if noEvent(Econ.damRec.m_flow > 0.000231) then 1.18430792005922E-005*Econ.damRec.state_a.p else (if noEvent(Econ.damRec.m_flow < -0.000231) then 1.18430792005922E-005*del.medium.p else 0.0128171852820261*Econ.damRec.m_flow*((4329.00432900433*Econ.damRec.m_flow)^2-3)*(del.medium.p-Econ.damRec.state_a.p)+5.92153960029608E-006*(Econ.damRec.state_a.p+del.medium.p))))");
W_[247] = 298.15+0.000994579541498831*W_[723];
W_[244] = IF W_[241] > 0.000231 THEN W_[247] ELSE IF W_[241] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[148] ELSE 149.075+1082.25108225108*W_[241]*(
  sqr(4329.00432900433*W_[241])-3)*(298.15+0.000994579541498831*W_[148]-W_[247])
  +0.5*(W_[247]+0.000994579541498831*W_[148]);
W_[248] = 298.15+0.000994579541498831*W_[148];
W_[245] = IF  -W_[241] > 0.000231 THEN W_[248] ELSE IF  -W_[241] < -0.000231
   THEN 298.15+0.000994579541498831*W_[723] ELSE 149.075+0.5*(W_[248]+
  0.000994579541498831*W_[723])-1082.25108225108*W_[241]*(sqr((-4329.00432900433)
  *W_[241])-3)*(298.15+0.000994579541498831*W_[723]-W_[248]);
W_[293] = divmacro(W_[376],"Econ.port_Out.m_flow",IF W_[376] > 0.000231 THEN 1.2
   ELSE IF W_[376] < -0.000231 THEN 1.18430792005922E-005*W_[160] ELSE 0.6+
  0.0128171852820261*W_[376]*(sqr(4329.00432900433*W_[376])-3)*(W_[160]-101325)+
  5.92153960029608E-006*W_[160],"smooth(1, (if noEvent(Econ.port_Out.m_flow > 0.000231) then 1.2 else (if noEvent(Econ.port_Out.m_flow < -0.000231) then 1.18430792005922E-005*Econ.damOA.state_a.p else 0.6+0.0128171852820261*Econ.port_Out.m_flow*((4329.00432900433*Econ.port_Out.m_flow)^2-3)*(Econ.damOA.state_a.p-101325)+5.92153960029608E-006*Econ.damOA.state_a.p)))");
W_[297] = 298.15+0.000994579541498831*W_[148];
W_[294] = IF W_[376] > 0.000231 THEN W_[297] ELSE IF W_[376] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[723] ELSE 149.075+1082.25108225108*W_[376]*(
  sqr(4329.00432900433*W_[376])-3)*(298.15+0.000994579541498831*W_[723]-W_[297])
  +0.5*(W_[297]+0.000994579541498831*W_[723]);
W_[298] = 298.15+0.000994579541498831*W_[723];
W_[295] = IF  -W_[376] > 0.000231 THEN W_[298] ELSE IF  -W_[376] < -0.000231
   THEN 298.15+0.000994579541498831*W_[148] ELSE 149.075+0.5*(W_[298]+
  0.000994579541498831*W_[148])-1082.25108225108*W_[376]*(sqr((-4329.00432900433)
  *W_[376])-3)*(298.15+0.000994579541498831*W_[148]-W_[298]);
W_[324] =  -divmacro(W_[378],"Econ.port_Exh.m_flow",IF  -W_[378] > 0.000231
   THEN 1.18430792005922E-005*W_[327] ELSE IF  -W_[378] < -0.000231 THEN 1.2
   ELSE 0.6+5.92153960029608E-006*W_[327]-0.0128171852820261*W_[378]*(sqr((
  -4329.00432900433)*W_[378])-3)*(101325-W_[327]),"smooth(1, (if noEvent( -Econ.port_Exh.m_flow > 0.000231) then 1.18430792005922E-005*Econ.preDroExh.state_a.p else (if noEvent( -Econ.port_Exh.m_flow < -0.000231) then 1.2 else 0.6+5.92153960029608E-006*Econ.preDroExh.state_a.p-0.0128171852820261*Econ.port_Exh.m_flow*(((-4329.00432900433)*Econ.port_Exh.m_flow)^2-3)*(101325-Econ.preDroExh.state_a.p))))");
W_[328] = 298.15+0.000994579541498831*W_[191];
W_[325] = IF  -W_[378] > 0.000231 THEN W_[328] ELSE IF  -W_[378] < -0.000231
   THEN 298.15+0.000994579541498831*W_[148] ELSE 149.075+0.5*(W_[328]+
  0.000994579541498831*W_[148])-1082.25108225108*W_[378]*(sqr((-4329.00432900433)
  *W_[378])-3)*(298.15+0.000994579541498831*W_[148]-W_[328]);
W_[330] = 298.15+0.000994579541498831*W_[148];
W_[326] = IF W_[378] > 0.000231 THEN W_[330] ELSE IF W_[378] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[191] ELSE 149.075+1082.25108225108*W_[378]*(
  sqr(4329.00432900433*W_[378])-3)*(298.15+0.000994579541498831*W_[191]-W_[330])
  +0.5*(W_[330]+0.000994579541498831*W_[191]);
W_[356] = divmacro(W_[241],"Econ.damRec.m_flow",IF W_[241] > 0.000231 THEN 
  1.18430792005922E-005*W_[722] ELSE IF W_[241] < -0.000231 THEN 
  1.18430792005922E-005*W_[246] ELSE 0.0128171852820261*W_[241]*(sqr(
  4329.00432900433*W_[241])-3)*(W_[246]-W_[722])+5.92153960029608E-006*(W_[722]+
  W_[246]),"smooth(1, (if noEvent(Econ.damRec.m_flow > 0.000231) then 1.18430792005922E-005*room.vol.medium.p else (if noEvent(Econ.damRec.m_flow < -0.000231) then 1.18430792005922E-005*Econ.damRec.state_a.p else 0.0128171852820261*Econ.damRec.m_flow*((4329.00432900433*Econ.damRec.m_flow)^2-3)*(Econ.damRec.state_a.p-room.vol.medium.p)+5.92153960029608E-006*(room.vol.medium.p+Econ.damRec.state_a.p))))");
W_[359] = 298.15+0.000994579541498831*W_[723];
W_[357] = IF W_[241] > 0.000231 THEN W_[359] ELSE IF W_[241] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[148] ELSE 149.075+1082.25108225108*W_[241]*(
  sqr(4329.00432900433*W_[241])-3)*(298.15+0.000994579541498831*W_[148]-W_[359])
  +0.5*(W_[359]+0.000994579541498831*W_[148]);
W_[360] = 298.15+0.000994579541498831*W_[148];
W_[358] = IF  -W_[241] > 0.000231 THEN W_[360] ELSE IF  -W_[241] < -0.000231
   THEN 298.15+0.000994579541498831*W_[723] ELSE 149.075+0.5*(W_[360]+
  0.000994579541498831*W_[723])-1082.25108225108*W_[241]*(sqr((-4329.00432900433)
  *W_[241])-3)*(298.15+0.000994579541498831*W_[723]-W_[360]);
Aux_[19] = W_[380]+helpvar[123];
Aux_[20] = IF Aux_[19] > 2.31E-010 THEN 1 ELSE IF Aux_[19] > 0 THEN sqr(
  4329004329.00433*Aux_[19])*(3.0-8658008658.00866*Aux_[19]) ELSE 0;
helpvar[128] = 1-Aux_[20];
helpvar[129] = Aux_[20]*helpvar[123]+2.31E-010*helpvar[128];
helpvar[130] = W_[380]+helpvar[129];
helpvar[131] = divmacro(1,"1",helpvar[130],"Econ.port_Ret.m_flow+stream_alpha5*max( -Econ.damRec.m_flow, 0)+2.31E-010*(1-stream_alpha5)");
W_[384] = helpvar[131]*(W_[380]*W_[723]+helpvar[129]*W_[148]);
Aux_[21] = helpvar[112]+W_[376];
Aux_[22] = IF Aux_[21] > 2.31E-010 THEN 1 ELSE IF Aux_[21] > 0 THEN sqr(
  4329004329.00433*Aux_[21])*(3.0-8658008658.00866*Aux_[21]) ELSE 0;
helpvar[132] = 1-Aux_[22];
helpvar[133] = Aux_[22]*helpvar[112]+2.31E-010*helpvar[132];
helpvar[134] = helpvar[133]+W_[376];
helpvar[135] = divmacro(1,"1",helpvar[134],"stream_alpha7*max(Econ.damRec.m_flow, 0)+2.31E-010*(1-stream_alpha7)+Econ.port_Out.m_flow");
W_[386] = helpvar[135]*(helpvar[133]*W_[723]+W_[376]*W_[148]);
W_[392] = W_[148]-287.051224952979*W_[778];
W_[399] = W_[778]-273.15;
W_[424] = divmacro(W_[803],"Duct.m_flow",IF W_[803] > 0.000231 THEN 
  1.18430792005922E-005*W_[639] ELSE IF W_[803] < -0.000231 THEN 
  1.18430792005922E-005*W_[830] ELSE 0.0128171852820261*W_[803]*(sqr(
  4329.00432900433*W_[803])-3)*(W_[830]-W_[639])+5.92153960029608E-006*(W_[639]+
  W_[830]),"smooth(1, (if noEvent(Duct.m_flow > 0.000231) then 1.18430792005922E-005*del.medium.p else (if noEvent(Duct.m_flow < -0.000231) then 1.18430792005922E-005*HC.port_a1.p else 0.0128171852820261*Duct.m_flow*((4329.00432900433*Duct.m_flow)^2-3)*(HC.port_a1.p-del.medium.p)+5.92153960029608E-006*(del.medium.p+HC.port_a1.p))))");
W_[427] = 298.15+0.000994579541498831*W_[640];
W_[425] = IF W_[803] > 0.000231 THEN W_[427] ELSE IF W_[803] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[831] ELSE 149.075+1082.25108225108*W_[803]*(
  sqr(4329.00432900433*W_[803])-3)*(298.15+0.000994579541498831*W_[831]-W_[427])
  +0.5*(W_[427]+0.000994579541498831*W_[831]);
W_[428] = 298.15+0.000994579541498831*W_[831];
W_[426] = IF  -W_[803] > 0.000231 THEN W_[428] ELSE IF  -W_[803] < -0.000231
   THEN 298.15+0.000994579541498831*W_[640] ELSE 149.075+0.5*(W_[428]+
  0.000994579541498831*W_[640])-1082.25108225108*W_[803]*(sqr((-4329.00432900433)
  *W_[803])-3)*(298.15+0.000994579541498831*W_[640]-W_[428]);
W_[455] = 298.15+0.000994579541498831*W_[84];
W_[456] = 298.15+0.000994579541498831*W_[448];
W_[457] = 298.15+0.000994579541498831*W_[84];
W_[458] = 298.15+0.000994579541498831*W_[723];
W_[467] = DP_[279]-W_[471];
W_[486] = W_[936]-W_[934];
W_[502] = DP_[281]-W_[506];
W_[519] = DP_[280]-W_[933];
W_[534] = DP_[211]-W_[83];
W_[619] = 1E-005*W_[880];
W_[650] = W_[642]-273.15;
W_[651] = 1E-005*W_[639];
W_[732] = W_[933]-273.15;
W_[733] = 1E-005*W_[722];
W_[782] = DP_[231]+(IF LessTime(DP_[232], 1) THEN 0 ELSE DP_[228]*sin(
  6.28318530717959*DP_[229]*(Time-DP_[232])+DP_[230]));
W_[784] = DP_[236]+(IF LessTime(DP_[237], 2) THEN 0 ELSE DP_[233]*sin(
  6.28318530717959*DP_[234]*(Time-DP_[237])+DP_[235]));
W_[786] = DP_[241]+(IF LessTime(DP_[242], 3) THEN 0 ELSE DP_[238]*sin(
  6.28318530717959*DP_[239]*(Time-DP_[242])+DP_[240]));
W_[805] = divmacro(W_[803],"Duct.m_flow",IF W_[803] > 0.000231 THEN 
  1.18430792005922E-005*W_[447] ELSE IF W_[803] < -0.000231 THEN 
  1.18430792005922E-005*W_[722] ELSE 0.0128171852820261*W_[803]*(sqr(
  4329.00432900433*W_[803])-3)*(W_[722]-W_[447])+5.92153960029608E-006*(W_[447]+
  W_[722]),"smooth(1, (if noEvent(Duct.m_flow > 0.000231) then 1.18430792005922E-005*RHC.port_b.p else (if noEvent(Duct.m_flow < -0.000231) then 1.18430792005922E-005*room.vol.medium.p else 0.0128171852820261*Duct.m_flow*((4329.00432900433*Duct.m_flow)^2-3)*(room.vol.medium.p-RHC.port_b.p)+5.92153960029608E-006*(RHC.port_b.p+room.vol.medium.p))))");
W_[808] = 298.15+0.000994579541498831*W_[448];
W_[806] = IF W_[803] > 0.000231 THEN W_[808] ELSE IF W_[803] < -0.000231 THEN 
  298.15+0.000994579541498831*W_[723] ELSE 149.075+1082.25108225108*W_[803]*(
  sqr(4329.00432900433*W_[803])-3)*(298.15+0.000994579541498831*W_[723]-W_[808])
  +0.5*(W_[808]+0.000994579541498831*W_[723]);
W_[809] = 298.15+0.000994579541498831*W_[723];
W_[807] = IF  -W_[803] > 0.000231 THEN W_[809] ELSE IF  -W_[803] < -0.000231
   THEN 298.15+0.000994579541498831*W_[448] ELSE 149.075+0.5*(W_[809]+
  0.000994579541498831*W_[448])-1082.25108225108*W_[803]*(sqr((-4329.00432900433)
  *W_[803])-3)*(298.15+0.000994579541498831*W_[448]-W_[809]);
 /* Linear system of equations to solve. */
W_[835] = RememberSimple_(W_[835], 20);
SolveScalarLinear(W_[848],"HC.m2_flow", W_[866]+83680.0*W_[848],"HC.Q1_flow+83680.0*HC.m2_flow",
   W_[835],"HC.port_a2.h_outflow");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
W_[837] = RememberSimple_(W_[837], 21);
SolveScalarLinear(W_[848],"HC.m2_flow", 343924.8*W_[848]-W_[866],
  "343924.8*HC.m2_flow-HC.Q1_flow", W_[837],"HC.port_b2.h_outflow");
 /* End of Equation Block */ 

W_[850] = 298.15+0.000994579541498831*(IF Greater(W_[803],"Duct.m_flow", 0,"0", 24)
   THEN W_[640] ELSE W_[831]);
W_[851] = 298.15+0.000994579541498831*(IF Greater( -W_[803]," -Duct.m_flow", 0,
  "0", 25) THEN Aux_[12] ELSE Aux_[13]);
W_[852] = 273.15+0.000239005736137667*(IF Greater(W_[848],"HC.m2_flow", 0,"0", 26)
   THEN 343924.8 ELSE W_[835]);
W_[854] = 273.15+0.000239005736137667*(IF Greater( -W_[848]," -HC.m2_flow", 0,
  "0", 27) THEN 83680.0 ELSE W_[837]);
 /* Linear system of equations to solve. */
W_[881] = RememberSimple_(W_[881], 22);
SolveScalarLinear(W_[894],"CC.m2_flow", W_[912]+83680.0*W_[894],"CC.Q1_flow+83680.0*CC.m2_flow",
   W_[881],"CC.port_a2.h_outflow");
 /* End of Equation Block */ 

 /* Linear system of equations to solve. */
W_[883] = RememberSimple_(W_[883], 23);
SolveScalarLinear(W_[894],"CC.m2_flow", W_[894]*W_[620]-W_[912],"CC.m2_flow*chiller.ports[1].h_outflow-CC.Q1_flow",
   W_[883],"CC.port_b2.h_outflow");
 /* End of Equation Block */ 

W_[896] = 298.15+0.000994579541498831*(IF Greater(W_[803],"Duct.m_flow", 0,"0", 24)
   THEN Aux_[13] ELSE Aux_[12]);
W_[897] = 298.15+0.000994579541498831*(IF Greater( -W_[803]," -Duct.m_flow", 0,
  "0", 25) THEN W_[84] ELSE W_[879]);
W_[898] = 273.15+0.000239005736137667*(IF Greater(W_[894],"CC.m2_flow", 0,"0", 28)
   THEN W_[620] ELSE W_[881]);
W_[900] = 273.15+0.000239005736137667*(IF Greater( -W_[894]," -CC.m2_flow", 0,
  "0", 29) THEN 83680.0 ELSE W_[883]);
W_[827] = DP_[261]+(IF LessTime(DP_[262], 4) THEN 0 ELSE DP_[260]);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAlias(0)
StartNonAlias(0)
DeclareParameter("system.p_ambient", "Default ambient pressure [Pa|bar]", 0, 101325,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("system.T_ambient", "Default ambient temperature [K|degC]", 1, \
293.15, 0.0,1E+100,0.0,0,560)
DeclareParameter("system.g", "Constant gravity acceleration [m/s2]", 2, 9.80665,\
 0.0,0.0,0.0,0,560)
DeclareVariable("system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("system.energyDynamics", "Default formulation of energy balances",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.massDynamics", "Default formulation of mass balances", 1,\
 1.0,4.0,0.0,0,517)
DeclareVariable("system.substanceDynamics", "Default formulation of substance balances",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.traceDynamics", "Default formulation of trace substance balances",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("system.momentumDynamics", "Default formulation of momentum balances, if options available",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("system.p_start", "Default start value for pressures [Pa|bar]", 0,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("system.T_start", "Default start value for temperatures [K|degC]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("system.m_flow_small", "Default small laminar mass flow rate for regularization of zero flow [kg/s]",\
 4, 0.01, 0.0,1E+100,0.0,0,560)
DeclareParameter("system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 5, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("VRoo", "Room volume [m3]", 6, 800, 0.0,0.0,0.0,0,560)
DeclareParameter("UA", "UA value of room [W/K]", 7, 200, 0.0,0.0,0.0,0,560)
DeclareParameter("Q_sen_d", "Fixed heat flow rate at port [W]", 8, 8000, \
0.0,0.0,0.0,0,560)
DeclareAlias2("DmprC.u_s", "Connector of setpoint input signal [K]", \
"cliBCVTB.yR[1]", 1, 5, 935, 0)
DeclareAlias2("DmprC.u_m", "Connector of measurement input signal [K]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareAlias2("DmprC.y", "Connector of actuator output signal", "DmprC.limiter.y", 1,\
 5, 21, 0)
DeclareVariable("DmprC.controlError", "Control error (set point - measurement) [K]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("DmprC.controllerType", "Type of controller", 2, 1.0,4.0,0.0,0,517)
DeclareParameter("DmprC.k", "Gain of controller", 9, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("DmprC.Ti", "Time constant of Integrator block [s]", 10, 60, \
1E-060,1E+100,0.0,0,560)
DeclareParameter("DmprC.Td", "Time constant of Derivative block [s]", 11, 60, \
0.0,1E+100,0.0,0,560)
DeclareParameter("DmprC.yMax", "Upper limit of output", 12, -0.3, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.yMin", "Lower limit of output", 13, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.wp", "Set-point weight for Proportional block (0..1)", 14,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("DmprC.wd", "Set-point weight for Derivative block (0..1)", 15,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("DmprC.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 16, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("DmprC.Nd", "The higher Nd, the more ideal the derivative block",\
 17, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("DmprC.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("DmprC.limitsAtInit", "= false, if limits are ignored during initializiation",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("DmprC.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 18, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.xd_start", "Initial or guess value for state of derivative block",\
 19, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.y_start", "Initial value of output", 20, 0, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("DmprC.addP.u1", "Connector of Real input signal 1 [K]", \
"cliBCVTB.yR[1]", 1, 5, 935, 0)
DeclareAlias2("DmprC.addP.u2", "Connector of Real input signal 2 [K]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareVariable("DmprC.addP.y", "Connector of Real output signal", 0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("DmprC.addP.k1", "Gain of upper input", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("DmprC.addP.k2", "Gain of lower input", 21, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.P.k", "Gain value multiplied with input signal", 22, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("DmprC.P.u", "Input signal connector", "DmprC.addP.y", 1, 5, 12, 0)
DeclareAlias2("DmprC.P.y", "Output signal connector", "DmprC.addPID.u1", 1, 5, 16,\
 0)
DeclareVariable("DmprC.gainPID.k", "Gain value multiplied with input signal", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("DmprC.gainPID.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("DmprC.gainPID.y", "Output signal connector", "DmprC.limiter.u", 1,\
 5, 20, 0)
DeclareParameter("DmprC.addPID.k1", "Gain of upper input", 23, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.addPID.k2", "Gain of middle input", 24, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.addPID.k3", "Gain of lower input", 25, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("DmprC.addPID.u1", "Connector 1 of Real input signals", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("DmprC.addPID.u2", "Connector 2 of Real input signals", \
"DmprC.Dzero.k", 1, 7, 26, 0)
DeclareAlias2("DmprC.addPID.u3", "Connector 3 of Real input signals", \
"DmprC.I.y", 1, 1, 6, 0)
DeclareAlias2("DmprC.addPID.y", "Connector of Real output signals", \
"DmprC.gainPID.u", 1, 5, 15, 0)
DeclareVariable("DmprC.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("DmprC.limiter.uMin", "Lower limits of input signals", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("DmprC.limiter.limitsAtInit", "= false, if limits are ignored during initializiation (i.e., y=u)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("DmprC.limiter.u", "Connector of Real input signal", 0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("DmprC.limiter.y", "Connector of Real output signal", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("DmprC.with_I", "", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("DmprC.with_D", "", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("DmprC.Dzero.k", "Constant output value", 26, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("DmprC.Dzero.y", "Connector of Real output signal", \
"DmprC.Dzero.k", 1, 7, 26, 0)
DeclareVariable("VAV.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("VAV.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareAlias2("VAV.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "SupF.medium.p", 1, 5, 83, 4)
DeclareAlias2("VAV.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "RHC.port_a.h_outflow", 1, 5, 446, 4)
DeclareAlias2("VAV.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", -1, 5, 803, 132)
DeclareAlias2("VAV.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "RHC.port_a.p", 1, 5, 445, 4)
DeclareVariable("VAV.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareVariable("VAV.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("VAV.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("VAV.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 27, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("VAV.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 3, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("VAV.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("VAV.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("VAV.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("VAV.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("VAV.m_flow", "Mass flow rate in design flow direction [kg/s]", \
"Duct.m_flow", 1, 5, 803, 0)
DeclareVariable("VAV.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 3, 0.0,0.0,3.0,0,512)
DeclareVariable("VAV.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("VAV.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("VAV.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareAlias2("VAV.state_a.p", "Absolute pressure of medium [Pa|bar]", \
"SupF.medium.p", 1, 5, 83, 1024)
DeclareVariable("VAV.state_a.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,2560)
DeclareAlias2("VAV.state_b.p", "Absolute pressure of medium [Pa|bar]", \
"RHC.port_a.p", 1, 5, 445, 1024)
DeclareVariable("VAV.state_b.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,2560)
DeclareVariable("VAV.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("VAV.m_flow_nominal", "Nominal mass flow rate [kg/s]", 2.31, 0.0,\
100000.0,0.0,0,513)
DeclareVariable("VAV.dp_nominal", "Pressure [Pa|Pa]", 3, 0.0,1E+100,0.0,0,513)
DeclareVariable("VAV.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("VAV.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("VAV.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("VAV.sta0.p", "Absolute pressure of medium [Pa|bar]", 101325, \
0.0,100000000.0,100000.0,0,2561)
DeclareVariable("VAV.sta0.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2561)
DeclareVariable("VAV.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("VAV.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 28, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("VAV.conv", "Factor, needed to satisfy unit check [m.s2/kg]", 1,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.conv2", "Factor, needed to satisfy unit check", 1, 0.0,0.0,\
0.0,0,2561)
DeclareAlias2("VAV.y", "Damper position (0: closed, 1: open)", "gain2.y", 1, 5, 826,\
 0)
DeclareParameter("VAV.use_deltaM", "Set to true to use deltaM for turbulent transition, else ReC is used",\
 29, true, 0.0,0.0,0.0,0,562)
DeclareParameter("VAV.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 30, 0.3, 0.0,0.0,0.0,0,560)
DeclareParameter("VAV.use_v_nominal", "Set to true to use face velocity to compute area",\
 31, true, 0.0,0.0,0.0,0,562)
DeclareParameter("VAV.v_nominal", "Nominal face velocity [m/s]", 32, 3.6, \
0.0,0.0,0.0,0,560)
DeclareParameter("VAV.A", "Face area [m2]", 33, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("VAV.roundDuct", "Set to true for round duct, false for square cross section",\
 34, false, 0.0,0.0,0.0,0,562)
DeclareParameter("VAV.ReC", "Reynolds number where transition to turbulent starts",\
 35, 4000, 0.0,0.0,0.0,0,560)
DeclareParameter("VAV.a", "Coefficient a for damper characteristics", 36, -1.51,\
 0.0,0.0,0.0,0,560)
DeclareParameter("VAV.b", "Coefficient b for damper characteristics", 37, 9.45, \
0.0,0.0,0.0,0,560)
DeclareParameter("VAV.yL", "Lower value for damper curve", 38, 0.166666666666667,\
 0.0,0.0,0.0,0,560)
DeclareParameter("VAV.yU", "Upper value for damper curve", 39, 0.611111111111111,\
 0.0,0.0,0.0,0,560)
DeclareParameter("VAV.k0", "Flow coefficient for y=0, k0 = pressure drop divided by dynamic pressure",\
 40, 1000000.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("VAV.k1", "Flow coefficient for y=1, k1 = pressure drop divided by dynamic pressure",\
 41, 0.45, 0.0,1E+100,0.0,0,560)
DeclareVariable("VAV.kDamSqu", "Flow coefficient for damper, kDam=k^2=m_flow^2/|dp| [kg.m]",\
 1, 0.0,0.0,0.0,0,512)
DeclareParameter("VAV.use_constant_density", "Set to true to use constant density for flow friction",\
 42, true, 0.0,0.0,0.0,0,562)
DeclareVariable("VAV.rho", "Medium density [kg/m3|g/cm3]", 1, 0.0,100000.0,1.0,0,512)
DeclareVariable("VAV.rho_nominal", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 1.2, 0.0,100000.0,1.0,0,2561)
DeclareVariable("VAV.kTheta", "Flow coefficient, kTheta = pressure drop divided by dynamic pressure",\
 0, 0.0,1E+100,0.0,0,2560)
DeclareVariable("VAV.cL[1]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.cL[2]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.cL[3]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.cU[1]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.cU[2]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.cU[3]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.facRouDuc", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.area", "Face velocity used in the computation [m2]", 0, \
0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.dpDamOpe0", "Pressure drop of fully open damper at nominal flow rate [Pa|bar]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("VAV.kResSqu", "Resistance coefficient for fixed resistance element [kg.m]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("Tc.k", "Constant output value", 43, 297.15, 0.0,0.0,0.0,0,560)
DeclareAlias2("Tc.y", "Connector of Real output signal", "Tc.k", 1, 7, 43, 0)
DeclareVariable("P_vd", "[Pa|bar]", 3, 0.0,0.0,0.0,0,513)
DeclareParameter("cp_a", "[J/(kg.K)]", 44, 1005, 0.0,0.0,0.0,0,560)
DeclareParameter("cp_w", "[J/(kg.K)]", 45, 4200, 0.0,0.0,0.0,0,560)
DeclareVariable("SupF.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("SupF.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareVariable("SupF.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,520)
DeclareAlias2("SupF.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "SupF.medium.h", 1, 5, 84, 4)
DeclareAlias2("SupF.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", -1, 5, 803, 132)
DeclareAlias2("SupF.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "SupF.medium.p", 1, 5, 83, 4)
DeclareAlias2("SupF.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "SupF.medium.h", 1, 5, 84, 4)
DeclareParameter("SupF.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 46, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("SupF.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("SupF.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 47, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("SupF.p_a_start", "Guess value for inlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("SupF.p_b_start", "Guess value for outlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareParameter("SupF.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 48, 1, -100000.0,100000.0,0.0,0,560)
DeclareParameter("SupF.nParallel", "Number of fans or pumps in parallel", 49, 1,\
 1.0,1E+100,0.0,0,564)
DeclareVariable("SupF.N_nominal", "Nominal rotational speed for flow characteristic [1/min]",\
 1500, 0.0,0.0,0.0,0,513)
DeclareParameter("SupF.rho_nominal", "Nominal fluid density [kg/m3|g/cm3]", 50, \
1.2, 0.0,100000.0,1.0,0,560)
DeclareVariable("SupF.use_powerCharacteristic", "Use powerCharacteristic (vs. efficiencyCharacteristic)",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("SupF.checkValve", "= true to prevent reverse flow", false, \
0.0,0.0,0.0,0,515)
DeclareVariable("SupF.V", "Volume inside the pump [m3]", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("SupF.fluidVolume", "Volume [m3]", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("SupF.energyDynamics", "Formulation of energy balance", 4, 1.0,\
4.0,0.0,0,517)
DeclareVariable("SupF.massDynamics", "Formulation of mass balance", 4, 1.0,4.0,\
0.0,0,517)
DeclareVariable("SupF.substanceDynamics", "Formulation of substance balance", 4,\
 1.0,4.0,0.0,0,517)
DeclareVariable("SupF.traceDynamics", "Formulation of trace substance balance", 4,\
 1.0,4.0,0.0,0,517)
DeclareVariable("SupF.p_start", "Start value of pressure [Pa|bar]", 100000.0, \
0.0,100000000.0,100000.0,0,513)
DeclareVariable("SupF.use_T_start", "= true, use T_start, otherwise h_start", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("SupF.T_start", "Start value of temperature [K|degC]", 300, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("SupF.h_start", "Start value of specific enthalpy [J/kg]", 0, \
-100000000.0,100000000.0,1000000.0,0,513)
DeclareParameter("SupF.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 51, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("SupF.medium.p", "Absolute pressure of medium [Pa|bar]", 0, 0.0,\
100000000.0,100000.0,0,512)
DeclareVariable("SupF.medium.h", "Specific enthalpy of medium [J/kg]", 0, \
-100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("SupF.medium.d", "Density of medium [kg/m3|g/cm3]", 1, 0.0,\
100000.0,1.0,0,512)
DeclareVariable("SupF.medium.T", "Temperature of medium [K|degC]", 300.0, 1.0,\
10000.0,300.0,0,512)
DeclareVariable("SupF.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("SupF.medium.u", "Specific internal energy of medium [J/kg]", 0,\
 -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("SupF.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 287.051224952979, 0.0,1000000.0,1000.0,0,513)
DeclareVariable("SupF.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.0289651159, 0.001,0.25,0.032,0,513)
DeclareAlias2("SupF.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
"SupF.medium.p", 1, 5, 83, 0)
DeclareAlias2("SupF.medium.state.T", "Temperature of medium [K|degC]", \
"SupF.medium.T", 1, 5, 86, 0)
DeclareVariable("SupF.medium.constantDensity", "= true if the mass density should be constant at dStp",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("SupF.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("SupF.medium.standardOrderComponents", "if true, and reducedX = true, the last element of X will be computed from the other ones",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("SupF.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("SupF.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("SupF.U", "Internal energy of fluid [J]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("SupF.m", "Mass of fluid [kg]", 0, 0.0,1E+100,0.0,0,512)
DeclareVariable("SupF.mb_flow", "Mass flows across boundaries [kg/s]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("SupF.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("SupF.Qb_flow", "Heat flow across boundaries or energy source/sink [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("SupF.Wb_flow", "Work flow across boundaries or source term [W]", \
"SupF.Hb_flow", -1, 5, 99, 0)
DeclareParameter("SupF.initialize_p", "= true to set up initial equations for pressure",\
 52, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("SupF.use_HeatTransfer", "= true to use a HeatTransfer model, e.g. for a housing",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("SupF.heatTransfer.n", "Number of heat transfer segments", 1, \
0.0,0.0,0.0,0,517)
DeclareAlias2("SupF.heatTransfer.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "SupF.medium.p", 1, 5, 83, 0)
DeclareAlias2("SupF.heatTransfer.states[1].T", "Temperature of medium [K|degC]",\
 "SupF.medium.T", 1, 5, 86, 0)
DeclareVariable("SupF.heatTransfer.surfaceAreas[1]", "Heat transfer areas [m2]",\
 3.04647389268978, 0.0,0.0,0.0,0,513)
DeclareVariable("SupF.heatTransfer.Q_flows[1]", "Heat flow rates [W]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("SupF.heatTransfer.use_k", "= true to use k value for thermal isolation",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("SupF.heatTransfer.k", "Heat transfer coefficient to ambient [W/(m2.K)]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("SupF.heatTransfer.T_ambient", "Ambient temperature [K|degC]", 0,\
 0.0,1E+100,0.0,0,513)
DeclareAlias2("SupF.heatTransfer.heatPorts[1].T", "Port temperature [K|degC]", \
"SupF.medium.T", 1, 5, 86, 4)
DeclareVariable("SupF.heatTransfer.heatPorts[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("SupF.heatTransfer.Ts[1]", "Temperatures defined by fluid states [K|degC]",\
 "SupF.medium.T", 1, 5, 86, 0)
DeclareVariable("SupF.dp", "Pressure increase [Pa|Pa]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("SupF.m_flow", "Mass flow rate (total) [kg/s]", "Duct.m_flow", 1, 5,\
 803, 0)
DeclareVariable("SupF.m_flow_single", "Mass flow rate (single pump) [kg/s]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("SupF.V_flow", "Volume flow rate (total) [m3/s]", 0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("SupF.V_flow_single", "Volume flow rate (single pump) [m3/s]", 0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("SupF.N", "Shaft rotational speed [1/min]", 1500, 0.0,1E+100,0.0,\
0,512)
DeclareVariable("SupF.W_single", "Power consumption (single fan or pump) [W]", 0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("SupF.W_total", "Power consumption (total) [W]", "SupF.Hb_flow", -1,\
 5, 99, 0)
DeclareVariable("SupF.eta", "Global efficiency [1]", 0.8, 0.0,0.0,0.0,0,513)
DeclareVariable("SupF.s", "Curvilinear abscissa for the flow curve in parametric form (either mass flow rate or total pressure) [1]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("SupF.show_NPSHa", "= true to compute Net Positive Suction Head available",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("SupF.unitPressure", "[Pa|bar]", 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("SupF.unitMassFlowRate", "[kg/s]", 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("SupF.use_y_in", "Get the rotational speed from the input connector",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("SupF.y_const", "Constant normalized rotational speed", 53, 1, \
0.0,1.0,0.0,0,560)
DeclareAlias2("SupF.y_in", "Constant normalized rotational speed", \
"FanC.limiter.y", 1, 5, 547, 0)
DeclareAlias2("SupF.y_in_internal", "Needed to connect to conditional connector",\
 "FanC.limiter.y", 1, 5, 547, 1024)
DeclareVariable("Boi.nPorts", "Number of ports", 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("Boi.medium.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_a2.p", 1, 5, 834, 0)
DeclareVariable("Boi.medium.h", "Specific enthalpy of medium [J/kg]", 343924.8, \
0.0,0.0,0.0,0,513)
DeclareVariable("Boi.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("Boi.medium.T", "Temperature of medium [K|degC]", 355.35, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("Boi.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("Boi.medium.u", "Specific internal energy of medium [J/kg]", \
343924.8, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("Boi.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,1000000.0,1000.0,0,513)
DeclareVariable("Boi.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("Boi.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_a2.p", 1, 5, 834, 0)
DeclareVariable("Boi.medium.state.T", "Temperature of medium [K|degC]", 355.35, \
1.0,10000.0,300.0,0,513)
DeclareVariable("Boi.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Boi.medium.standardOrderComponents", "if true, and reducedX = true, the last element of X will be computed from the other ones",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Boi.medium.T_degC", "Temperature of medium in [degC] [degC;]", \
82.2, 0.0,0.0,0.0,0,513)
DeclareVariable("Boi.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("Boi.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "HC.m2_flow", -1, 5, 848, 132)
DeclareAlias2("Boi.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "HC.port_a2.p", 1, 5, 834, 4)
DeclareVariable("Boi.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 343924.8, -100000000.0,100000000.0,1000000.0,0,521)
DeclareVariable("Boi.flowDirection", "Allowed flow direction", 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("Boi.use_m_flow_in", "Get the mass flow rate from the input connector",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("Boi.use_T_in", "Get the temperature from the input connector", \
false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Boi.use_X_in", "Get the composition from the input connector", \
false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Boi.use_C_in", "Get the trace substances from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Boi.m_flow", "Fixed mass flow rate going out of the fluid port [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Boi.T", "Fixed value of temperature [K|degC]", 355.35, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("Boi.X[1]", "Fixed value of composition [kg/kg]", 1, 0.0,1.0,0.1,\
0,513)
DeclareAlias2("Boi.m_flow_in", "Prescribed mass flow rate [kg/s]", "HC.m2_flow", 1,\
 5, 848, 0)
DeclareAlias2("Boi.m_flow_in_internal", "Needed to connect to conditional connector [kg/s]",\
 "HC.m2_flow", 1, 5, 848, 1024)
DeclareVariable("Boi.T_in_internal", "Needed to connect to conditional connector [K]",\
 355.35, 0.0,0.0,0.0,0,2561)
DeclareVariable("Boi.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damOA.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.damOA.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Out.m_flow", 1, 5, 376, 132)
DeclareAlias2("Econ.damOA.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "Econ.damOA.state_a.p", 1, 5, 160, 4)
DeclareVariable("Econ.damOA.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("Econ.damOA.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Out.m_flow", -1, 5, 376, 132)
DeclareAlias2("Econ.damOA.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 4)
DeclareVariable("Econ.damOA.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareVariable("Econ.damOA.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("Econ.damOA.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("Econ.damOA.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 54, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("Econ.damOA.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Econ.damOA.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damOA.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damOA.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damOA.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.damOA.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "Econ.port_Out.m_flow", 1, 5, 376, 0)
DeclareVariable("Econ.damOA.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0, 0.0,0.0,10.0,0,512)
DeclareVariable("Econ.damOA.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.damOA.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.damOA.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.damOA.state_a.p", "Absolute pressure of medium [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,2560)
DeclareVariable("Econ.damOA.state_a.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareAlias2("Econ.damOA.state_b.p", "Absolute pressure of medium [Pa|bar]", \
"del.medium.p", 1, 5, 639, 1024)
DeclareVariable("Econ.damOA.state_b.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareVariable("Econ.damOA.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damOA.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
2.31, 0.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damOA.dp_nominal", "Pressure [Pa|Pa]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("Econ.damOA.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damOA.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.damOA.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damOA.sta0.p", "Absolute pressure of medium [Pa|bar]", 101325,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Econ.damOA.sta0.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,2561)
DeclareVariable("Econ.damOA.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.damOA.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 55, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("Econ.damOA.conv", "Factor, needed to satisfy unit check [m.s2/kg]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.conv2", "Factor, needed to satisfy unit check", 1, \
0.0,0.0,0.0,0,2561)
DeclareAlias2("Econ.damOA.y", "Damper position (0: closed, 1: open)", \
"Econ.damExh.y", 1, 5, 216, 0)
DeclareParameter("Econ.damOA.use_deltaM", "Set to true to use deltaM for turbulent transition, else ReC is used",\
 56, true, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damOA.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 57, 0.3, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damOA.use_v_nominal", "Set to true to use face velocity to compute area",\
 58, true, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damOA.v_nominal", "Nominal face velocity [m/s]", 59, 1, \
0.0,0.0,0.0,0,560)
DeclareVariable("Econ.damOA.A", "Face area [m2]", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("Econ.damOA.roundDuct", "Set to true for round duct, false for square cross section",\
 60, false, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damOA.ReC", "Reynolds number where transition to turbulent starts",\
 61, 4000, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damOA.a", "Coefficient a for damper characteristics", 62,\
 -1.51, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damOA.b", "Coefficient b for damper characteristics", 63,\
 9.45, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damOA.yL", "Lower value for damper curve", 64, \
0.166666666666667, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damOA.yU", "Upper value for damper curve", 65, \
0.611111111111111, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damOA.k0", "Flow coefficient for y=0, k0 = pressure drop divided by dynamic pressure",\
 66, 1000000.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("Econ.damOA.k1", "Flow coefficient for y=1, k1 = pressure drop divided by dynamic pressure",\
 67, 0.45, 0.0,1E+100,0.0,0,560)
DeclareVariable("Econ.damOA.kDamSqu", "Flow coefficient for damper, kDam=k^2=m_flow^2/|dp| [kg.m]",\
 1, 0.0,0.0,0.0,0,512)
DeclareParameter("Econ.damOA.use_constant_density", "Set to true to use constant density for flow friction",\
 68, true, 0.0,0.0,0.0,0,562)
DeclareVariable("Econ.damOA.rho", "Medium density [kg/m3|g/cm3]", 1, 0.0,\
100000.0,1.0,0,512)
DeclareVariable("Econ.damOA.rho_nominal", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 1.2, 0.0,100000.0,1.0,0,2561)
DeclareVariable("Econ.damOA.kTheta", "Flow coefficient, kTheta = pressure drop divided by dynamic pressure",\
 0, 0.0,1E+100,0.0,0,2560)
DeclareVariable("Econ.damOA.cL[1]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.cL[2]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.cL[3]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.cU[1]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.cU[2]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.cU[3]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.facRouDuc", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.area", "Face velocity used in the computation [m2]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.kDam_nominal", "Flow coefficient for damper, k=m_flow/sqrt(dp), with unit=(kg*m)^(1/2)",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damOA.kTheta_nominal", "Flow coefficient, kTheta = pressure drop divided by dynamic pressure",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.AOutMin", "Face area minimum outside air damper [m2]", 69,\
 0.03, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.AOut", "Face area outside air damper [m2]", 70, 0.33, \
0.0,0.0,0.0,0,560)
DeclareVariable("Econ.damExh.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.damExh.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Exh.m_flow", -1, 5, 378, 132)
DeclareAlias2("Econ.damExh.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 4)
DeclareVariable("Econ.damExh.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("Econ.damExh.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Exh.m_flow", 1, 5, 378, 132)
DeclareAlias2("Econ.damExh.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "Econ.preDroExh.state_a.p", 1, 5, 327, 4)
DeclareVariable("Econ.damExh.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareVariable("Econ.damExh.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("Econ.damExh.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("Econ.damExh.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 71, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("Econ.damExh.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Econ.damExh.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damExh.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damExh.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damExh.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.damExh.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "Econ.port_Exh.m_flow", -1, 5, 378, 0)
DeclareVariable("Econ.damExh.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0, 0.0,0.0,10.0,0,512)
DeclareVariable("Econ.damExh.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.damExh.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.damExh.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareAlias2("Econ.damExh.state_a.p", "Absolute pressure of medium [Pa|bar]", \
"room.vol.medium.p", 1, 5, 722, 1024)
DeclareVariable("Econ.damExh.state_a.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareAlias2("Econ.damExh.state_b.p", "Absolute pressure of medium [Pa|bar]", \
"Econ.preDroExh.state_a.p", 1, 5, 327, 1024)
DeclareVariable("Econ.damExh.state_b.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareVariable("Econ.damExh.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damExh.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
2.31, 0.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damExh.dp_nominal", "Pressure [Pa|Pa]", 0, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("Econ.damExh.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damExh.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.damExh.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damExh.sta0.p", "Absolute pressure of medium [Pa|bar]", 101325,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Econ.damExh.sta0.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,2561)
DeclareVariable("Econ.damExh.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.damExh.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 72, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("Econ.damExh.conv", "Factor, needed to satisfy unit check [m.s2/kg]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.conv2", "Factor, needed to satisfy unit check", 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.y", "Damper position (0: closed, 1: open)", 0, 0.0,\
1.0,0.0,0,512)
DeclareParameter("Econ.damExh.use_deltaM", "Set to true to use deltaM for turbulent transition, else ReC is used",\
 73, true, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damExh.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 74, 0.3, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damExh.use_v_nominal", "Set to true to use face velocity to compute area",\
 75, true, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damExh.v_nominal", "Nominal face velocity [m/s]", 76, 1, \
0.0,0.0,0.0,0,560)
DeclareVariable("Econ.damExh.A", "Face area [m2]", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("Econ.damExh.roundDuct", "Set to true for round duct, false for square cross section",\
 77, false, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damExh.ReC", "Reynolds number where transition to turbulent starts",\
 78, 4000, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damExh.a", "Coefficient a for damper characteristics", 79,\
 -1.51, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damExh.b", "Coefficient b for damper characteristics", 80,\
 9.45, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damExh.yL", "Lower value for damper curve", 81, \
0.166666666666667, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damExh.yU", "Upper value for damper curve", 82, \
0.611111111111111, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damExh.k0", "Flow coefficient for y=0, k0 = pressure drop divided by dynamic pressure",\
 83, 1000000.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("Econ.damExh.k1", "Flow coefficient for y=1, k1 = pressure drop divided by dynamic pressure",\
 84, 0.45, 0.0,1E+100,0.0,0,560)
DeclareVariable("Econ.damExh.kDamSqu", "Flow coefficient for damper, kDam=k^2=m_flow^2/|dp| [kg.m]",\
 1, 0.0,0.0,0.0,0,512)
DeclareParameter("Econ.damExh.use_constant_density", "Set to true to use constant density for flow friction",\
 85, true, 0.0,0.0,0.0,0,562)
DeclareVariable("Econ.damExh.rho", "Medium density [kg/m3|g/cm3]", 1, 0.0,\
100000.0,1.0,0,512)
DeclareVariable("Econ.damExh.rho_nominal", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 1.2, 0.0,100000.0,1.0,0,2561)
DeclareVariable("Econ.damExh.kTheta", "Flow coefficient, kTheta = pressure drop divided by dynamic pressure",\
 0, 0.0,1E+100,0.0,0,2560)
DeclareVariable("Econ.damExh.cL[1]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.cL[2]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.cL[3]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.cU[1]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.cU[2]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.cU[3]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.facRouDuc", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.area", "Face velocity used in the computation [m2]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.kDam_nominal", "Flow coefficient for damper, k=m_flow/sqrt(dp), with unit=(kg*m)^(1/2)",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damExh.kTheta_nominal", "Flow coefficient, kTheta = pressure drop divided by dynamic pressure",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.AExh", "Face area exhaust air damper [m2]", 86, 0.33, \
0.0,0.0,0.0,0,560)
DeclareVariable("Econ.damRec.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.damRec.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.damRec.m_flow", 1, 5, 241, 132)
DeclareAlias2("Econ.damRec.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "Econ.damRec.state_a.p", 1, 5, 246, 4)
DeclareAlias2("Econ.damRec.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.preDroRec.port_a.h_outflow", 1, 5, 347, 4)
DeclareAlias2("Econ.damRec.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.damRec.m_flow", -1, 5, 241, 132)
DeclareAlias2("Econ.damRec.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 4)
DeclareVariable("Econ.damRec.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareVariable("Econ.damRec.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("Econ.damRec.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("Econ.damRec.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 87, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("Econ.damRec.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Econ.damRec.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damRec.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damRec.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damRec.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damRec.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 0, -1E+060,100000.0,2.31,0,512)
DeclareVariable("Econ.damRec.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0, 0.0,0.0,10.0,0,512)
DeclareVariable("Econ.damRec.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.damRec.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.damRec.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.damRec.state_a.p", "Absolute pressure of medium [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2560)
DeclareVariable("Econ.damRec.state_a.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareAlias2("Econ.damRec.state_b.p", "Absolute pressure of medium [Pa|bar]", \
"del.medium.p", 1, 5, 639, 1024)
DeclareVariable("Econ.damRec.state_b.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareVariable("Econ.damRec.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damRec.m_flow_nominal", "Nominal mass flow rate [kg/s]", \
2.31, 0.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damRec.dp_nominal", "Pressure [Pa|Pa]", 0, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("Econ.damRec.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.damRec.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.damRec.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.damRec.sta0.p", "Absolute pressure of medium [Pa|bar]", 101325,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Econ.damRec.sta0.T", "Temperature of medium [K|degC]", 293.15, \
1.0,10000.0,300.0,0,2561)
DeclareVariable("Econ.damRec.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.damRec.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 88, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("Econ.damRec.conv", "Factor, needed to satisfy unit check [m.s2/kg]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.conv2", "Factor, needed to satisfy unit check", 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.y", "Damper position (0: closed, 1: open)", 0, 0.0,\
1.0,0.0,0,512)
DeclareParameter("Econ.damRec.use_deltaM", "Set to true to use deltaM for turbulent transition, else ReC is used",\
 89, true, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damRec.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 90, 0.3, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damRec.use_v_nominal", "Set to true to use face velocity to compute area",\
 91, true, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damRec.v_nominal", "Nominal face velocity [m/s]", 92, 1, \
0.0,0.0,0.0,0,560)
DeclareVariable("Econ.damRec.A", "Face area [m2]", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("Econ.damRec.roundDuct", "Set to true for round duct, false for square cross section",\
 93, false, 0.0,0.0,0.0,0,562)
DeclareParameter("Econ.damRec.ReC", "Reynolds number where transition to turbulent starts",\
 94, 4000, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damRec.a", "Coefficient a for damper characteristics", 95,\
 -1.51, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damRec.b", "Coefficient b for damper characteristics", 96,\
 9.45, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damRec.yL", "Lower value for damper curve", 97, \
0.166666666666667, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damRec.yU", "Upper value for damper curve", 98, \
0.611111111111111, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.damRec.k0", "Flow coefficient for y=0, k0 = pressure drop divided by dynamic pressure",\
 99, 1000000.0, 0.0,1E+100,0.0,0,560)
DeclareParameter("Econ.damRec.k1", "Flow coefficient for y=1, k1 = pressure drop divided by dynamic pressure",\
 100, 0.45, 0.0,1E+100,0.0,0,560)
DeclareVariable("Econ.damRec.kDamSqu", "Flow coefficient for damper, kDam=k^2=m_flow^2/|dp| [kg.m]",\
 1, 0.0,0.0,0.0,0,512)
DeclareParameter("Econ.damRec.use_constant_density", "Set to true to use constant density for flow friction",\
 101, true, 0.0,0.0,0.0,0,562)
DeclareVariable("Econ.damRec.rho", "Medium density [kg/m3|g/cm3]", 1, 0.0,\
100000.0,1.0,0,512)
DeclareVariable("Econ.damRec.rho_nominal", "Density, used to compute fluid volume [kg/m3|g/cm3]",\
 1.2, 0.0,100000.0,1.0,0,2561)
DeclareVariable("Econ.damRec.kTheta", "Flow coefficient, kTheta = pressure drop divided by dynamic pressure",\
 0, 0.0,1E+100,0.0,0,2560)
DeclareVariable("Econ.damRec.cL[1]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.cL[2]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.cL[3]", "Polynomial coefficients for curve fit for y < yl",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.cU[1]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.cU[2]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.cU[3]", "Polynomial coefficients for curve fit for y > yu",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.facRouDuc", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.area", "Face velocity used in the computation [m2]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.kDam_nominal", "Flow coefficient for damper, k=m_flow/sqrt(dp), with unit=(kg*m)^(1/2)",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.damRec.kTheta_nominal", "Flow coefficient, kTheta = pressure drop divided by dynamic pressure",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.ARec", "Face area recirculation air damper [m2]", 102, \
0.33, 0.0,0.0,0.0,0,560)
DeclareVariable("Econ.m0OutMin_flow", "Mass flow rate minimum outside air damper [kg/s]",\
 0.231, 0.0,0.0,0.0,0,513)
DeclareParameter("Econ.dpOutMin_nominal", "Pressure drop minimum outside air leg (without damper) [Pa|Pa]",\
 103, 42, 0.0,0.0,0.0,0,560)
DeclareVariable("Econ.m0Out_flow", "Mass flow rate outside air damper [kg/s]", \
2.31, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.dpOut_nominal", "Pressure drop outside air leg (without damper) [Pa|Pa]",\
 42, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.m0Rec_flow", "Mass flow rate recirculation air damper [kg/s]",\
 2.31, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.dpRec_nominal", "Pressure drop recirculation air leg (without damper) [Pa|Pa]",\
 42, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.m0Exh_flow", "Mass flow rate exhaust air damper [kg/s]", \
2.31, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.dpExh_nominal", "Pressure drop exhaust air leg (without damper) [Pa|Pa]",\
 42, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroOut.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.preDroOut.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Out.m_flow", 1, 5, 376, 132)
DeclareVariable("Econ.preDroOut.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("Econ.preDroOut.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.damOA.port_a.h_outflow", 1, 5, 147, 4)
DeclareAlias2("Econ.preDroOut.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Out.m_flow", -1, 5, 376, 132)
DeclareAlias2("Econ.preDroOut.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "Econ.damOA.state_a.p", 1, 5, 160, 4)
DeclareAlias2("Econ.preDroOut.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.damOA.port_b.h_outflow", 1, 5, 148, 4)
DeclareVariable("Econ.preDroOut.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("Econ.preDroOut.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("Econ.preDroOut.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 104, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("Econ.preDroOut.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Econ.preDroOut.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroOut.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroOut.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroOut.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.preDroOut.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "Econ.port_Out.m_flow", 1, 5, 376, 0)
DeclareVariable("Econ.preDroOut.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0, 0.0,0.0,42.0,0,512)
DeclareVariable("Econ.preDroOut.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.preDroOut.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.preDroOut.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.preDroOut.state_a.p", "Absolute pressure of medium [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Econ.preDroOut.state_a.T", "Temperature of medium [K|degC]", 300,\
 1.0,10000.0,300.0,0,2560)
DeclareAlias2("Econ.preDroOut.state_b.p", "Absolute pressure of medium [Pa|bar]",\
 "Econ.damOA.state_a.p", 1, 5, 160, 1024)
DeclareVariable("Econ.preDroOut.state_b.T", "Temperature of medium [K|degC]", 300,\
 1.0,10000.0,300.0,0,2560)
DeclareVariable("Econ.preDroOut.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroOut.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 2.31, 0.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroOut.dp_nominal", "Pressure [Pa|Pa]", 42, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("Econ.preDroOut.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroOut.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.356440738412432, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroOut.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0.693, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroOut.sta0.p", "Absolute pressure of medium [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Econ.preDroOut.sta0.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("Econ.preDroOut.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.preDroOut.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 105, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("Econ.preDroOut.conv", "Factor, needed to satisfy unit check [m.s2/kg]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.preDroOut.conv2", "Factor, needed to satisfy unit check", 1,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.preDroOut.use_dh", "Set to true to specify hydraulic diameter",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroOut.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroOut.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroOut.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("Econ.preDroExh.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.preDroExh.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Exh.m_flow", -1, 5, 378, 132)
DeclareAlias2("Econ.preDroExh.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "Econ.preDroExh.state_a.p", 1, 5, 327, 4)
DeclareAlias2("Econ.preDroExh.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.damExh.port_a.h_outflow", 1, 5, 190, 4)
DeclareAlias2("Econ.preDroExh.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Exh.m_flow", 1, 5, 378, 132)
DeclareVariable("Econ.preDroExh.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("Econ.preDroExh.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.damExh.port_b.h_outflow", 1, 5, 191, 4)
DeclareVariable("Econ.preDroExh.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("Econ.preDroExh.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("Econ.preDroExh.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 106, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("Econ.preDroExh.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Econ.preDroExh.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroExh.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroExh.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroExh.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.preDroExh.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "Econ.port_Exh.m_flow", -1, 5, 378, 0)
DeclareVariable("Econ.preDroExh.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0, 0.0,0.0,42.0,0,512)
DeclareVariable("Econ.preDroExh.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.preDroExh.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.preDroExh.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.preDroExh.state_a.p", "Absolute pressure of medium [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,2560)
DeclareVariable("Econ.preDroExh.state_a.T", "Temperature of medium [K|degC]", 300,\
 1.0,10000.0,300.0,0,2560)
DeclareVariable("Econ.preDroExh.state_b.p", "Absolute pressure of medium [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Econ.preDroExh.state_b.T", "Temperature of medium [K|degC]", 300,\
 1.0,10000.0,300.0,0,2560)
DeclareVariable("Econ.preDroExh.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroExh.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 2.31, 0.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroExh.dp_nominal", "Pressure [Pa|Pa]", 42, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("Econ.preDroExh.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroExh.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.356440738412432, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroExh.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0.693, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroExh.sta0.p", "Absolute pressure of medium [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Econ.preDroExh.sta0.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("Econ.preDroExh.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.preDroExh.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 107, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("Econ.preDroExh.conv", "Factor, needed to satisfy unit check [m.s2/kg]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.preDroExh.conv2", "Factor, needed to satisfy unit check", 1,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.preDroExh.use_dh", "Set to true to specify hydraulic diameter",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroExh.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroExh.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroExh.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("Econ.preDroRec.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.preDroRec.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.damRec.m_flow", 1, 5, 241, 132)
DeclareAlias2("Econ.preDroRec.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 4)
DeclareVariable("Econ.preDroRec.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("Econ.preDroRec.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.damRec.m_flow", -1, 5, 241, 132)
DeclareAlias2("Econ.preDroRec.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "Econ.damRec.state_a.p", 1, 5, 246, 4)
DeclareAlias2("Econ.preDroRec.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.damRec.port_b.h_outflow", 1, 5, 233, 4)
DeclareVariable("Econ.preDroRec.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("Econ.preDroRec.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("Econ.preDroRec.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 108, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("Econ.preDroRec.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Econ.preDroRec.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroRec.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroRec.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroRec.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("Econ.preDroRec.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "Econ.damRec.m_flow", 1, 5, 241, 0)
DeclareVariable("Econ.preDroRec.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0, 0.0,0.0,42.0,0,512)
DeclareVariable("Econ.preDroRec.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Econ.preDroRec.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Econ.preDroRec.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareAlias2("Econ.preDroRec.state_a.p", "Absolute pressure of medium [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 1024)
DeclareVariable("Econ.preDroRec.state_a.T", "Temperature of medium [K|degC]", 300,\
 1.0,10000.0,300.0,0,2560)
DeclareAlias2("Econ.preDroRec.state_b.p", "Absolute pressure of medium [Pa|bar]",\
 "Econ.damRec.state_a.p", 1, 5, 246, 1024)
DeclareVariable("Econ.preDroRec.state_b.T", "Temperature of medium [K|degC]", 300,\
 1.0,10000.0,300.0,0,2560)
DeclareVariable("Econ.preDroRec.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroRec.m_flow_nominal", "Nominal mass flow rate [kg/s]",\
 2.31, 0.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroRec.dp_nominal", "Pressure [Pa|Pa]", 42, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("Econ.preDroRec.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroRec.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.356440738412432, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroRec.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0.693, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Econ.preDroRec.sta0.p", "Absolute pressure of medium [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Econ.preDroRec.sta0.T", "Temperature of medium [K|degC]", \
293.15, 1.0,10000.0,300.0,0,2561)
DeclareVariable("Econ.preDroRec.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Econ.preDroRec.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 109, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("Econ.preDroRec.conv", "Factor, needed to satisfy unit check [m.s2/kg]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.preDroRec.conv2", "Factor, needed to satisfy unit check", 1,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("Econ.preDroRec.use_dh", "Set to true to specify hydraulic diameter",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Econ.preDroRec.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroRec.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("Econ.preDroRec.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("Econ.port_Out.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,2.31,0,776)
DeclareVariable("Econ.port_Out.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("Econ.port_Out.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.damOA.port_a.h_outflow", 1, 5, 147, 4)
DeclareVariable("Econ.port_Exh.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,0.0,2.31,0,776)
DeclareVariable("Econ.port_Exh.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("Econ.port_Exh.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.damExh.port_b.h_outflow", 1, 5, 191, 4)
DeclareVariable("Econ.port_Ret.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,776)
DeclareAlias2("Econ.port_Ret.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 4)
DeclareAlias2("Econ.port_Ret.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Econ.preDroRec.port_a.h_outflow", 1, 5, 347, 4)
DeclareVariable("Econ.port_Sup.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,0.0,0.0,0,776)
DeclareAlias2("Econ.port_Sup.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 4)
DeclareVariable("Econ.port_Sup.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("Econ.y", "Damper position (0: closed, 1: open)", "Econ.damExh.y", 1,\
 5, 216, 0)
DeclareParameter("Econ.uni.k", "Constant output value", 110, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("Econ.uni.y", "Connector of Real output signal", "Econ.uni.k", 1, 7,\
 110, 0)
DeclareAlias2("Econ.add.u1", "Connector of Real input signal 1", "Econ.uni.k", 1,\
 7, 110, 0)
DeclareAlias2("Econ.add.u2", "Connector of Real input signal 2", "Econ.damExh.y", 1,\
 5, 216, 0)
DeclareAlias2("Econ.add.y", "Connector of Real output signal", "Econ.damRec.y", 1,\
 5, 260, 0)
DeclareParameter("Econ.add.k1", "Gain of upper input", 111, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("Econ.add.k2", "Gain of lower input", 112, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("Econ.port_Ret1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.0,0,2825)
DeclareAlias2("Econ.port_Ret1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 1028)
DeclareVariable("Econ.port_Ret1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,2568)
DeclareVariable("Econ.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.0,0,2825)
DeclareAlias2("Econ.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 1028)
DeclareVariable("Econ.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,2568)
DeclareVariable("Amb.nPorts", "Number of ports", 3, 0.0,0.0,0.0,0,517)
DeclareVariable("Amb.medium.p", "Absolute pressure of medium [Pa|bar]", 101325, \
0.0,1E+100,0.0,0,513)
DeclareVariable("Amb.medium.h", "Specific enthalpy of medium [J/kg]", 0, \
-100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("Amb.medium.d", "Density of medium [kg/m3|g/cm3]", 1.2, 0.0,\
100000.0,1.0,0,513)
DeclareAlias2("Amb.medium.T", "Temperature of medium [K|degC]", "room.TAmb", 1, 5,\
 778, 0)
DeclareVariable("Amb.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("Amb.medium.u", "Specific internal energy of medium [J/kg]", 0, \
-100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("Amb.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 287.051224952979, 0.0,1000000.0,1000.0,0,513)
DeclareVariable("Amb.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.0289651159, 0.001,0.25,0.032,0,513)
DeclareVariable("Amb.medium.state.p", "Absolute pressure of medium [Pa|bar]", 101325,\
 0.0,100000000.0,100000.0,0,513)
DeclareAlias2("Amb.medium.state.T", "Temperature of medium [K|degC]", \
"room.TAmb", 1, 5, 778, 0)
DeclareVariable("Amb.medium.constantDensity", "= true if the mass density should be constant at dStp",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Amb.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Amb.medium.standardOrderComponents", "if true, and reducedX = true, the last element of X will be computed from the other ones",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Amb.medium.T_degC", "Temperature of medium in [degC] [degC;]", 0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("Amb.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 1.01325, 0.0,0.0,0.0,0,513)
DeclareVariable("Amb.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -1E+060,1E+060,0.0,0,777)
DeclareVariable("Amb.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("Amb.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Amb.medium.h", 1, 5, 389, 4)
DeclareAlias2("Amb.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Out.m_flow", -1, 5, 376, 132)
DeclareVariable("Amb.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("Amb.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Amb.medium.h", 1, 5, 389, 4)
DeclareAlias2("Amb.ports[3].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Exh.m_flow", -1, 5, 378, 132)
DeclareVariable("Amb.ports[3].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 101325, 0.0,100000000.0,100000.0,0,521)
DeclareAlias2("Amb.ports[3].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "Amb.medium.h", 1, 5, 389, 4)
DeclareVariable("Amb.flowDirection", "Allowed flow direction", 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("Amb.use_p_in", "Get the pressure from the input connector", \
false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb.use_T_in", "Get the temperature from the input connector", \
true, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb.use_X_in", "Get the composition from the input connector", \
false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb.use_C_in", "Get the trace substances from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb.p", "Fixed value of pressure [Pa|bar]", 101325, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("Amb.T", "Fixed value of temperature [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("Amb.X[1]", "Fixed value of composition [kg/kg]", 1, 0.0,1.0,0.1,\
0,513)
DeclareAlias2("Amb.T_in", "Prescribed boundary temperature [K]", "room.TAmb", 1,\
 5, 778, 0)
DeclareVariable("Amb.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 101325, 0.0,0.0,0.0,0,2561)
DeclareAlias2("Amb.T_in_internal", "Needed to connect to conditional connector [K]",\
 "room.TAmb", 1, 5, 778, 1024)
DeclareVariable("Amb.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("filter.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("filter.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareAlias2("filter.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 4)
DeclareAlias2("filter.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "HC.port_a1.h_outflow", 1, 5, 831, 4)
DeclareAlias2("filter.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", -1, 5, 803, 132)
DeclareAlias2("filter.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "HC.port_a1.p", 1, 5, 830, 4)
DeclareAlias2("filter.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "del.medium.h", 1, 5, 640, 4)
DeclareVariable("filter.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("filter.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("filter.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 113, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("filter.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("filter.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("filter.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("filter.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("filter.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("filter.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 0)
DeclareVariable("filter.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0, 0.0,0.0,100.0,0,512)
DeclareVariable("filter.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("filter.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("filter.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareAlias2("filter.state_a.p", "Absolute pressure of medium [Pa|bar]", \
"del.medium.p", 1, 5, 639, 1024)
DeclareVariable("filter.state_a.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,2560)
DeclareAlias2("filter.state_b.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_a1.p", 1, 5, 830, 1024)
DeclareVariable("filter.state_b.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,2560)
DeclareVariable("filter.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("filter.m_flow_nominal", "Nominal mass flow rate [kg/s]", 2.31, \
0.0,100000.0,0.0,0,513)
DeclareVariable("filter.dp_nominal", "Pressure [Pa|Pa]", 100, 0.0,1E+100,0.0,0,513)
DeclareVariable("filter.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("filter.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.231, 0.0,0.0,0.0,0,513)
DeclareVariable("filter.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0.693, -100000.0,100000.0,0.0,0,513)
DeclareVariable("filter.sta0.p", "Absolute pressure of medium [Pa|bar]", 101325,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("filter.sta0.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2561)
DeclareVariable("filter.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("filter.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 114, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("filter.conv", "Factor, needed to satisfy unit check [m.s2/kg]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("filter.conv2", "Factor, needed to satisfy unit check", 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("filter.use_dh", "Set to true to specify hydraulic diameter", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("filter.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("filter.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("filter.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("RHC.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("RHC.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareVariable("RHC.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("RHC.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("RHC.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", -1, 5, 803, 132)
DeclareVariable("RHC.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("RHC.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareParameter("RHC.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 115, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("RHC.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 116, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("RHC.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 117, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("RHC.m_flow_nominal", "Nominal mass flow rate [kg/s]", 2.31, 0.0,\
100000.0,0.0,0,513)
DeclareVariable("RHC.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, 0.0,100000.0,0.0,0,513)
DeclareVariable("RHC.p_a_start", "Guess value for inlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("RHC.p_b_start", "Guess value for outlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("RHC.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("RHC.m_flow", "Mass flow rate from port_a to port_b (m_flow > 0 is design flow direction) [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 0)
DeclareVariable("RHC.dp", "Pressure difference between port_a and port_b [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("RHC.sta_a.p", "Absolute pressure of medium [Pa|bar]", \
"RHC.port_a.p", 1, 5, 445, 0)
DeclareVariable("RHC.sta_a.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("RHC.sta_b.p", "Absolute pressure of medium [Pa|bar]", \
"RHC.port_b.p", 1, 5, 447, 0)
DeclareVariable("RHC.sta_b.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("RHC.state_a_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"RHC.port_a.p", 1, 5, 445, 1024)
DeclareVariable("RHC.state_a_inflow.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareAlias2("RHC.state_b_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"RHC.port_b.p", 1, 5, 447, 1024)
DeclareVariable("RHC.state_b_inflow.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareVariable("RHC.computeFlowResistance", "=true, compute flow resistance. Set to false to assume no friction",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("RHC.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("RHC.dp_nominal", "Pressure [Pa|Pa]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("RHC.linearizeFlowResistance", "= true, use linear relation between m_flow and dp for any flow rate",\
 118, false, 0.0,0.0,0.0,0,562)
DeclareParameter("RHC.deltaM", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 119, 0.1, 0.0,0.0,0.0,0,560)
DeclareVariable("RHC.Q_flow", "Heat transfered into the medium [W]", 0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("RHC.Q_flow_nominal", "Heat flow rate at u=1, positive for heating [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("RHC.u", "Control input [1]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Tmix.port.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("Tmix.port.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 4)
DeclareVariable("Tmix.port.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,521)
DeclareAlias2("Tmix.T", "Temperature in port medium [K|degC]", "EcoC.addP.u2", 1,\
 5, 471, 0)
DeclareAlias2("EcoC.u_s", "Connector of setpoint input signal [K]", "Tmsp.k", 1,\
 7, 279, 0)
DeclareAlias2("EcoC.u_m", "Connector of measurement input signal [K]", \
"EcoC.addP.u2", 1, 5, 471, 0)
DeclareAlias2("EcoC.y", "Connector of actuator output signal", "EcoC.limiter.y", 1,\
 5, 481, 0)
DeclareVariable("EcoC.controlError", "Control error (set point - measurement) [K]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("EcoC.controllerType", "Type of controller", 2, 1.0,4.0,0.0,0,517)
DeclareParameter("EcoC.k", "Gain of controller", 120, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("EcoC.Ti", "Time constant of Integrator block [s]", 121, 60, \
1E-060,1E+100,0.0,0,560)
DeclareParameter("EcoC.Td", "Time constant of Derivative block [s]", 122, 60, \
0.0,1E+100,0.0,0,560)
DeclareParameter("EcoC.yMax", "Upper limit of output", 123, -0.1, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.yMin", "Lower limit of output", 124, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.wp", "Set-point weight for Proportional block (0..1)", 125,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("EcoC.wd", "Set-point weight for Derivative block (0..1)", 126,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("EcoC.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 127, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("EcoC.Nd", "The higher Nd, the more ideal the derivative block",\
 128, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("EcoC.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("EcoC.limitsAtInit", "= false, if limits are ignored during initializiation",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("EcoC.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 129, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.xd_start", "Initial or guess value for state of derivative block",\
 130, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.y_start", "Initial value of output", 131, 0, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("EcoC.addP.u1", "Connector of Real input signal 1 [K]", "Tmsp.k", 1,\
 7, 279, 0)
DeclareVariable("EcoC.addP.u2", "Connector of Real input signal 2 [K]", 0, 0.0,\
1E+100,0.0,0,512)
DeclareVariable("EcoC.addP.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("EcoC.addP.k1", "Gain of upper input", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("EcoC.addP.k2", "Gain of lower input", 132, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.P.k", "Gain value multiplied with input signal", 133, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("EcoC.P.u", "Input signal connector", "EcoC.addP.y", 1, 5, 472, 0)
DeclareAlias2("EcoC.P.y", "Output signal connector", "EcoC.addPID.u1", 1, 5, 476,\
 0)
DeclareVariable("EcoC.gainPID.k", "Gain value multiplied with input signal", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("EcoC.gainPID.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("EcoC.gainPID.y", "Output signal connector", "EcoC.limiter.u", 1, 5,\
 480, 0)
DeclareParameter("EcoC.addPID.k1", "Gain of upper input", 134, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.addPID.k2", "Gain of middle input", 135, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.addPID.k3", "Gain of lower input", 136, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("EcoC.addPID.u1", "Connector 1 of Real input signals", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("EcoC.addPID.u2", "Connector 2 of Real input signals", \
"EcoC.Dzero.k", 1, 7, 137, 0)
DeclareAlias2("EcoC.addPID.u3", "Connector 3 of Real input signals", "EcoC.I.y", 1,\
 1, 7, 0)
DeclareAlias2("EcoC.addPID.y", "Connector of Real output signals", \
"EcoC.gainPID.u", 1, 5, 475, 0)
DeclareVariable("EcoC.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("EcoC.limiter.uMin", "Lower limits of input signals", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("EcoC.limiter.limitsAtInit", "= false, if limits are ignored during initializiation (i.e., y=u)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("EcoC.limiter.u", "Connector of Real input signal", 0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("EcoC.limiter.y", "Connector of Real output signal", 0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("EcoC.with_I", "", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("EcoC.with_D", "", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("EcoC.Dzero.k", "Constant output value", 137, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("EcoC.Dzero.y", "Connector of Real output signal", "EcoC.Dzero.k", 1,\
 7, 137, 0)
DeclareVariable("Tsa.port.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("Tsa.port.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "SupF.medium.p", 1, 5, 83, 4)
DeclareVariable("Tsa.port.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,521)
DeclareAlias2("Tsa.T", "Temperature in port medium [K|degC]", "cliBCVTB.uR[2]", 1,\
 5, 934, 0)
DeclareAlias2("CCC.u_s", "Connector of setpoint input signal [K]", \
"cliBCVTB.yR[2]", 1, 5, 936, 0)
DeclareAlias2("CCC.u_m", "Connector of measurement input signal [K]", \
"cliBCVTB.uR[2]", 1, 5, 934, 0)
DeclareAlias2("CCC.y", "Connector of actuator output signal [1]", \
"CCC.limiter.y", 1, 5, 499, 0)
DeclareVariable("CCC.controlError", "Control error (set point - measurement) [K]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("CCC.controllerType", "Type of controller", 2, 1.0,4.0,0.0,0,517)
DeclareParameter("CCC.k", "Gain of controller", 138, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("CCC.Ti", "Time constant of Integrator block [s]", 139, 60, \
1E-060,1E+100,0.0,0,560)
DeclareParameter("CCC.Td", "Time constant of Derivative block [s]", 140, 60, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("CCC.yMax", "Upper limit of output [1]", 141, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.yMin", "Lower limit of output [1]", 142, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.wp", "Set-point weight for Proportional block (0..1)", 143,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("CCC.wd", "Set-point weight for Derivative block (0..1)", 144, 0,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("CCC.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 145, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("CCC.Nd", "The higher Nd, the more ideal the derivative block",\
 146, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("CCC.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("CCC.limitsAtInit", "= false, if limits are ignored during initializiation",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("CCC.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 147, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.xd_start", "Initial or guess value for state of derivative block",\
 148, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.y_start", "Initial value of output [1]", 149, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("CCC.addP.u1", "Connector of Real input signal 1 [K]", \
"cliBCVTB.yR[2]", 1, 5, 936, 0)
DeclareAlias2("CCC.addP.u2", "Connector of Real input signal 2 [K]", \
"cliBCVTB.uR[2]", 1, 5, 934, 0)
DeclareVariable("CCC.addP.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("CCC.addP.k1", "Gain of upper input", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("CCC.addP.k2", "Gain of lower input", 150, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.P.k", "Gain value multiplied with input signal", 151, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("CCC.P.u", "Input signal connector", "CCC.addP.y", 1, 5, 490, 0)
DeclareAlias2("CCC.P.y", "Output signal connector", "CCC.addPID.u1", 1, 5, 494, 0)
DeclareVariable("CCC.gainPID.k", "Gain value multiplied with input signal", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("CCC.gainPID.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("CCC.gainPID.y", "Output signal connector [1]", "CCC.limiter.u", 1,\
 5, 498, 0)
DeclareParameter("CCC.addPID.k1", "Gain of upper input", 152, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.addPID.k2", "Gain of middle input", 153, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.addPID.k3", "Gain of lower input", 154, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("CCC.addPID.u1", "Connector 1 of Real input signals", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("CCC.addPID.u2", "Connector 2 of Real input signals", \
"CCC.Dzero.k", 1, 7, 155, 0)
DeclareAlias2("CCC.addPID.u3", "Connector 3 of Real input signals", "CCC.I.y", 1,\
 1, 8, 0)
DeclareAlias2("CCC.addPID.y", "Connector of Real output signals", \
"CCC.gainPID.u", 1, 5, 493, 0)
DeclareVariable("CCC.limiter.uMax", "Upper limits of input signals [1]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("CCC.limiter.uMin", "Lower limits of input signals [1]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("CCC.limiter.limitsAtInit", "= false, if limits are ignored during initializiation (i.e., y=u)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CCC.limiter.u", "Connector of Real input signal [1]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("CCC.limiter.y", "Connector of Real output signal [1]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("CCC.with_I", "", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("CCC.with_D", "", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("CCC.Dzero.k", "Constant output value", 155, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("CCC.Dzero.y", "Connector of Real output signal", "CCC.Dzero.k", 1,\
 7, 155, 0)
DeclareParameter("Tssp.k", "Constant output value", 156, 288.15, 0.0,0.0,0.0,0,560)
DeclareAlias2("Tssp.y", "Connector of Real output signal", "Tssp.k", 1, 7, 156, 0)
DeclareAlias2("HCC.u_s", "Connector of setpoint input signal [K]", "Tssp1.k", 1,\
 7, 281, 0)
DeclareAlias2("HCC.u_m", "Connector of measurement input signal [K]", \
"HCC.addP.u2", 1, 5, 506, 0)
DeclareAlias2("HCC.y", "Connector of actuator output signal [1]", \
"HCC.limiter.y", 1, 5, 516, 0)
DeclareVariable("HCC.controlError", "Control error (set point - measurement) [K]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("HCC.controllerType", "Type of controller", 2, 1.0,4.0,0.0,0,517)
DeclareParameter("HCC.k", "Gain of controller", 157, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("HCC.Ti", "Time constant of Integrator block [s]", 158, 60, \
1E-060,1E+100,0.0,0,560)
DeclareParameter("HCC.Td", "Time constant of Derivative block [s]", 159, 60, 0.0,\
1E+100,0.0,0,560)
DeclareParameter("HCC.yMax", "Upper limit of output [1]", 160, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.yMin", "Lower limit of output [1]", 161, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.wp", "Set-point weight for Proportional block (0..1)", 162,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("HCC.wd", "Set-point weight for Derivative block (0..1)", 163, 0,\
 0.0,1E+100,0.0,0,560)
DeclareParameter("HCC.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 164, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("HCC.Nd", "The higher Nd, the more ideal the derivative block",\
 165, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("HCC.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("HCC.limitsAtInit", "= false, if limits are ignored during initializiation",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("HCC.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 166, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.xd_start", "Initial or guess value for state of derivative block",\
 167, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.y_start", "Initial value of output [1]", 168, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("HCC.addP.u1", "Connector of Real input signal 1 [K]", "Tssp1.k", 1,\
 7, 281, 0)
DeclareVariable("HCC.addP.u2", "Connector of Real input signal 2 [K]", 0, 0.0,\
1E+100,0.0,0,512)
DeclareVariable("HCC.addP.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("HCC.addP.k1", "Gain of upper input", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("HCC.addP.k2", "Gain of lower input", 169, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.P.k", "Gain value multiplied with input signal", 170, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("HCC.P.u", "Input signal connector", "HCC.addP.y", 1, 5, 507, 0)
DeclareAlias2("HCC.P.y", "Output signal connector", "HCC.addPID.u1", 1, 5, 511, 0)
DeclareVariable("HCC.gainPID.k", "Gain value multiplied with input signal", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("HCC.gainPID.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("HCC.gainPID.y", "Output signal connector [1]", "HCC.limiter.u", 1,\
 5, 515, 0)
DeclareParameter("HCC.addPID.k1", "Gain of upper input", 171, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.addPID.k2", "Gain of middle input", 172, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.addPID.k3", "Gain of lower input", 173, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("HCC.addPID.u1", "Connector 1 of Real input signals", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("HCC.addPID.u2", "Connector 2 of Real input signals", \
"HCC.Dzero.k", 1, 7, 174, 0)
DeclareAlias2("HCC.addPID.u3", "Connector 3 of Real input signals", "HCC.I.y", 1,\
 1, 9, 0)
DeclareAlias2("HCC.addPID.y", "Connector of Real output signals", \
"HCC.gainPID.u", 1, 5, 510, 0)
DeclareVariable("HCC.limiter.uMax", "Upper limits of input signals [1]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("HCC.limiter.uMin", "Lower limits of input signals [1]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("HCC.limiter.limitsAtInit", "= false, if limits are ignored during initializiation (i.e., y=u)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("HCC.limiter.u", "Connector of Real input signal [1]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("HCC.limiter.y", "Connector of Real output signal [1]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("HCC.with_I", "", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("HCC.with_D", "", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("HCC.Dzero.k", "Constant output value", 174, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("HCC.Dzero.y", "Connector of Real output signal", "HCC.Dzero.k", 1,\
 7, 174, 0)
DeclareAlias2("RHCC.u_s", "Connector of setpoint input signal [K]", "Th.k", 1, 7,\
 280, 0)
DeclareAlias2("RHCC.u_m", "Connector of measurement input signal [K]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareAlias2("RHCC.y", "Connector of actuator output signal [1]", "RHC.u", 1, 5,\
 464, 0)
DeclareVariable("RHCC.controlError", "Control error (set point - measurement) [K]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("RHCC.controllerType", "Type of controller", 2, 1.0,4.0,0.0,0,517)
DeclareParameter("RHCC.k", "Gain of controller", 175, 1.5, 0.0,1E+100,0.0,0,560)
DeclareParameter("RHCC.Ti", "Time constant of Integrator block [s]", 176, 60, \
1E-060,1E+100,0.0,0,560)
DeclareParameter("RHCC.Td", "Time constant of Derivative block [s]", 177, 60, \
0.0,1E+100,0.0,0,560)
DeclareParameter("RHCC.yMax", "Upper limit of output [1]", 178, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.yMin", "Lower limit of output [1]", 179, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.wp", "Set-point weight for Proportional block (0..1)", 180,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("RHCC.wd", "Set-point weight for Derivative block (0..1)", 181,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("RHCC.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 182, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("RHCC.Nd", "The higher Nd, the more ideal the derivative block",\
 183, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("RHCC.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("RHCC.limitsAtInit", "= false, if limits are ignored during initializiation",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("RHCC.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 184, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.xd_start", "Initial or guess value for state of derivative block",\
 185, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.y_start", "Initial value of output [1]", 186, 0, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("RHCC.addP.u1", "Connector of Real input signal 1 [K]", "Th.k", 1,\
 7, 280, 0)
DeclareAlias2("RHCC.addP.u2", "Connector of Real input signal 2 [K]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareVariable("RHCC.addP.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("RHCC.addP.k1", "Gain of upper input", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("RHCC.addP.k2", "Gain of lower input", 187, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.P.k", "Gain value multiplied with input signal", 188, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("RHCC.P.u", "Input signal connector", "RHCC.addP.y", 1, 5, 523, 0)
DeclareAlias2("RHCC.P.y", "Output signal connector", "RHCC.addPID.u1", 1, 5, 527,\
 0)
DeclareVariable("RHCC.gainPID.k", "Gain value multiplied with input signal", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("RHCC.gainPID.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("RHCC.gainPID.y", "Output signal connector [1]", "RHCC.limiter.u", 1,\
 5, 531, 0)
DeclareParameter("RHCC.addPID.k1", "Gain of upper input", 189, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.addPID.k2", "Gain of middle input", 190, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.addPID.k3", "Gain of lower input", 191, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("RHCC.addPID.u1", "Connector 1 of Real input signals", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("RHCC.addPID.u2", "Connector 2 of Real input signals", \
"RHCC.Dzero.k", 1, 7, 192, 0)
DeclareAlias2("RHCC.addPID.u3", "Connector 3 of Real input signals", "RHCC.I.y", 1,\
 1, 10, 0)
DeclareAlias2("RHCC.addPID.y", "Connector of Real output signals", \
"RHCC.gainPID.u", 1, 5, 526, 0)
DeclareVariable("RHCC.limiter.uMax", "Upper limits of input signals [1]", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("RHCC.limiter.uMin", "Lower limits of input signals [1]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("RHCC.limiter.limitsAtInit", "= false, if limits are ignored during initializiation (i.e., y=u)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("RHCC.limiter.u", "Connector of Real input signal [1]", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("RHCC.limiter.y", "Connector of Real output signal [1]", "RHC.u", 1,\
 5, 464, 0)
DeclareVariable("RHCC.with_I", "", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("RHCC.with_D", "", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("RHCC.Dzero.k", "Constant output value", 192, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("RHCC.Dzero.y", "Connector of Real output signal", "RHCC.Dzero.k", 1,\
 7, 192, 0)
DeclareAlias2("FanC.u_s", "Connector of setpoint input signal [Pa]", "Prsp.k", 1,\
 7, 211, 0)
DeclareAlias2("FanC.u_m", "Connector of measurement input signal [Pa]", \
"SupF.medium.p", 1, 5, 83, 0)
DeclareAlias2("FanC.y", "Connector of actuator output signal", "FanC.limiter.y", 1,\
 5, 547, 0)
DeclareVariable("FanC.controlError", "Control error (set point - measurement) [Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("FanC.controllerType", "Type of controller", 2, 1.0,4.0,0.0,0,517)
DeclareParameter("FanC.k", "Gain of controller", 193, 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("FanC.Ti", "Time constant of Integrator block [s]", 194, 60, \
1E-060,1E+100,0.0,0,560)
DeclareParameter("FanC.Td", "Time constant of Derivative block [s]", 195, 60, \
0.0,1E+100,0.0,0,560)
DeclareParameter("FanC.yMax", "Upper limit of output", 196, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.yMin", "Lower limit of output", 197, 0.3, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.wp", "Set-point weight for Proportional block (0..1)", 198,\
 1, 0.0,1E+100,0.0,0,560)
DeclareParameter("FanC.wd", "Set-point weight for Derivative block (0..1)", 199,\
 0, 0.0,1E+100,0.0,0,560)
DeclareParameter("FanC.Ni", "Ni*Ti is time constant of anti-windup compensation",\
 200, 0.9, 1E-013,1E+100,0.0,0,560)
DeclareParameter("FanC.Nd", "The higher Nd, the more ideal the derivative block",\
 201, 10, 1E-013,1E+100,0.0,0,560)
DeclareVariable("FanC.initType", "Type of initialization (1: no init, 2: steady state, 3: initial state, 4: initial output)",\
 5, 1.0,5.0,0.0,0,517)
DeclareVariable("FanC.limitsAtInit", "= false, if limits are ignored during initializiation",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("FanC.xi_start", "Initial or guess value value for integrator output (= integrator state)",\
 202, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.xd_start", "Initial or guess value for state of derivative block",\
 203, 0, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.y_start", "Initial value of output", 204, 0, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("FanC.addP.u1", "Connector of Real input signal 1 [Pa]", "Prsp.k", 1,\
 7, 211, 0)
DeclareAlias2("FanC.addP.u2", "Connector of Real input signal 2 [Pa]", \
"SupF.medium.p", 1, 5, 83, 0)
DeclareVariable("FanC.addP.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("FanC.addP.k1", "Gain of upper input", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("FanC.addP.k2", "Gain of lower input", 205, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.P.k", "Gain value multiplied with input signal", 206, 1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("FanC.P.u", "Input signal connector", "FanC.addP.y", 1, 5, 538, 0)
DeclareAlias2("FanC.P.y", "Output signal connector", "FanC.addPID.u1", 1, 5, 542,\
 0)
DeclareVariable("FanC.gainPID.k", "Gain value multiplied with input signal", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("FanC.gainPID.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("FanC.gainPID.y", "Output signal connector", "FanC.limiter.u", 1, 5,\
 546, 0)
DeclareParameter("FanC.addPID.k1", "Gain of upper input", 207, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.addPID.k2", "Gain of middle input", 208, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.addPID.k3", "Gain of lower input", 209, 1, 0.0,0.0,0.0,0,560)
DeclareVariable("FanC.addPID.u1", "Connector 1 of Real input signals", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("FanC.addPID.u2", "Connector 2 of Real input signals", \
"FanC.Dzero.k", 1, 7, 210, 0)
DeclareAlias2("FanC.addPID.u3", "Connector 3 of Real input signals", "FanC.I.y", 1,\
 1, 11, 0)
DeclareAlias2("FanC.addPID.y", "Connector of Real output signals", \
"FanC.gainPID.u", 1, 5, 541, 0)
DeclareVariable("FanC.limiter.uMax", "Upper limits of input signals", 1, \
0.0,0.0,0.0,0,513)
DeclareVariable("FanC.limiter.uMin", "Lower limits of input signals", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("FanC.limiter.limitsAtInit", "= false, if limits are ignored during initializiation (i.e., y=u)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("FanC.limiter.u", "Connector of Real input signal", 0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("FanC.limiter.y", "Connector of Real output signal", 0, 0.0,1.0,\
0.0,0,512)
DeclareVariable("FanC.with_I", "", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("FanC.with_D", "", false, 0.0,0.0,0.0,0,1539)
DeclareParameter("FanC.Dzero.k", "Constant output value", 210, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("FanC.Dzero.y", "Connector of Real output signal", "FanC.Dzero.k", 1,\
 7, 210, 0)
DeclareVariable("pressure.port.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("pressure.port.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "SupF.medium.p", 1, 5, 83, 4)
DeclareVariable("pressure.port.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,521)
DeclareAlias2("pressure.p", "Pressure at port [Pa|bar]", "SupF.medium.p", 1, 5, 83,\
 0)
DeclareParameter("Prsp.k", "Constant output value [Pa]", 211, 101575, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("Prsp.y", "Connector of Real output signal [Pa]", "Prsp.k", 1, 7, 211,\
 0)
DeclareParameter("Q_rhc_d", "Heat flow rate at u=1, positive for heating [W]", 212,\
 20000, 0.0,0.0,0.0,0,560)
DeclareParameter("dp_rhc_d", "Pressure [Pa|bar]", 213, 87, 0.0,0.0,0.0,0,560)
DeclareVariable("dp_fil_d", "filter design pressure drop [Pa|bar]", 100, \
0.0,0.0,0.0,0,513)
DeclareVariable("gain.k", "Gain value multiplied with input signal [kg/s]", 1, \
0.0,0.0,0.0,0,513)
DeclareAlias2("gain.u", "Input signal connector [1]", "HCC.limiter.y", 1, 5, 516,\
 0)
DeclareAlias2("gain.y", "Output signal connector [kg/s]", "HC.m2_flow", 1, 5, 848,\
 0)
DeclareVariable("Amb1.nPorts", "Number of ports", 1, 0.0,0.0,0.0,0,517)
DeclareVariable("Amb1.medium.p", "Absolute pressure of medium [Pa|bar]", 100000,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("Amb1.medium.h", "Specific enthalpy of medium [J/kg]", 83680.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("Amb1.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("Amb1.medium.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("Amb1.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("Amb1.medium.u", "Specific internal energy of medium [J/kg]", \
83680.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("Amb1.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,1000000.0,1000.0,0,513)
DeclareVariable("Amb1.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareVariable("Amb1.medium.state.p", "Absolute pressure of medium [Pa|bar]", 100000,\
 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Amb1.medium.state.T", "Temperature of medium [K|degC]", 293.15,\
 1.0,10000.0,300.0,0,513)
DeclareVariable("Amb1.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Amb1.medium.standardOrderComponents", "if true, and reducedX = true, the last element of X will be computed from the other ones",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Amb1.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 20.0, 0.0,0.0,0.0,0,513)
DeclareVariable("Amb1.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("Amb1.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "HC.m2_flow", 1, 5, 848, 132)
DeclareVariable("Amb1.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100000, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("Amb1.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -100000000.0,100000000.0,1000000.0,0,521)
DeclareVariable("Amb1.flowDirection", "Allowed flow direction", 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("Amb1.use_p_in", "Get the pressure from the input connector", \
false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb1.use_T_in", "Get the temperature from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb1.use_X_in", "Get the composition from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb1.use_C_in", "Get the trace substances from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb1.p", "Fixed value of pressure [Pa|bar]", 100000, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("Amb1.T", "Fixed value of temperature [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("Amb1.X[1]", "Fixed value of composition [kg/kg]", 1, 0.0,1.0,\
0.1,0,513)
DeclareVariable("Amb1.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 100000, 0.0,0.0,0.0,0,2561)
DeclareVariable("Amb1.T_in_internal", "Needed to connect to conditional connector [K]",\
 293.15, 0.0,0.0,0.0,0,2561)
DeclareVariable("Amb1.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("Amb2.nPorts", "Number of ports", 1, 0.0,0.0,0.0,0,517)
DeclareVariable("Amb2.medium.p", "Absolute pressure of medium [Pa|bar]", 100000,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("Amb2.medium.h", "Specific enthalpy of medium [J/kg]", 83680.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("Amb2.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, 0.0,\
100000.0,1.0,0,513)
DeclareVariable("Amb2.medium.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("Amb2.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("Amb2.medium.u", "Specific internal energy of medium [J/kg]", \
83680.0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("Amb2.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,1000000.0,1000.0,0,513)
DeclareVariable("Amb2.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareVariable("Amb2.medium.state.p", "Absolute pressure of medium [Pa|bar]", 100000,\
 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Amb2.medium.state.T", "Temperature of medium [K|degC]", 293.15,\
 1.0,10000.0,300.0,0,513)
DeclareVariable("Amb2.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Amb2.medium.standardOrderComponents", "if true, and reducedX = true, the last element of X will be computed from the other ones",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Amb2.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 20.0, 0.0,0.0,0.0,0,513)
DeclareVariable("Amb2.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 1, 0.0,0.0,0.0,0,513)
DeclareAlias2("Amb2.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CC.m2_flow", 1, 5, 894, 132)
DeclareVariable("Amb2.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100000, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("Amb2.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 83680.0, -100000000.0,100000000.0,1000000.0,0,521)
DeclareVariable("Amb2.flowDirection", "Allowed flow direction", 3, 1.0,3.0,0.0,0,2565)
DeclareVariable("Amb2.use_p_in", "Get the pressure from the input connector", \
false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb2.use_T_in", "Get the temperature from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb2.use_X_in", "Get the composition from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb2.use_C_in", "Get the trace substances from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("Amb2.p", "Fixed value of pressure [Pa|bar]", 100000, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("Amb2.T", "Fixed value of temperature [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("Amb2.X[1]", "Fixed value of composition [kg/kg]", 1, 0.0,1.0,\
0.1,0,513)
DeclareVariable("Amb2.p_in_internal", "Needed to connect to conditional connector [Pa]",\
 100000, 0.0,0.0,0.0,0,2561)
DeclareVariable("Amb2.T_in_internal", "Needed to connect to conditional connector [K]",\
 293.15, 0.0,0.0,0.0,0,2561)
DeclareVariable("Amb2.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("chiller.nPorts", "Number of ports", 1, 0.0,0.0,0.0,0,517)
DeclareAlias2("chiller.medium.p", "Absolute pressure of medium [Pa|bar]", \
"CC.port_a2.p", 1, 5, 880, 0)
DeclareAlias2("chiller.medium.h", "Specific enthalpy of medium [J/kg]", \
"chiller.ports[1].h_outflow", 1, 5, 620, 0)
DeclareVariable("chiller.medium.d", "Density of medium [kg/m3|g/cm3]", 995.586, \
0.0,100000.0,1.0,0,513)
DeclareAlias2("chiller.medium.T", "Temperature of medium [K|degC]", "chiller.T", 1,\
 5, 627, 0)
DeclareVariable("chiller.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("chiller.medium.u", "Specific internal energy of medium [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,513)
DeclareVariable("chiller.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 0, 0.0,1000000.0,1000.0,0,513)
DeclareVariable("chiller.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.018015268, 0.001,0.25,0.032,0,513)
DeclareAlias2("chiller.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
"CC.port_a2.p", 1, 5, 880, 0)
DeclareAlias2("chiller.medium.state.T", "Temperature of medium [K|degC]", \
"chiller.T", 1, 5, 627, 0)
DeclareVariable("chiller.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("chiller.medium.standardOrderComponents", "if true, and reducedX = true, the last element of X will be computed from the other ones",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("chiller.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("chiller.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("chiller.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CC.m2_flow", -1, 5, 894, 132)
DeclareAlias2("chiller.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "CC.port_a2.p", 1, 5, 880, 4)
DeclareVariable("chiller.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,521)
DeclareVariable("chiller.flowDirection", "Allowed flow direction", 3, 1.0,3.0,\
0.0,0,2565)
DeclareVariable("chiller.use_m_flow_in", "Get the mass flow rate from the input connector",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("chiller.use_T_in", "Get the temperature from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chiller.use_X_in", "Get the composition from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chiller.use_C_in", "Get the trace substances from the input connector",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("chiller.m_flow", "Fixed mass flow rate going out of the fluid port [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("chiller.T", "Fixed value of temperature [K|degC]", 300, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("chiller.X[1]", "Fixed value of composition [kg/kg]", 1, 0.0,1.0,\
0.1,0,513)
DeclareAlias2("chiller.m_flow_in", "Prescribed mass flow rate [kg/s]", \
"CC.m2_flow", 1, 5, 894, 0)
DeclareAlias2("chiller.m_flow_in_internal", "Needed to connect to conditional connector [kg/s]",\
 "CC.m2_flow", 1, 5, 894, 1024)
DeclareAlias2("chiller.T_in_internal", "Needed to connect to conditional connector [K]",\
 "chiller.T", 1, 5, 627, 1024)
DeclareVariable("chiller.X_in_internal[1]", "Needed to connect to conditional connector [1]",\
 1, 0.0,0.0,0.0,0,2561)
DeclareVariable("gain1.k", "Gain value multiplied with input signal [kg/s]", \
-2.31, 0.0,0.0,0.0,0,513)
DeclareAlias2("gain1.u", "Input signal connector [1]", "CCC.limiter.y", 1, 5, 499,\
 0)
DeclareAlias2("gain1.y", "Output signal connector [kg/s]", "CC.m2_flow", 1, 5, 894,\
 0)
DeclareAlias2("del.fluidVolume", "Volume [m3]", "del.V", 1, 5, 699, 0)
DeclareVariable("del.energyDynamics", "Formulation of energy balance", 1, 1.0,\
4.0,0.0,0,517)
DeclareVariable("del.massDynamics", "Formulation of mass balance", 1, 1.0,4.0,\
0.0,0,517)
DeclareVariable("del.substanceDynamics", "Formulation of substance balance", 1, \
1.0,4.0,0.0,0,517)
DeclareVariable("del.traceDynamics", "Formulation of trace substance balance", 1,\
 1.0,4.0,0.0,0,517)
DeclareVariable("del.p_start", "Start value of pressure [Pa|bar]", 100000.0, 0.0,\
100000000.0,100000.0,0,513)
DeclareVariable("del.use_T_start", "= true, use T_start, otherwise h_start", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("del.T_start", "Start value of temperature [K|degC]", 300, 1.0,\
10000.0,300.0,0,513)
DeclareVariable("del.h_start", "Start value of specific enthalpy [J/kg]", 0, \
-100000000.0,100000000.0,1000000.0,0,513)
DeclareParameter("del.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 214, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("del.medium.p", "Absolute pressure of medium [Pa|bar]", 0, 0.0,\
100000000.0,100000.0,0,512)
DeclareVariable("del.medium.h", "Specific enthalpy of medium [J/kg]", 0, \
-100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("del.medium.d", "Density of medium [kg/m3|g/cm3]", 1, 0.0,\
100000.0,1.0,0,512)
DeclareVariable("del.medium.T", "Temperature of medium [K|degC]", 300.0, 1.0,\
10000.0,300.0,0,512)
DeclareVariable("del.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("del.medium.u", "Specific internal energy of medium [J/kg]", 0, \
-100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("del.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 287.051224952979, 0.0,1000000.0,1000.0,0,513)
DeclareVariable("del.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.0289651159, 0.001,0.25,0.032,0,513)
DeclareAlias2("del.medium.state.p", "Absolute pressure of medium [Pa|bar]", \
"del.medium.p", 1, 5, 639, 0)
DeclareAlias2("del.medium.state.T", "Temperature of medium [K|degC]", \
"del.medium.T", 1, 5, 642, 0)
DeclareVariable("del.medium.constantDensity", "= true if the mass density should be constant at dStp",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("del.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("del.medium.standardOrderComponents", "if true, and reducedX = true, the last element of X will be computed from the other ones",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("del.medium.T_degC", "Temperature of medium in [degC] [degC;]", 0,\
 0.0,0.0,0.0,0,512)
DeclareVariable("del.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0, 0.0,0.0,0.0,0,512)
DeclareState("del.U", "Internal energy of fluid [J]", 0, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("del.der(U)", "der(Internal energy of fluid) [J/s]", 0, \
0.0,0.0,0.0,0,512)
DeclareState("del.m", "Mass of fluid [kg]", 1, 0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("del.der(m)", "der(Mass of fluid) [kg/s]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("del.mb_flow", "Mass flows across boundaries [kg/s]", "del.der(m)", 1,\
 6, 1, 0)
DeclareAlias2("del.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 "del.der(U)", 1, 6, 0, 0)
DeclareVariable("del.Qb_flow", "Heat flow across boundaries or energy source/sink [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.Wb_flow", "Work flow across boundaries or source term [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareParameter("del.initialize_p", "= true to set up initial equations for pressure",\
 215, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("del.nPorts", "Number of ports", 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("del.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Sup.m_flow", -1, 5, 381, 132)
DeclareAlias2("del.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 4)
DeclareAlias2("del.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "del.medium.h", 1, 5, 640, 4)
DeclareAlias2("del.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", -1, 5, 803, 132)
DeclareAlias2("del.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 4)
DeclareAlias2("del.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "del.medium.h", 1, 5, 640, 4)
DeclareVariable("del.ports[3].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, -100000.0,100000.0,0.0,0,777)
DeclareAlias2("del.ports[3].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 4)
DeclareAlias2("del.ports[3].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "del.medium.h", 1, 5, 640, 4)
DeclareVariable("del.use_portsData", "= false to neglect pressure loss and kinetic energy",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("del.m_flow_small", "Regularization range at zero mass flow rate [kg/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("del.ports_H_flow[1]", "[W]", 0, -100000000.0,100000000.0,1000.0,\
0,512)
DeclareVariable("del.ports_H_flow[2]", "[W]", 0, -100000000.0,100000000.0,1000.0,\
0,512)
DeclareVariable("del.ports_H_flow[3]", "[W]", 0, -100000000.0,100000000.0,1000.0,\
0,513)
DeclareVariable("del.use_HeatTransfer", "= true to use the HeatTransfer model", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("del.heatTransfer.n", "Number of heat transfer segments", 1, \
0.0,0.0,0.0,0,517)
DeclareAlias2("del.heatTransfer.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 0)
DeclareAlias2("del.heatTransfer.states[1].T", "Temperature of medium [K|degC]", \
"del.medium.T", 1, 5, 642, 0)
DeclareVariable("del.heatTransfer.surfaceAreas[1]", "Heat transfer areas [m2]", 0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("del.heatTransfer.Q_flows[1]", "Heat flow rates [W]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("del.heatTransfer.use_k", "= true to use k value for thermal isolation",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("del.heatTransfer.k", "Heat transfer coefficient to ambient [W/(m2.K)]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.heatTransfer.T_ambient", "Ambient temperature [K|degC]", 0,\
 0.0,1E+100,0.0,0,513)
DeclareAlias2("del.heatTransfer.heatPorts[1].T", "Port temperature [K|degC]", \
"del.medium.T", 1, 5, 642, 4)
DeclareVariable("del.heatTransfer.heatPorts[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("del.heatTransfer.Ts[1]", "Temperatures defined by fluid states [K|degC]",\
 "del.medium.T", 1, 5, 642, 0)
DeclareAlias2("del.portDensities[1]", "densites of the fluid at the device boudary [kg/m3|g/cm3]",\
 "del.medium.d", 1, 5, 641, 0)
DeclareAlias2("del.portDensities[2]", "densites of the fluid at the device boudary [kg/m3|g/cm3]",\
 "del.medium.d", 1, 5, 641, 0)
DeclareAlias2("del.portDensities[3]", "densites of the fluid at the device boudary [kg/m3|g/cm3]",\
 "del.medium.d", 1, 5, 641, 0)
DeclareVariable("del.portVelocities[1]", "velocities of fluid flow at device boundary [m/s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.portVelocities[2]", "velocities of fluid flow at device boundary [m/s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.portVelocities[3]", "velocities of fluid flow at device boundary [m/s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.ports_E_flow[1]", "flow of kinetic and potential energy at device boundary [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.ports_E_flow[2]", "flow of kinetic and potential energy at device boundary [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.ports_E_flow[3]", "flow of kinetic and potential energy at device boundary [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.s[1]", "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices [m]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.s[2]", "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices [m]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.s[3]", "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices [m]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.ports_penetration[1]", "penetration of port with fluid, depending on fluid level and port diameter",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("del.ports_penetration[2]", "penetration of port with fluid, depending on fluid level and port diameter",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("del.ports_penetration[3]", "penetration of port with fluid, depending on fluid level and port diameter",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("del.portAreas[1]", "[m2]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.portAreas[2]", "[m2]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.portAreas[3]", "[m2]", 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("del.vessel_ps_static[1]", "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 0)
DeclareAlias2("del.vessel_ps_static[2]", "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 0)
DeclareAlias2("del.vessel_ps_static[3]", "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity [Pa|bar]",\
 "del.medium.p", 1, 5, 639, 0)
DeclareVariable("del.fluidLevel", "level of fluid in the vessel for treating heights of ports [m]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("del.fluidLevel_max", "maximum level of fluid in the vessel [m]",\
 1, 0.0,1E+100,0.0,0,2561)
DeclareVariable("del.vesselArea", "Area of the vessel used to relate to cross flow area of ports [m2]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_diameter[1]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_diameter[2]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_diameter[3]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_height[1]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_height[2]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_height[3]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_zeta_in[1]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_zeta_in[2]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_zeta_in[3]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_zeta_out[1]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_zeta_out[2]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.portsData_zeta_out[3]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("del.V", "Volume [m3]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("del.sta0.p", "Absolute pressure of medium [Pa|bar]", 100000.0, \
0.0,100000000.0,100000.0,0,2561)
DeclareVariable("del.sta0.T", "Temperature of medium [K|degC]", 300, 1.0,10000.0,\
300.0,0,2561)
DeclareVariable("del.rho_nominal", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareParameter("del.tau", "Time constant at nominal flow [s]", 216, 20, \
0.0,0.0,0.0,0,560)
DeclareVariable("del.m_flow_nominal", "Mass flow rate [kg/s]", 2.31, 0.0,1E+100,\
0.0,0,513)
DeclareVariable("del.V0", "Volume of delay element [m3]", 0, 0.0,0.0,0.0,0,2561)
DeclareParameter("room.system.p_ambient", "Default ambient pressure [Pa|bar]", 217,\
 101325, 0.0,1E+100,0.0,0,560)
DeclareParameter("room.system.T_ambient", "Default ambient temperature [K|degC]",\
 218, 293.15, 0.0,1E+100,0.0,0,560)
DeclareParameter("room.system.g", "Constant gravity acceleration [m/s2]", 219, \
9.80665, 0.0,0.0,0.0,0,560)
DeclareVariable("room.system.allowFlowReversal", "= false to restrict to design flow direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("room.system.energyDynamics", "Default formulation of energy balances",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("room.system.massDynamics", "Default formulation of mass balances",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("room.system.substanceDynamics", "Default formulation of substance balances",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("room.system.traceDynamics", "Default formulation of trace substance balances",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("room.system.momentumDynamics", "Default formulation of momentum balances, if options available",\
 4, 1.0,4.0,0.0,0,517)
DeclareParameter("room.system.m_flow_start", "Default start value for mass flow rates [kg/s]",\
 220, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("room.system.p_start", "Default start value for pressures [Pa|bar]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("room.system.T_start", "Default start value for temperatures [K|degC]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("room.system.m_flow_small", "Default small laminar mass flow rate for regularization of zero flow [kg/s]",\
 221, 0.01, 0.0,1E+100,0.0,0,560)
DeclareParameter("room.system.dp_small", "Default small pressure drop for regularization of laminar and zero flow [Pa|bar]",\
 222, 1, 0.0,1E+100,0.0,0,560)
DeclareVariable("room.nPorts", "Number of ports", 2, 0.0,0.0,0.0,0,517)
DeclareVariable("room.VRoo", "Room volume [m3]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.UA", "UA value of room [W/K]", 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("room.vol.fluidVolume", "Volume [m3]", "room.vol.V", 1, 5, 770, 0)
DeclareVariable("room.vol.energyDynamics", "Formulation of energy balance", 2, \
1.0,4.0,0.0,0,517)
DeclareVariable("room.vol.massDynamics", "Formulation of mass balance", 2, 1.0,\
4.0,0.0,0,517)
DeclareVariable("room.vol.substanceDynamics", "Formulation of substance balance",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("room.vol.traceDynamics", "Formulation of trace substance balance",\
 2, 1.0,4.0,0.0,0,517)
DeclareParameter("room.vol.p_start", "Start value of pressure [Pa|bar]", 223, 100000,\
 0.0,100000000.0,100000.0,0,560)
DeclareVariable("room.vol.use_T_start", "= true, use T_start, otherwise h_start",\
 true, 0.0,0.0,0.0,0,515)
DeclareParameter("room.vol.T_start", "Start value of temperature [K|degC]", 224,\
 293.15, 1.0,10000.0,300.0,0,560)
DeclareVariable("room.vol.h_start", "Start value of specific enthalpy [J/kg]", 0,\
 -100000000.0,100000000.0,1000000.0,0,513)
DeclareParameter("room.vol.X_start[1]", "Start value of mass fractions m_i/m [kg/kg]",\
 225, 1, 0.0,1.0,0.1,0,560)
DeclareVariable("room.vol.medium.p", "Absolute pressure of medium [Pa|bar]", 0, \
0.0,100000000.0,100000.0,0,512)
DeclareVariable("room.vol.medium.h", "Specific enthalpy of medium [J/kg]", 0, \
-100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("room.vol.medium.d", "Density of medium [kg/m3|g/cm3]", 1, 0.0,\
100000.0,1.0,0,512)
DeclareAlias2("room.vol.medium.T", "Temperature of medium [K|degC]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareVariable("room.vol.medium.X[1]", "Mass fractions (= (component mass)/total mass  m_i/m) [kg/kg]",\
 1, 0.0,1.0,0.1,0,513)
DeclareVariable("room.vol.medium.u", "Specific internal energy of medium [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,512)
DeclareVariable("room.vol.medium.R", "Gas constant (of mixture if applicable) [J/(kg.K)]",\
 287.051224952979, 0.0,1000000.0,1000.0,0,513)
DeclareVariable("room.vol.medium.MM", "Molar mass (of mixture or single fluid) [kg/mol]",\
 0.0289651159, 0.001,0.25,0.032,0,513)
DeclareAlias2("room.vol.medium.state.p", "Absolute pressure of medium [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 0)
DeclareAlias2("room.vol.medium.state.T", "Temperature of medium [K|degC]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareVariable("room.vol.medium.constantDensity", "= true if the mass density should be constant at dStp",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("room.vol.medium.preferredMediumStates", "= true if StateSelect.prefer shall be used for the independent property variables of the medium",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("room.vol.medium.standardOrderComponents", "if true, and reducedX = true, the last element of X will be computed from the other ones",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("room.vol.medium.T_degC", "Temperature of medium in [degC] [degC;]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("room.vol.medium.p_bar", "Absolute pressure of medium in [bar] [bar]",\
 0, 0.0,0.0,0.0,0,512)
DeclareState("room.vol.U", "Internal energy of fluid [J]", 2, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("room.vol.der(U)", "der(Internal energy of fluid) [J/s]", 0, \
0.0,0.0,0.0,0,512)
DeclareState("room.vol.m", "Mass of fluid [kg]", 3, 0, 0.0,1E+100,0.0,0,544)
DeclareDerivative("room.vol.der(m)", "der(Mass of fluid) [kg/s]", 0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("room.vol.mb_flow", "Mass flows across boundaries [kg/s]", \
"room.vol.der(m)", 1, 6, 3, 0)
DeclareVariable("room.vol.Hb_flow", "Enthalpy flow across boundaries or energy source/sink [W]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("room.vol.Qb_flow", "Heat flow across boundaries or energy source/sink [W]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("room.vol.Wb_flow", "Work flow across boundaries or source term [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.initialize_p", "= true to set up initial equations for pressure",\
 true, 0.0,0.0,0.0,0,2563)
DeclareVariable("room.vol.nPorts", "Number of ports", 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("room.vol.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Ret.m_flow", -1, 5, 380, 132)
DeclareAlias2("room.vol.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 4)
DeclareAlias2("room.vol.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "room.vol.medium.h", 1, 5, 723, 4)
DeclareAlias2("room.vol.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareAlias2("room.vol.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 4)
DeclareAlias2("room.vol.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "room.vol.medium.h", 1, 5, 723, 4)
DeclareVariable("room.vol.use_portsData", "= false to neglect pressure loss and kinetic energy",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("room.vol.m_flow_small", "Regularization range at zero mass flow rate [kg/s]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("room.vol.ports_H_flow[1]", "[W]", 0, -100000000.0,100000000.0,\
1000.0,0,512)
DeclareVariable("room.vol.ports_H_flow[2]", "[W]", 0, -100000000.0,100000000.0,\
1000.0,0,512)
DeclareVariable("room.vol.use_HeatTransfer", "= true to use the HeatTransfer model",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("room.vol.heatTransfer.n", "Number of heat transfer segments", 1,\
 0.0,0.0,0.0,0,517)
DeclareAlias2("room.vol.heatTransfer.states[1].p", "Absolute pressure of medium [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 0)
DeclareAlias2("room.vol.heatTransfer.states[1].T", "Temperature of medium [K|degC]",\
 "cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareVariable("room.vol.heatTransfer.surfaceAreas[1]", "Heat transfer areas [m2]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("room.vol.heatTransfer.Q_flows[1]", "Heat flow rates [W]", \
"room.vol.Qb_flow", 1, 5, 735, 0)
DeclareVariable("room.vol.heatTransfer.use_k", "= true to use k value for thermal isolation",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("room.vol.heatTransfer.k", "Heat transfer coefficient to ambient [W/(m2.K)]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.heatTransfer.T_ambient", "Ambient temperature [K|degC]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareAlias2("room.vol.heatTransfer.heatPorts[1].T", "Port temperature [K|degC]",\
 "cliBCVTB.uR[1]", 1, 5, 933, 4)
DeclareAlias2("room.vol.heatTransfer.heatPorts[1].Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.vol.Qb_flow", 1, 5, 735, 132)
DeclareAlias2("room.vol.heatTransfer.Ts[1]", "Temperatures defined by fluid states [K|degC]",\
 "cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareAlias2("room.vol.heatPort.T", "Port temperature [K|degC]", \
"cliBCVTB.uR[1]", 1, 5, 933, 4)
DeclareAlias2("room.vol.heatPort.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.vol.Qb_flow", 1, 5, 735, 132)
DeclareAlias2("room.vol.portDensities[1]", "densites of the fluid at the device boudary [kg/m3|g/cm3]",\
 "room.vol.medium.d", 1, 5, 724, 0)
DeclareAlias2("room.vol.portDensities[2]", "densites of the fluid at the device boudary [kg/m3|g/cm3]",\
 "room.vol.medium.d", 1, 5, 724, 0)
DeclareVariable("room.vol.portVelocities[1]", "velocities of fluid flow at device boundary [m/s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.portVelocities[2]", "velocities of fluid flow at device boundary [m/s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.ports_E_flow[1]", "flow of kinetic and potential energy at device boundary [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.ports_E_flow[2]", "flow of kinetic and potential energy at device boundary [W]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.s[1]", "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices [m]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.s[2]", "curve parameters for port flows vs. port pressures; for further details see, Modelica Tutorial: Ideal switching devices [m]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.ports_penetration[1]", "penetration of port with fluid, depending on fluid level and port diameter",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.ports_penetration[2]", "penetration of port with fluid, depending on fluid level and port diameter",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.portAreas[1]", "[m2]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.portAreas[2]", "[m2]", 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("room.vol.vessel_ps_static[1]", "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 0)
DeclareAlias2("room.vol.vessel_ps_static[2]", "static pressures inside the vessel at the height of the corresponding ports, zero flow velocity [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 0)
DeclareVariable("room.vol.fluidLevel", "level of fluid in the vessel for treating heights of ports [m]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareVariable("room.vol.fluidLevel_max", "maximum level of fluid in the vessel [m]",\
 1, 0.0,1E+100,0.0,0,2561)
DeclareVariable("room.vol.vesselArea", "Area of the vessel used to relate to cross flow area of ports [m2]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.portsData_diameter[1]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.portsData_diameter[2]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.portsData_height[1]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.portsData_height[2]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.portsData_zeta_in[1]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.portsData_zeta_in[2]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.portsData_zeta_out[1]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.portsData_zeta_out[2]", "", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("room.vol.V", "Volume [m3]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("room.vol.sta0.p", "Absolute pressure of medium [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("room.vol.sta0.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,2561)
DeclareVariable("room.vol.rho_nominal", "Density, used to compute fluid mass [kg/m3|g/cm3]",\
 0, 0.0,1E+100,0.0,0,2561)
DeclareAlias2("room.theCon.Q_flow", "Heat flow rate from port_a -> port_b [W]", \
"room.theCon.port_a.Q_flow", 1, 5, 775, 0)
DeclareVariable("room.theCon.dT", "port_a.T - port_b.T [K,]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("room.theCon.port_a.T", "Port temperature [K|degC]", \
"cliBCVTB.uR[1]", 1, 5, 933, 4)
DeclareVariable("room.theCon.port_a.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,776)
DeclareAlias2("room.theCon.port_b.T", "Port temperature [K|degC]", "room.TAmb", 1,\
 5, 778, 4)
DeclareAlias2("room.theCon.port_b.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.theCon.port_a.Q_flow", -1, 5, 775, 132)
DeclareVariable("room.theCon.G", "Constant thermal conductance of material [W/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("room.TOut.port.T", "Port temperature [K|degC]", "room.TAmb", 1, 5,\
 778, 4)
DeclareAlias2("room.TOut.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 "room.theCon.port_a.Q_flow", 1, 5, 775, 132)
DeclareAlias2("room.TOut.T", "[K]", "room.TAmb", 1, 5, 778, 0)
DeclareAlias2("room.temSen.T", "[K]", "cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareAlias2("room.temSen.port.T", "Port temperature [K|degC]", \
"cliBCVTB.uR[1]", 1, 5, 933, 4)
DeclareVariable("room.temSen.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("room.ports[1].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Econ.port_Ret.m_flow", -1, 5, 380, 132)
DeclareAlias2("room.ports[1].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 4)
DeclareAlias2("room.ports[1].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "room.vol.medium.h", 1, 5, 723, 4)
DeclareAlias2("room.ports[2].m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareAlias2("room.ports[2].p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 4)
DeclareAlias2("room.ports[2].h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "room.vol.medium.h", 1, 5, 723, 4)
DeclareAlias2("room.TRoo", "Room air temperature [K]", "cliBCVTB.uR[1]", 1, 5, 933,\
 0)
DeclareVariable("room.TAmb", "Outside air temperature [K]", 273.15, 1.0,10000.0,\
300.0,0,512)
DeclareVariable("room.Qsen.Q_flow", "Fixed heat flow rate at port [W]", 0, \
0.0,0.0,0.0,0,513)
DeclareParameter("room.Qsen.T_ref", "Reference temperature [K|degC]", 226, \
293.15, 0.0,1E+100,0.0,0,560)
DeclareParameter("room.Qsen.alpha", "Temperature coefficient of heat flow rate [1/K]",\
 227, 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("room.Qsen.port.T", "Port temperature [K|degC]", "cliBCVTB.uR[1]", 1,\
 5, 933, 4)
DeclareVariable("room.Qsen.port.Q_flow", "Heat flow rate (positive if flowing from outside into the component) [W]",\
 0, 0.0,0.0,0.0,0,776)
DeclareVariable("room.Q_sen_d", "Fixed heat flow rate at port [W]", 0, 0.0,0.0,\
0.0,0,513)
DeclareParameter("TOutBC.amplitude", "Amplitude of sine wave", 228, 5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("TOutBC.freqHz", "Frequency of sine wave [Hz]", 229, \
1.15740740740741E-005, 0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC.phase", "Phase of sine wave [rad|deg]", 230, \
-1.5707963267949, 0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC.offset", "Offset of output signal", 231, 283.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC.startTime", "Output = offset for time < startTime [s]",\
 232, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("TOutBC.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("TOutBC.pi", "", 3.14159265358979, 0.0,0.0,0.0,0,2561)
DeclareParameter("TOutBC1.amplitude", "Amplitude of sine wave", 233, 5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("TOutBC1.freqHz", "Frequency of sine wave [Hz]", 234, \
1.15740740740741E-005, 0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC1.phase", "Phase of sine wave [rad|deg]", 235, \
-1.5707963267949, 0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC1.offset", "Offset of output signal", 236, 283.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC1.startTime", "Output = offset for time < startTime [s]",\
 237, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("TOutBC1.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("TOutBC1.pi", "", 3.14159265358979, 0.0,0.0,0.0,0,2561)
DeclareParameter("TOutBC2.amplitude", "Amplitude of sine wave", 238, 5, 0.0,0.0,\
0.0,0,560)
DeclareParameter("TOutBC2.freqHz", "Frequency of sine wave [Hz]", 239, \
1.15740740740741E-005, 0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC2.phase", "Phase of sine wave [rad|deg]", 240, \
-1.5707963267949, 0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC2.offset", "Offset of output signal", 241, 283.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("TOutBC2.startTime", "Output = offset for time < startTime [s]",\
 242, 0, 0.0,0.0,0.0,0,560)
DeclareVariable("TOutBC2.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("TOutBC2.pi", "", 3.14159265358979, 0.0,0.0,0.0,0,2561)
DeclareParameter("OAT.amplitude", "Amplitude of sine wave", 243, 3, 0.0,0.0,0.0,\
0,560)
DeclareParameter("OAT.freqHz", "Frequency of sine wave [Hz]", 244, \
1.15740740740741E-005, 0.0,0.0,0.0,0,560)
DeclareParameter("OAT.phase", "Phase of sine wave [rad|deg]", 245, \
-1.5707963267949, 0.0,0.0,0.0,0,560)
DeclareParameter("OAT.offset", "Offset of output signal [K]", 246, 303.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("OAT.startTime", "Output = offset for time < startTime [s]", 247,\
 0, 0.0,0.0,0.0,0,560)
DeclareAlias2("OAT.y", "Connector of Real output signal [K]", "room.TAmb", 1, 5,\
 778, 0)
DeclareVariable("OAT.pi", "", 3.14159265358979, 0.0,0.0,0.0,0,2561)
DeclareVariable("m_a_cc_d", "Q_cc_d/cp_a/12.7cooling coil air side nominal mass flow rate [kg/s]",\
 2.31, 0.0,0.0,0.0,0,513)
DeclareVariable("m_a_hc_d", "heating coil air side nominal mass flow rate [kg/s]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("m_w_cc_d", "Nominal mass flow rate [kg/s]", 0, 0.0,0.0,0.0,0,513)
DeclareParameter("T_ea_cc_d", "cooling coil entering air temp at design condition [K|degC]",\
 248, 299.85, 0.0,1E+100,0.0,0,560)
DeclareVariable("T_la_cc_d", "cooling coil entering air temp at design condition [K|degC]",\
 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("T_ew_cc_d", "cooling coil enetering chilled water temp at design condition [K|degC]",\
 249, 280.35, 0.0,1E+100,0.0,0,560)
DeclareParameter("Q_cc_d", "cooling coil design cooling capacity [W]", 250, 29454,\
 0.0,0.0,0.0,0,560)
DeclareParameter("dp_a_cc_d", "cooling coil air side design pressure drop [Pa|bar]",\
 251, 165, 0.0,0.0,0.0,0,560)
DeclareParameter("dp_w_cc_d", "cooling coil design chilled water pressure drop [Pa|bar]",\
 252, 4783, 0.0,0.0,0.0,0,560)
DeclareVariable("m_w_hc_d", "heating coil design mass flow rate [kg/s]", 0, \
0.0,0.0,0.0,0,513)
DeclareParameter("dp_a_hc_d", "heating coil air side design pressure drop [Pa|bar]",\
 253, 28.6, 0.0,0.0,0.0,0,560)
DeclareParameter("dp_w_hc_d", "heating coil design hot water pressure drop [Pa|bar]",\
 254, 2989, 0.0,0.0,0.0,0,560)
DeclareParameter("Q_hc_d", "heating coil design capacity [W]", 255, 37015, \
0.0,0.0,0.0,0,560)
DeclareParameter("T_ea_hc_d", "heating coil entering air temp at design condition [K|degC]",\
 256, 288.75, 0.0,1E+100,0.0,0,560)
DeclareVariable("T_ew_hc_d", "heating coil enetering hot water temp at design condition [K|degC]",\
 355.35, 0.0,1E+100,0.0,0,513)
DeclareVariable("Duct.allowFlowReversal", "= true to allow flow reversal, false restricts to design direction (port_a -> port_b)",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("Duct.port_a.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareAlias2("Duct.port_a.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "RHC.port_b.p", 1, 5, 447, 4)
DeclareAlias2("Duct.port_a.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "room.vol.medium.h", 1, 5, 723, 4)
DeclareAlias2("Duct.port_b.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", -1, 5, 803, 132)
DeclareAlias2("Duct.port_b.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "room.vol.medium.p", 1, 5, 722, 4)
DeclareAlias2("Duct.port_b.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 "RHC.port_b.h_outflow", 1, 5, 448, 4)
DeclareVariable("Duct.port_a_exposesState", "= true if port_a exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareVariable("Duct.port_b_exposesState", "= true if port_b.p exposes the state of a fluid volume",\
 false, 0.0,0.0,0.0,0,2563)
DeclareParameter("Duct.showDesignFlowDirection", "= false to hide the arrow in the model icon",\
 257, true, 0.0,0.0,0.0,0,2610)
DeclareVariable("Duct.dp_start", "Guess value of dp = port_a.p - port_b.p [Pa|bar]",\
 100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("Duct.m_flow_start", "Guess value of m_flow = port_a.m_flow [kg/s]",\
 0, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Duct.m_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Duct.show_T", "= true, if temperatures at port_a and port_b are computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Duct.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Duct.m_flow", "Mass flow rate in design flow direction [kg/s]",\
 0, 0.0,100000.0,2.31,0,512)
DeclareVariable("Duct.dp", "Pressure difference between port_a and port_b (= port_a.p - port_b.p) [Pa|Pa]",\
 0, 0.0,0.0,100.0,0,512)
DeclareVariable("Duct.V_flow", "Volume flow rate at inflowing port (positive when flow from port_a to port_b) [m3/s]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("Duct.port_a_T", "Temperature close to port_a, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareVariable("Duct.port_b_T", "Temperature close to port_b, if show_T = true [K|degC]",\
 300, 1.0,10000.0,300.0,0,512)
DeclareAlias2("Duct.state_a.p", "Absolute pressure of medium [Pa|bar]", \
"RHC.port_b.p", 1, 5, 447, 1024)
DeclareVariable("Duct.state_a.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,2560)
DeclareAlias2("Duct.state_b.p", "Absolute pressure of medium [Pa|bar]", \
"room.vol.medium.p", 1, 5, 722, 1024)
DeclareVariable("Duct.state_b.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,2560)
DeclareVariable("Duct.from_dp", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("Duct.m_flow_nominal", "Nominal mass flow rate [kg/s]", 2.31, \
0.0,100000.0,0.0,0,513)
DeclareVariable("Duct.dp_nominal", "Pressure [Pa|Pa]", 100, 0.0,1E+100,0.0,0,513)
DeclareVariable("Duct.linearized", "= true, use linear relation between m_flow and dp for any flow rate",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("Duct.k", "Flow coefficient, k=m_flow/sqrt(dp), with unit=(kg.m)^(1/2)",\
 0.231, 0.0,0.0,0.0,0,513)
DeclareVariable("Duct.m_flow_turbulent", "Turbulent flow if |m_flow| >= m_flow_turbulent, not a parameter because k can be a function of time [kg/s]",\
 0.693, -100000.0,100000.0,0.0,0,513)
DeclareVariable("Duct.sta0.p", "Absolute pressure of medium [Pa|bar]", 101325, \
0.0,100000000.0,100000.0,0,2561)
DeclareVariable("Duct.sta0.T", "Temperature of medium [K|degC]", 293.15, 1.0,\
10000.0,300.0,0,2561)
DeclareVariable("Duct.eta_nominal", "Dynamic viscosity, used to compute transition to turbulent flow regime [Pa.s]",\
 1.82E-005, 0.0,1E+100,0.0,0,2561)
DeclareParameter("Duct.h0", "Initial value for solver for specific enthalpy [J/kg]",\
 258, -5027.25, 0.0,0.0,0.0,0,2608)
DeclareVariable("Duct.conv", "Factor, needed to satisfy unit check [m.s2/kg]", 1,\
 0.0,0.0,0.0,0,2561)
DeclareVariable("Duct.conv2", "Factor, needed to satisfy unit check", 1, \
0.0,0.0,0.0,0,2561)
DeclareVariable("Duct.use_dh", "Set to true to specify hydraulic diameter", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("Duct.dh", "Hydraulic diameter [m]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("Duct.ReC", "Reynolds number where transition to turbulent starts",\
 4000, 0.0,0.0,0.0,0,513)
DeclareVariable("Duct.deltaM", "Fraction of nominal mass flow rate where transition to turbulent occurs [1]",\
 0.3, 0.01,1E+100,0.0,0,513)
DeclareVariable("dp_dt_d", "total duct work pressure drop at design condition [Pa|bar]",\
 100, 0.0,0.0,0.0,0,513)
DeclareParameter("gain2.k", "Gain value multiplied with input signal", 259, -1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("gain2.u", "Input signal connector", "DmprC.limiter.y", 1, 5, 21, 0)
DeclareVariable("gain2.y", "Output signal connector", 0, 0.0,1.0,0.0,0,512)
DeclareParameter("step.height", "Height of step", 260, -2, 0.0,0.0,0.0,0,560)
DeclareVariable("step.y", "Connector of Real output signal", 0, 0.0,0.0,0.0,0,640)
DeclareParameter("step.offset", "Offset of output signal y", 261, 297.15, \
0.0,0.0,0.0,0,560)
DeclareParameter("step.startTime", "Output y = offset for time < startTime [s]",\
 262, 1200, 0.0,0.0,0.0,0,560)
DeclareVariable("HC.allowFlowReversal1", "= true to allow flow reversal in medium 1, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("HC.allowFlowReversal2", "= true to allow flow reversal in medium 2, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("HC.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareVariable("HC.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("HC.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("HC.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", -1, 5, 803, 132)
DeclareVariable("HC.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("HC.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("HC.port_a2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "HC.m2_flow", 1, 5, 848, 132)
DeclareVariable("HC.port_a2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("HC.port_a2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("HC.port_b2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "HC.m2_flow", -1, 5, 848, 132)
DeclareVariable("HC.port_b2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100000, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("HC.port_b2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareParameter("HC.port_a1_exposesState", "= true if port_a1 exposes the state of a fluid volume",\
 263, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("HC.port_b1_exposesState", "= true if port_b1 exposes the state of a fluid volume",\
 264, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("HC.port_a2_exposesState", "= true if port_a1 exposes the state of a fluid volume",\
 265, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("HC.port_b2_exposesState", "= true if port_b1 exposes the state of a fluid volume",\
 266, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("HC.m1_flow_nominal", "Nominal mass flow rate [kg/s]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("HC.m2_flow_nominal", "Nominal mass flow rate [kg/s]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("HC.m1_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0, 0.0,100000.0,0.0,0,513)
DeclareVariable("HC.m2_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0, 0.0,100000.0,0.0,0,513)
DeclareVariable("HC.p_a1_start", "Guess value for inlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("HC.p_b1_start", "Guess value for outlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("HC.p_a2_start", "Guess value for inlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("HC.p_b2_start", "Guess value for outlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("HC.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("HC.m1_flow", "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction) [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 0)
DeclareVariable("HC.dp1", "Pressure difference between port_a1 and port_b1 [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("HC.m2_flow", "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction) [kg/s]",\
 0, -100000.0,100000.0,0.0,0,512)
DeclareVariable("HC.dp2", "Pressure difference between port_a2 and port_b2 [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("HC.sta_a1.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_a1.p", 1, 5, 830, 0)
DeclareVariable("HC.sta_a1.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("HC.sta_b1.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_b1.p", 1, 5, 832, 0)
DeclareVariable("HC.sta_b1.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("HC.sta_a2.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_a2.p", 1, 5, 834, 0)
DeclareVariable("HC.sta_a2.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareVariable("HC.sta_b2.p", "Absolute pressure of medium [Pa|bar]", 100000, \
0.0,100000000.0,100000.0,0,513)
DeclareVariable("HC.sta_b2.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("HC.state_a1_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_a1.p", 1, 5, 830, 1024)
DeclareVariable("HC.state_a1_inflow.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareAlias2("HC.state_b1_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_b1.p", 1, 5, 832, 1024)
DeclareVariable("HC.state_b1_inflow.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2624)
DeclareAlias2("HC.state_a2_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_a2.p", 1, 5, 834, 1024)
DeclareVariable("HC.state_a2_inflow.T", "Temperature of medium [K|degC]", 355.35,\
 1.0,10000.0,300.0,0,2561)
DeclareVariable("HC.state_b2_inflow.p", "Absolute pressure of medium [Pa|bar]", 100000,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("HC.state_b2_inflow.T", "Temperature of medium [K|degC]", 293.15,\
 1.0,10000.0,300.0,0,2561)
DeclareVariable("HC.computeFlowResistance1", "=true, compute flow resistance. Set to false to assume no friction",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("HC.from_dp1", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("HC.dp1_nominal", "Pressure [Pa|Pa]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("HC.linearizeFlowResistance1", "= true, use linear relation between m_flow and dp for any flow rate",\
 267, false, 0.0,0.0,0.0,0,562)
DeclareParameter("HC.deltaM1", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 268, 0.1, 0.0,0.0,0.0,0,560)
DeclareVariable("HC.computeFlowResistance2", "=true, compute flow resistance. Set to false to assume no friction",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("HC.from_dp2", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("HC.dp2_nominal", "Pressure [Pa|Pa]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("HC.linearizeFlowResistance2", "= true, use linear relation between m_flow and dp for any flow rate",\
 269, false, 0.0,0.0,0.0,0,562)
DeclareParameter("HC.deltaM2", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 270, 0.1, 0.0,0.0,0.0,0,560)
DeclareVariable("HC.Q1_flow", "Heat transfered into the medium 1 [W]", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("HC.Q2_flow", "Heat transfered into the medium 2 [W]", \
"HC.Q1_flow", -1, 5, 866, 0)
DeclareVariable("HC.eps", "Heat exchanger effectiveness [1]", 0, 0.0,1.0,0.0,0,513)
DeclareVariable("HC.T_in1", "Inlet temperature medium 1 [K|degC]", 0, 0.0,1E+100,\
0.0,0,512)
DeclareVariable("HC.T_in2", "Inlet temperature medium 2 [K|degC]", 0, 0.0,1E+100,\
0.0,0,512)
DeclareVariable("HC.C1_flow", "Heat capacity flow rate medium 1 [W/K]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("HC.C2_flow", "Heat capacity flow rate medium 2 [W/K]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("HC.CMin_flow", "Minimum heat capacity flow rate [W/K]", 0, 0.0,\
1E+100,0.0,0,512)
DeclareVariable("HC.QMax_flow", "Maximum heat flow rate [W]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("HC.gai1", "Auxiliary variable for smoothing at zero flow", 0, \
0.0,1.0,0.0,0,2560)
DeclareVariable("HC.gai2", "Auxiliary variable for smoothing at zero flow", 0, \
0.0,1.0,0.0,0,2560)
DeclareVariable("CC.allowFlowReversal1", "= true to allow flow reversal in medium 1, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CC.allowFlowReversal2", "= true to allow flow reversal in medium 2, false restricts to design direction (port_a -> port_b)",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("CC.port_a1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 132)
DeclareAlias2("CC.port_a1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "HC.port_b1.p", 1, 5, 832, 4)
DeclareVariable("CC.port_a1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("CC.port_b1.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "Duct.m_flow", -1, 5, 803, 132)
DeclareAlias2("CC.port_b1.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "SupF.port_a.p", 1, 5, 66, 4)
DeclareVariable("CC.port_b1.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,584)
DeclareAlias2("CC.port_a2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CC.m2_flow", 1, 5, 894, 132)
DeclareVariable("CC.port_a2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 0, 0.0,100000000.0,100000.0,0,520)
DeclareVariable("CC.port_a2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareAlias2("CC.port_b2.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 "CC.m2_flow", -1, 5, 894, 132)
DeclareVariable("CC.port_b2.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 100000, 0.0,100000000.0,100000.0,0,521)
DeclareVariable("CC.port_b2.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,520)
DeclareParameter("CC.port_a1_exposesState", "= true if port_a1 exposes the state of a fluid volume",\
 271, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CC.port_b1_exposesState", "= true if port_b1 exposes the state of a fluid volume",\
 272, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CC.port_a2_exposesState", "= true if port_a1 exposes the state of a fluid volume",\
 273, false, 0.0,0.0,0.0,0,2610)
DeclareParameter("CC.port_b2_exposesState", "= true if port_b1 exposes the state of a fluid volume",\
 274, false, 0.0,0.0,0.0,0,2610)
DeclareVariable("CC.m1_flow_nominal", "Nominal mass flow rate [kg/s]", 2.31, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("CC.m2_flow_nominal", "Nominal mass flow rate [kg/s]", 0, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("CC.m1_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0.000231, 0.0,100000.0,0.0,0,513)
DeclareVariable("CC.m2_flow_small", "Small mass flow rate for regularization of zero flow [kg/s]",\
 0, 0.0,100000.0,0.0,0,513)
DeclareVariable("CC.p_a1_start", "Guess value for inlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("CC.p_b1_start", "Guess value for outlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("CC.p_a2_start", "Guess value for inlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("CC.p_b2_start", "Guess value for outlet pressure [Pa|bar]", \
100000.0, 0.0,100000000.0,100000.0,0,513)
DeclareVariable("CC.show_V_flow", "= true, if volume flow rate at inflowing port is computed",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("CC.m1_flow", "Mass flow rate from port_a1 to port_b1 (m1_flow > 0 is design flow direction) [kg/s]",\
 "Duct.m_flow", 1, 5, 803, 0)
DeclareVariable("CC.dp1", "Pressure difference between port_a1 and port_b1 [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("CC.m2_flow", "Mass flow rate from port_a2 to port_b2 (m2_flow > 0 is design flow direction) [kg/s]",\
 0, -100000.0,100000.0,0.0,0,512)
DeclareVariable("CC.dp2", "Pressure difference between port_a2 and port_b2 [Pa|Pa]",\
 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("CC.sta_a1.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_b1.p", 1, 5, 832, 0)
DeclareVariable("CC.sta_a1.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("CC.sta_b1.p", "Absolute pressure of medium [Pa|bar]", \
"SupF.port_a.p", 1, 5, 66, 0)
DeclareVariable("CC.sta_b1.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("CC.sta_a2.p", "Absolute pressure of medium [Pa|bar]", \
"CC.port_a2.p", 1, 5, 880, 0)
DeclareVariable("CC.sta_a2.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareVariable("CC.sta_b2.p", "Absolute pressure of medium [Pa|bar]", 100000, \
0.0,100000000.0,100000.0,0,513)
DeclareVariable("CC.sta_b2.T", "Temperature of medium [K|degC]", 300, 1.0,\
10000.0,300.0,0,512)
DeclareAlias2("CC.state_a1_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"HC.port_b1.p", 1, 5, 832, 1024)
DeclareVariable("CC.state_a1_inflow.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2624)
DeclareAlias2("CC.state_b1_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"SupF.port_a.p", 1, 5, 66, 1024)
DeclareVariable("CC.state_b1_inflow.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2560)
DeclareAlias2("CC.state_a2_inflow.p", "Absolute pressure of medium [Pa|bar]", \
"CC.port_a2.p", 1, 5, 880, 1024)
DeclareVariable("CC.state_a2_inflow.T", "Temperature of medium [K|degC]", 300, \
1.0,10000.0,300.0,0,2561)
DeclareVariable("CC.state_b2_inflow.p", "Absolute pressure of medium [Pa|bar]", 100000,\
 0.0,100000000.0,100000.0,0,2561)
DeclareVariable("CC.state_b2_inflow.T", "Temperature of medium [K|degC]", 293.15,\
 1.0,10000.0,300.0,0,2561)
DeclareVariable("CC.computeFlowResistance1", "=true, compute flow resistance. Set to false to assume no friction",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CC.from_dp1", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CC.dp1_nominal", "Pressure [Pa|Pa]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("CC.linearizeFlowResistance1", "= true, use linear relation between m_flow and dp for any flow rate",\
 275, false, 0.0,0.0,0.0,0,562)
DeclareParameter("CC.deltaM1", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 276, 0.1, 0.0,0.0,0.0,0,560)
DeclareVariable("CC.computeFlowResistance2", "=true, compute flow resistance. Set to false to assume no friction",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CC.from_dp2", "= true, use m_flow = f(dp) else dp = f(m_flow)",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("CC.dp2_nominal", "Pressure [Pa|Pa]", 0, 0.0,1E+100,0.0,0,513)
DeclareParameter("CC.linearizeFlowResistance2", "= true, use linear relation between m_flow and dp for any flow rate",\
 277, false, 0.0,0.0,0.0,0,562)
DeclareParameter("CC.deltaM2", "Fraction of nominal flow rate where flow transitions to laminar [1]",\
 278, 0.1, 0.0,0.0,0.0,0,560)
DeclareVariable("CC.Q1_flow", "Heat transfered into the medium 1 [W]", 0, \
0.0,0.0,0.0,0,512)
DeclareAlias2("CC.Q2_flow", "Heat transfered into the medium 2 [W]", \
"CC.Q1_flow", -1, 5, 912, 0)
DeclareVariable("CC.eps", "Heat exchanger effectiveness [1]", 0, 0.0,1.0,0.0,0,513)
DeclareVariable("CC.T_in1", "Inlet temperature medium 1 [K|degC]", 0, 0.0,1E+100,\
0.0,0,512)
DeclareVariable("CC.T_in2", "Inlet temperature medium 2 [K|degC]", 0, 0.0,1E+100,\
0.0,0,512)
DeclareVariable("CC.C1_flow", "Heat capacity flow rate medium 1 [W/K]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("CC.C2_flow", "Heat capacity flow rate medium 2 [W/K]", 0, \
0.0,0.0,0.0,0,512)
DeclareVariable("CC.CMin_flow", "Minimum heat capacity flow rate [W/K]", 0, 0.0,\
1E+100,0.0,0,512)
DeclareVariable("CC.QMax_flow", "Maximum heat flow rate [W]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("CC.gai1", "Auxiliary variable for smoothing at zero flow", 0, \
0.0,1.0,0.0,0,2560)
DeclareVariable("CC.gai2", "Auxiliary variable for smoothing at zero flow", 0, \
0.0,1.0,0.0,0,2560)
DeclareVariable("eps_hc", "heating coil heat exchange effectiveness [1]", 0, \
0.0,0.0,0.0,0,513)
DeclareVariable("eps_cc", "cooling coil heat exchange effectiveness [1]", 0, \
0.0,0.0,0.0,0,513)
DeclareParameter("Tmsp.k", "Constant output value [K]", 279, 283.15, 0.0,0.0,0.0,\
0,560)
DeclareAlias2("Tmsp.y", "Connector of Real output signal [K]", "Tmsp.k", 1, 7, 279,\
 0)
DeclareParameter("Th.k", "Constant output value [K]", 280, 290.15, 0.0,0.0,0.0,0,560)
DeclareAlias2("Th.y", "Connector of Real output signal [K]", "Th.k", 1, 7, 280, 0)
DeclareVariable("Tsa_h.port.m_flow", "Mass flow rate from the connection point into the component [kg/s]",\
 0, 0.0,100000.0,0.0,0,777)
DeclareAlias2("Tsa_h.port.p", "Thermodynamic pressure in the connection point [Pa|bar]",\
 "HC.port_b1.p", 1, 5, 832, 4)
DeclareVariable("Tsa_h.port.h_outflow", "Specific thermodynamic enthalpy close to the connection point if m_flow < 0 [J/kg]",\
 0, -100000000.0,100000000.0,1000000.0,0,521)
DeclareAlias2("Tsa_h.T", "Temperature in port medium [K|degC]", "HCC.addP.u2", 1,\
 5, 506, 0)
DeclareParameter("Tssp1.k", "Constant output value [K]", 281, 284.15, 0.0,0.0,\
0.0,0,560)
DeclareAlias2("Tssp1.y", "Connector of Real output signal [K]", "Tssp1.k", 1, 7,\
 281, 0)
DeclareParameter("gain3.k", "Gain value multiplied with input signal", 282, -1, \
0.0,0.0,0.0,0,560)
DeclareAlias2("gain3.u", "Input signal connector", "EcoC.limiter.y", 1, 5, 481, 0)
DeclareAlias2("gain3.y", "Output signal connector", "Econ.damExh.y", 1, 5, 216, 0)
DeclareParameter("cliBCVTB.samplePeriod", "Sample period of component [s]", 283,\
 60, 1E-013,1E+100,0.0,0,560)
DeclareParameter("cliBCVTB.startTime", "First sample time instant [s]", 284, 0, \
0.0,0.0,0.0,0,560)
DeclareVariable("cliBCVTB.sampleTrigger", "True, if sample time instant", false,\
 0.0,0.0,0.0,0,2690)
DeclareVariable("cliBCVTB.firstTrigger", "Rising edge signals first sample instant",\
 false, 0.0,0.0,0.0,0,2706)
DeclareVariable("cliBCVTB.nDblWri", "Number of double values to write to the BCVTB",\
 2, 0.0,1E+100,0.0,0,517)
DeclareVariable("cliBCVTB.nDblRea", "Number of double values to be read from the BCVTB",\
 2, 0.0,1E+100,0.0,0,517)
DeclareParameter("cliBCVTB.flaDblWri[1]", "Flag for double values (0: use current value, 1: use average over interval, 2: use integral over interval)",\
 285, 0, 0.0,0.0,0.0,0,564)
DeclareParameter("cliBCVTB.flaDblWri[2]", "Flag for double values (0: use current value, 1: use average over interval, 2: use integral over interval)",\
 286, 0, 0.0,0.0,0.0,0,564)
DeclareParameter("cliBCVTB.uStart[1]", "Initial input signal, used during first data transfer with BCVTB",\
 287, 297.15, 0.0,0.0,0.0,0,560)
DeclareParameter("cliBCVTB.uStart[2]", "Initial input signal, used during first data transfer with BCVTB",\
 288, 288.15, 0.0,0.0,0.0,0,560)
DeclareVariable("cliBCVTB.activateInterface", "Set to false to deactivate interface and use instead yFixed as output",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("cliBCVTB.yRFixed[1]", "Fixed output, used if activateInterface=false",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("cliBCVTB.yRFixed[2]", "Fixed output, used if activateInterface=false",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("cliBCVTB.uR[1]", "Real inputs to be sent to the BCVTB", 300.0, \
1.0,10000.0,300.0,0,512)
DeclareVariable("cliBCVTB.uR[2]", "Real inputs to be sent to the BCVTB", 300.0, \
1.0,10000.0,300.0,0,512)
DeclareVariable("cliBCVTB.yR[1]", "Real outputs received from the BCVTB", 0, \
0.0,0.0,0.0,0,640)
DeclareVariable("cliBCVTB.yR[2]", "Real outputs received from the BCVTB", 0, \
0.0,0.0,0.0,0,640)
DeclareVariable("cliBCVTB.flaRea", "Flag received from BCVTB", 0, 0.0,0.0,0.0,0,644)
DeclareVariable("cliBCVTB.simTimRea", "Current simulation time received from the BCVTB [s]",\
 0, 0.0,0.0,0.0,0,656)
DeclareVariable("cliBCVTB.retVal", "Return value from the BSD socket data exchange",\
 0, 0.0,0.0,0.0,0,660)
DeclareVariable("cliBCVTB.socketFD", "Socket file descripter, or a negative value if an error occured",\
 0, 0.0,0.0,0.0,0,2565)
DeclareVariable("cliBCVTB._uStart[1]", "Initial input signal, used during first data transfer with BCVTB",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("cliBCVTB._uStart[2]", "Initial input signal, used during first data transfer with BCVTB",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("cliBCVTB.flaWri", "", 0, 0.0,0.0,0.0,0,2565)
DeclareState("cliBCVTB.uRInt[1]", "Value of integral", 4, 0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("cliBCVTB.der(uRInt[1])", "der(Value of integral)", 0, \
0.0,0.0,0.0,0,2560)
DeclareState("cliBCVTB.uRInt[2]", "Value of integral", 5, 0, 0.0,0.0,0.0,0,2592)
DeclareDerivative("cliBCVTB.der(uRInt[2])", "der(Value of integral)", 0, \
0.0,0.0,0.0,0,2560)
DeclareVariable("cliBCVTB.uRIntPre[1]", "Value of integral at previous sampling instance",\
 0, 0.0,0.0,0.0,0,2688)
DeclareVariable("cliBCVTB.uRIntPre[2]", "Value of integral at previous sampling instance",\
 0, 0.0,0.0,0.0,0,2688)
DeclareVariable("cliBCVTB.uRWri[1]", "Value to be sent to the interface", 0, \
0.0,0.0,0.0,0,640)
DeclareVariable("cliBCVTB.uRWri[2]", "Value to be sent to the interface", 0, \
0.0,0.0,0.0,0,640)
DeclareVariable("multiplex2_1.n1", "dimension of input signal connector 1", 1, \
0.0,0.0,0.0,0,517)
DeclareVariable("multiplex2_1.n2", "dimension of input signal connector 2", 1, \
0.0,0.0,0.0,0,517)
DeclareAlias2("multiplex2_1.u1[1]", "Connector of Real input signals 1 [K]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareAlias2("multiplex2_1.u2[1]", "Connector of Real input signals 2 [K]", \
"cliBCVTB.uR[2]", 1, 5, 934, 0)
DeclareAlias2("multiplex2_1.y[1]", "Connector of Real output signals", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareAlias2("multiplex2_1.y[2]", "Connector of Real output signals", \
"cliBCVTB.uR[2]", 1, 5, 934, 0)
DeclareVariable("deMultiplex2_1.n1", "dimension of output signal connector 1", 1,\
 0.0,0.0,0.0,0,517)
DeclareVariable("deMultiplex2_1.n2", "dimension of output signal connector 2", 1,\
 0.0,0.0,0.0,0,517)
DeclareAlias2("deMultiplex2_1.u[1]", "Connector of Real input signals", \
"cliBCVTB.yR[1]", 1, 5, 935, 0)
DeclareAlias2("deMultiplex2_1.u[2]", "Connector of Real input signals", \
"cliBCVTB.yR[2]", 1, 5, 936, 0)
DeclareAlias2("deMultiplex2_1.y1[1]", "Connector of Real output signals 1 [K]", \
"cliBCVTB.yR[1]", 1, 5, 935, 0)
DeclareAlias2("deMultiplex2_1.y2[1]", "Connector of Real output signals 2 [K]", \
"cliBCVTB.yR[2]", 1, 5, 936, 0)
DeclareVariable("DmprC.I.k", "Integrator gain [s-1]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("DmprC.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output)",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("DmprC.I.y_start", "Initial or guess value of output (= state)",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("DmprC.I.u", "Connector of Real input signal", "DmprC.addI.y", 1, 5,\
 955, 0)
DeclareState("DmprC.I.y", "Connector of Real output signal", 6, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("DmprC.I.der(y)", "der(Connector of Real output signal)", 0, \
0.0,0.0,0.0,0,512)
DeclareParameter("DmprC.addI.k1", "Gain of upper input", 289, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.addI.k2", "Gain of middle input", 290, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.addI.k3", "Gain of lower input", 291, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("DmprC.addI.u1", "Connector 1 of Real input signals [K]", \
"cliBCVTB.yR[1]", 1, 5, 935, 0)
DeclareAlias2("DmprC.addI.u2", "Connector 2 of Real input signals [K]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareAlias2("DmprC.addI.u3", "Connector 3 of Real input signals", \
"DmprC.gainTrack.y", 1, 5, 958, 0)
DeclareVariable("DmprC.addI.y", "Connector of Real output signals", 0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("DmprC.addSat.u1", "Connector of Real input signal 1", \
"DmprC.limiter.y", 1, 5, 21, 0)
DeclareAlias2("DmprC.addSat.u2", "Connector of Real input signal 2", \
"DmprC.limiter.u", 1, 5, 20, 0)
DeclareAlias2("DmprC.addSat.y", "Connector of Real output signal", \
"DmprC.gainTrack.u", 1, 5, 957, 0)
DeclareParameter("DmprC.addSat.k1", "Gain of upper input", 292, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("DmprC.addSat.k2", "Gain of lower input", 293, -1, 0.0,0.0,0.0,\
0,560)
DeclareVariable("DmprC.gainTrack.k", "Gain value multiplied with input signal", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("DmprC.gainTrack.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("DmprC.gainTrack.y", "Output signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("EcoC.I.k", "Integrator gain [s-1]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("EcoC.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output)",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("EcoC.I.y_start", "Initial or guess value of output (= state)", 0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("EcoC.I.u", "Connector of Real input signal", "EcoC.addI.y", 1, 5,\
 962, 0)
DeclareState("EcoC.I.y", "Connector of Real output signal", 7, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("EcoC.I.der(y)", "der(Connector of Real output signal)", 0, \
0.0,0.0,0.0,0,512)
DeclareParameter("EcoC.addI.k1", "Gain of upper input", 294, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.addI.k2", "Gain of middle input", 295, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.addI.k3", "Gain of lower input", 296, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("EcoC.addI.u1", "Connector 1 of Real input signals [K]", "Tmsp.k", 1,\
 7, 279, 0)
DeclareAlias2("EcoC.addI.u2", "Connector 2 of Real input signals [K]", \
"EcoC.addP.u2", 1, 5, 471, 0)
DeclareAlias2("EcoC.addI.u3", "Connector 3 of Real input signals", \
"EcoC.gainTrack.y", 1, 5, 965, 0)
DeclareVariable("EcoC.addI.y", "Connector of Real output signals", 0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("EcoC.addSat.u1", "Connector of Real input signal 1", \
"EcoC.limiter.y", 1, 5, 481, 0)
DeclareAlias2("EcoC.addSat.u2", "Connector of Real input signal 2", \
"EcoC.limiter.u", 1, 5, 480, 0)
DeclareAlias2("EcoC.addSat.y", "Connector of Real output signal", \
"EcoC.gainTrack.u", 1, 5, 964, 0)
DeclareParameter("EcoC.addSat.k1", "Gain of upper input", 297, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("EcoC.addSat.k2", "Gain of lower input", 298, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("EcoC.gainTrack.k", "Gain value multiplied with input signal", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("EcoC.gainTrack.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("EcoC.gainTrack.y", "Output signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("CCC.I.k", "Integrator gain [s-1]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("CCC.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output)",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("CCC.I.y_start", "Initial or guess value of output (= state)", 0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("CCC.I.u", "Connector of Real input signal", "CCC.addI.y", 1, 5, 969,\
 0)
DeclareState("CCC.I.y", "Connector of Real output signal", 8, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("CCC.I.der(y)", "der(Connector of Real output signal)", 0, \
0.0,0.0,0.0,0,512)
DeclareParameter("CCC.addI.k1", "Gain of upper input", 299, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.addI.k2", "Gain of middle input", 300, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.addI.k3", "Gain of lower input", 301, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("CCC.addI.u1", "Connector 1 of Real input signals [K]", \
"cliBCVTB.yR[2]", 1, 5, 936, 0)
DeclareAlias2("CCC.addI.u2", "Connector 2 of Real input signals [K]", \
"cliBCVTB.uR[2]", 1, 5, 934, 0)
DeclareAlias2("CCC.addI.u3", "Connector 3 of Real input signals", \
"CCC.gainTrack.y", 1, 5, 972, 0)
DeclareVariable("CCC.addI.y", "Connector of Real output signals", 0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("CCC.addSat.u1", "Connector of Real input signal 1 [1]", \
"CCC.limiter.y", 1, 5, 499, 0)
DeclareAlias2("CCC.addSat.u2", "Connector of Real input signal 2 [1]", \
"CCC.limiter.u", 1, 5, 498, 0)
DeclareAlias2("CCC.addSat.y", "Connector of Real output signal", \
"CCC.gainTrack.u", 1, 5, 971, 0)
DeclareParameter("CCC.addSat.k1", "Gain of upper input", 302, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("CCC.addSat.k2", "Gain of lower input", 303, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("CCC.gainTrack.k", "Gain value multiplied with input signal", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("CCC.gainTrack.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("CCC.gainTrack.y", "Output signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("HCC.I.k", "Integrator gain [s-1]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("HCC.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output)",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("HCC.I.y_start", "Initial or guess value of output (= state)", 0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("HCC.I.u", "Connector of Real input signal", "HCC.addI.y", 1, 5, 976,\
 0)
DeclareState("HCC.I.y", "Connector of Real output signal", 9, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("HCC.I.der(y)", "der(Connector of Real output signal)", 0, \
0.0,0.0,0.0,0,512)
DeclareParameter("HCC.addI.k1", "Gain of upper input", 304, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.addI.k2", "Gain of middle input", 305, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.addI.k3", "Gain of lower input", 306, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("HCC.addI.u1", "Connector 1 of Real input signals [K]", "Tssp1.k", 1,\
 7, 281, 0)
DeclareAlias2("HCC.addI.u2", "Connector 2 of Real input signals [K]", \
"HCC.addP.u2", 1, 5, 506, 0)
DeclareAlias2("HCC.addI.u3", "Connector 3 of Real input signals", \
"HCC.gainTrack.y", 1, 5, 979, 0)
DeclareVariable("HCC.addI.y", "Connector of Real output signals", 0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("HCC.addSat.u1", "Connector of Real input signal 1 [1]", \
"HCC.limiter.y", 1, 5, 516, 0)
DeclareAlias2("HCC.addSat.u2", "Connector of Real input signal 2 [1]", \
"HCC.limiter.u", 1, 5, 515, 0)
DeclareAlias2("HCC.addSat.y", "Connector of Real output signal", \
"HCC.gainTrack.u", 1, 5, 978, 0)
DeclareParameter("HCC.addSat.k1", "Gain of upper input", 307, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("HCC.addSat.k2", "Gain of lower input", 308, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("HCC.gainTrack.k", "Gain value multiplied with input signal", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("HCC.gainTrack.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("HCC.gainTrack.y", "Output signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("RHCC.I.k", "Integrator gain [s-1]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("RHCC.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output)",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("RHCC.I.y_start", "Initial or guess value of output (= state)", 0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("RHCC.I.u", "Connector of Real input signal", "RHCC.addI.y", 1, 5,\
 983, 0)
DeclareState("RHCC.I.y", "Connector of Real output signal", 10, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("RHCC.I.der(y)", "der(Connector of Real output signal)", 0, \
0.0,0.0,0.0,0,512)
DeclareParameter("RHCC.addI.k1", "Gain of upper input", 309, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.addI.k2", "Gain of middle input", 310, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.addI.k3", "Gain of lower input", 311, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("RHCC.addI.u1", "Connector 1 of Real input signals [K]", "Th.k", 1,\
 7, 280, 0)
DeclareAlias2("RHCC.addI.u2", "Connector 2 of Real input signals [K]", \
"cliBCVTB.uR[1]", 1, 5, 933, 0)
DeclareAlias2("RHCC.addI.u3", "Connector 3 of Real input signals", \
"RHCC.gainTrack.y", 1, 5, 986, 0)
DeclareVariable("RHCC.addI.y", "Connector of Real output signals", 0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("RHCC.addSat.u1", "Connector of Real input signal 1 [1]", "RHC.u", 1,\
 5, 464, 0)
DeclareAlias2("RHCC.addSat.u2", "Connector of Real input signal 2 [1]", \
"RHCC.limiter.u", 1, 5, 531, 0)
DeclareAlias2("RHCC.addSat.y", "Connector of Real output signal", \
"RHCC.gainTrack.u", 1, 5, 985, 0)
DeclareParameter("RHCC.addSat.k1", "Gain of upper input", 312, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("RHCC.addSat.k2", "Gain of lower input", 313, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("RHCC.gainTrack.k", "Gain value multiplied with input signal", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("RHCC.gainTrack.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("RHCC.gainTrack.y", "Output signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("FanC.I.k", "Integrator gain [s-1]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("FanC.I.initType", "Type of initialization (1: no init, 2: steady state, 3,4: initial output)",\
 3, 1.0,4.0,0.0,0,517)
DeclareVariable("FanC.I.y_start", "Initial or guess value of output (= state)", 0,\
 0.0,0.0,0.0,0,513)
DeclareAlias2("FanC.I.u", "Connector of Real input signal", "FanC.addI.y", 1, 5,\
 990, 0)
DeclareState("FanC.I.y", "Connector of Real output signal", 11, 0, 0.0,0.0,0.0,0,544)
DeclareDerivative("FanC.I.der(y)", "der(Connector of Real output signal)", 0, \
0.0,0.0,0.0,0,512)
DeclareParameter("FanC.addI.k1", "Gain of upper input", 314, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.addI.k2", "Gain of middle input", 315, -1, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.addI.k3", "Gain of lower input", 316, 1, 0.0,0.0,0.0,0,560)
DeclareAlias2("FanC.addI.u1", "Connector 1 of Real input signals [Pa]", "Prsp.k", 1,\
 7, 211, 0)
DeclareAlias2("FanC.addI.u2", "Connector 2 of Real input signals [Pa]", \
"SupF.medium.p", 1, 5, 83, 0)
DeclareAlias2("FanC.addI.u3", "Connector 3 of Real input signals", \
"FanC.gainTrack.y", 1, 5, 993, 0)
DeclareVariable("FanC.addI.y", "Connector of Real output signals", 0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("FanC.addSat.u1", "Connector of Real input signal 1", \
"FanC.limiter.y", 1, 5, 547, 0)
DeclareAlias2("FanC.addSat.u2", "Connector of Real input signal 2", \
"FanC.limiter.u", 1, 5, 546, 0)
DeclareAlias2("FanC.addSat.y", "Connector of Real output signal", \
"FanC.gainTrack.u", 1, 5, 992, 0)
DeclareParameter("FanC.addSat.k1", "Gain of upper input", 317, 1, 0.0,0.0,0.0,0,560)
DeclareParameter("FanC.addSat.k2", "Gain of lower input", 318, -1, 0.0,0.0,0.0,0,560)
DeclareVariable("FanC.gainTrack.k", "Gain value multiplied with input signal", 1,\
 0.0,0.0,0.0,0,513)
DeclareVariable("FanC.gainTrack.u", "Input signal connector", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("FanC.gainTrack.y", "Output signal connector", 0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)
#define NX_    12
#define NX2_   13
#define NU_    0
#define NY_    0
#define NW_    994
#define NP_    319
#define NPS_   0
#define NHash1_ 2116432361
#define NHash2_ -345354516
#define NHash3_ 1638708141
#define NI_    0
#define NRelF_ 24
#define NRel_  30
#define NTim_  5
#define NSamp_ 1
#define NCons_ 0
#define NA_    361
#define SizePre_ 11
#define SizeEq_ 24
#define SizeDelay_ 0
#define QNLmax_ 5
#define MAXAux 37
#define NrDymolaTimers_ 0
#define NWhen_ 2
#define NCheckIf_ 0
#define NGlobalHelp_ 136
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif

#include <dsblock5.c>

StartDataBlock
StartPreBlock
pre(W_[937],"cliBCVTB.flaRea", 0, 2);
pre(W_[939],"cliBCVTB.retVal", 0, 6);
pre(W_[938],"cliBCVTB.simTimRea", 0, 3);
pre(W_[944],"cliBCVTB.uRIntPre[1]", 0, 7);
pre(W_[945],"cliBCVTB.uRIntPre[2]", 0, 8);
pre(W_[946],"cliBCVTB.uRWri[1]", 0, 0);
pre(W_[947],"cliBCVTB.uRWri[2]", 0, 1);
preCont(W_[933],"cliBCVTB.uR[1]", DP_[224], 9);
preCont(W_[934],"cliBCVTB.uR[2]", 300.0, 10);
pre(W_[935],"cliBCVTB.yR[1]", 0, 4);
pre(W_[936],"cliBCVTB.yR[2]", 0, 5);
EndPreBlock
StartEqBlock
if (final_==2) {
W_[199] = W_[194];
W_[156] = W_[151];
W_[242] = W_[236];
W_[830] = W_[842];
W_[832] = W_[843];
W_[445] = W_[451];
W_[447] = W_[452];
W_[84] = W_[82];
W_[83] = W_[79];
W_[66] = W_[68];
}
DoRemember_(W_[881], 0, 22);
DoRemember_(W_[879], 0, 12);
DoRemember_(W_[883], 0, 23);
DoRemember_(W_[901], 300, 10);
DoRemember_(W_[199], W_[194], 17);
DoRemember_(W_[156], W_[151], 14);
DoRemember_(W_[242], W_[236], 15);
DoRemember_(W_[831], 0, 16);
DoRemember_(W_[830], W_[842], 7);
DoRemember_(W_[835], 0, 20);
DoRemember_(W_[832], W_[843], 6);
DoRemember_(W_[837], 0, 21);
DoRemember_(W_[856], 300, 11);
DoRemember_(W_[446], 0, 19);
DoRemember_(W_[445], W_[451], 4);
DoRemember_(W_[448], 0, 18);
DoRemember_(W_[447], W_[452], 3);
DoRemember_(W_[84], W_[82], 13);
DoRemember_(W_[83], W_[79], 8);
DoRemember_(W_[66], W_[68], 5);
DoRemember_(W_[641], 1, 0);
DoRemember_(W_[644], 0, 9);
DoRemember_(W_[724], 1, 2);
DoRemember_(W_[726], 0, 1);
EndEqBlock
UpdateQEvaluate(2)
UpdateSampleCounters(1)
EndDataBlock
